<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://zhangchuanfeng.me">
  <title>（转）JavaScript面向对象核心知识归纳 | 张传峰的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="面向对象概念
面向对象就是使用对象。面向对象开发就是使用对象开发。
面向过程就是用过程的方式进行开发。面向对象是对面向过程的封装。

三大特性抽象性所谓的抽象性就是：如果需要一个对象描述数据，需要抽取这个对象的核心数据

提出需要的核心属性和方法
不在特定的环境下无法明确对象的具体意义

封装性对象是将数据与共组合到一起，即封装">
<meta property="og:type" content="article">
<meta property="og:title" content="（转）JavaScript面向对象核心知识归纳">
<meta property="og:url" content="http://zhangchuanfeng.me/2016/12/02/object-oriented-programming-core/index.html">
<meta property="og:site_name" content="张传峰的博客">
<meta property="og:description" content="面向对象概念
面向对象就是使用对象。面向对象开发就是使用对象开发。
面向过程就是用过程的方式进行开发。面向对象是对面向过程的封装。

三大特性抽象性所谓的抽象性就是：如果需要一个对象描述数据，需要抽取这个对象的核心数据

提出需要的核心属性和方法
不在特定的环境下无法明确对象的具体意义

封装性对象是将数据与共组合到一起，即封装">
<meta property="og:image" content="http://ww3.sinaimg.cn/large/006y8mN6jw1fac8coydvnj30hb0bo0tk.jpg">
<meta property="og:updated_time" content="2016-12-03T07:58:47.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="（转）JavaScript面向对象核心知识归纳">
<meta name="twitter:description" content="面向对象概念
面向对象就是使用对象。面向对象开发就是使用对象开发。
面向过程就是用过程的方式进行开发。面向对象是对面向过程的封装。

三大特性抽象性所谓的抽象性就是：如果需要一个对象描述数据，需要抽取这个对象的核心数据

提出需要的核心属性和方法
不在特定的环境下无法明确对象的具体意义

封装性对象是将数据与共组合到一起，即封装">
<meta name="twitter:image" content="http://ww3.sinaimg.cn/large/006y8mN6jw1fac8coydvnj30hb0bo0tk.jpg">
  
    <link rel="alternative" href="/atom.xml" title="张传峰的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/img/niuniu.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">张传峰</a></h1>
		</hgroup>

		
		<p class="header-subtitle">一直在路上</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/demo/index.html">Demo</a></li>
	        
				<li><a href="/about/index.html">关于&amp;留言</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/ChuanfengZhang" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/chuckzhang91" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/zhang-chuan-feng-13" title="zhihu">zhihu</a>
		        
					<a class="mail" target="_blank" href="/wfhtzcf@gmail.com" title="mail">mail</a>
		        
					<a class="linkedin" target="_blank" href="https://cn.linkedin.com/in/chuckzhang94" title="linkedin">linkedin</a>
		        
			</div>
		</nav>
	</header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">张传峰</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/img/niuniu.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">张传峰</h1>
			</hgroup>
			
			<p class="header-subtitle">一直在路上</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/demo/index.html">Demo</a></li>
		        
					<li><a href="/about/index.html">关于&amp;留言</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/ChuanfengZhang" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/chuckzhang91" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/zhang-chuan-feng-13" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="/wfhtzcf@gmail.com" title="mail">mail</a>
			        
						<a class="linkedin" target="_blank" href="https://cn.linkedin.com/in/chuckzhang94" title="linkedin">linkedin</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-object-oriented-programming-core" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      （转）JavaScript面向对象核心知识归纳
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol>
<li>面向对象就是使用对象。面向对象开发就是使用对象开发。</li>
<li>面向过程就是用过程的方式进行开发。面向对象是对面向过程的封装。</li>
</ol>
<h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="抽象性"><a href="#抽象性" class="headerlink" title="抽象性"></a>抽象性</h3><p>所谓的抽象性就是：如果需要一个对象描述数据，需要抽取这个对象的核心数据</p>
<ol>
<li>提出需要的核心属性和方法</li>
<li>不在特定的环境下无法明确对象的具体意义</li>
</ol>
<h3 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h3><p>对象是将数据与共组合到一起，即封装<br><a id="more"></a></p>
<ol>
<li>JS 对象就是键值对的集合，键值如果是数据（基本数据、符合数据、空数据）就称为属性，如果键值是函数那么就称为方法</li>
<li>对象就是将属性与方法封装起来</li>
<li>方法是将过程封装起来</li>
</ol>
<h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>所谓继承性就是自己没有但别人有，拿过来成为自己的，就是继承。继承是实现复用的一种手段</p>
<ul>
<li>在 Java 等语言中继承满足一个 class 的规则，类是一个 class，它规定了一个对象有什么属性和方法</li>
<li>在这些语言中继承是 class 之间的继承，一个 class 继承另一个 class 创建出来的对象就同时具有两个 class 的成员</li>
</ul>
<p>在 JS 中没有明确的继承语法（ES6提供了 class extend 语法），一般都是按照继承的理念实现对象的成员扩充实现继承，因此 JS 中实现继承的方法非常多。</p>
<p>传统继承基于类，JS 继承基于对象</p>
<p>一个简单的继承模式：混入（mix）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span> (<span class="params">o1,o2</span>)</span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> o2)&#123;</div><div class="line">		o1[k] = o2[k];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="关于面向对象的其他概念"><a href="#关于面向对象的其他概念" class="headerlink" title="关于面向对象的其他概念"></a>关于面向对象的其他概念</h2><h3 id="类-class：在-JS-中就是构造函数"><a href="#类-class：在-JS-中就是构造函数" class="headerlink" title="类 class：在 JS 中就是构造函数"></a>类 class：在 JS 中就是构造函数</h3><ul>
<li>在传统的面向对象语言中，使用一个叫类的东西定义模板，然后使用模板创建对象</li>
<li>在构造方法中也有类似的功能，因此也称其为类</li>
</ul>
<h3 id="实例（instance）与对象（object）"><a href="#实例（instance）与对象（object）" class="headerlink" title="实例（instance）与对象（object）"></a>实例（instance）与对象（object）</h3><ul>
<li>实例一般是指某一个构造函数创建出来的对象，我们称为 XXXX 构造函数的实例</li>
<li>实例就是对象。对象是一个泛称</li>
<li>实例与对象是一个近义词</li>
</ul>
<h3 id="键值对与属性和方法"><a href="#键值对与属性和方法" class="headerlink" title="键值对与属性和方法"></a>键值对与属性和方法</h3><ul>
<li>在 JS 中键值对的集合称为对象</li>
<li>如果值为数据（非函数），就称该键值对为属性</li>
<li>如果值为函数（方法），就称该键值对为方法 method</li>
</ul>
<h3 id="父类与子类（基类和派生类）"><a href="#父类与子类（基类和派生类）" class="headerlink" title="父类与子类（基类和派生类）"></a>父类与子类（基类和派生类）</h3><ul>
<li>传统的面向对象语言中使用类来实现继承那么就有父类、子类的概念</li>
<li>父类又称为基类，子类又称为派生类</li>
<li>在 JS 中没有类的概念，在 JS 中常常称为父对象、子对象，基对象、派生对象</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="构造函数是干什么用的"><a href="#构造函数是干什么用的" class="headerlink" title="构造函数是干什么用的"></a>构造函数是干什么用的</h3><ul>
<li>初始化数据的</li>
<li>在 JS 中给对象添加属性用的，初始化属性值用的</li>
</ul>
<h3 id="面向对象的过程"><a href="#面向对象的过程" class="headerlink" title="面向对象的过程"></a>面向对象的过程</h3><ol>
<li>代码： var p = new Person();</li>
<li>首先运算符 new 创建了一个对象，类似于{}，是一个没有任何（自定义）成员的对象<ul>
<li>使用 new 创建对象，那么对象的类型就是创建他的构造函数名</li>
<li>使用{}无论如何都是 Object 类型，相当于 new Object</li>
</ul>
</li>
<li>然后调用构造函数，为其初始化成员<ul>
<li>构造函数在调用的一开始，有一个赋值操作，即 this = 刚刚创立出来的对象</li>
<li>因此在构造函数中 this 表示刚刚创建出来的对象</li>
</ul>
</li>
<li>在构造函数中利用对象的动态特性为其对象添加成员</li>
</ol>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h3><p>域表示的就是范围，即作用域，就是一个名字在什么地方可以使用，什么地方不能使用</p>
<h3 id="JS-中词法作用域的规则"><a href="#JS-中词法作用域的规则" class="headerlink" title="JS 中词法作用域的规则"></a>JS 中词法作用域的规则</h3><ul>
<li>函数允许访问函数外部的数据</li>
<li>整个代码结构中只有函数可以限定作用域</li>
<li>作用规则首先使用提升规则分析</li>
<li>如果当前作用域中有了名字了，就不考虑外面的名字</li>
</ul>
<h3 id="属性搜索原则"><a href="#属性搜索原则" class="headerlink" title="属性搜索原则"></a>属性搜索原则</h3><ul>
<li>所谓的属性搜索原则，就是对象在访问属性或方法的时候，首先在当前对象中查找</li>
<li>如果当前对象中存储着属性或方法，停止查找，直接使用该属性或方法</li>
<li>如果当前对象没有该成员，那么再在其原型对象中查找</li>
<li>如果原型对象中含有该成员，那么停止查找，直接使用</li>
<li>如果原型中还没有，就到原型的原型中查找</li>
<li>如此往复，直到Object.protitype还没有，那么就返回undefined</li>
<li>如果是调用方法就报错，该xxx不是一个函数</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><p>闭包的含义就是闭合，包起来，简单的来说，就是一个具有封闭功能与包裹功能的结构。所谓的闭包就是一个具有封闭的对外不公开的，包裹结构，或空间。</p>
<h3 id="为什么函数可以构成闭包？"><a href="#为什么函数可以构成闭包？" class="headerlink" title="为什么函数可以构成闭包？"></a>为什么函数可以构成闭包？</h3><p>闭包就是一个具有封闭与包裹功能的结构，是为了实现具有私有访问空间的函数的。函数可以构成闭包。函数内部定义的数据函数外部无法访问，即函数具有封闭性；函数可以封装代码即具有包裹性，所以函数可以构成闭包。</p>
<h3 id="闭包有什么用"><a href="#闭包有什么用" class="headerlink" title="闭包有什么用"></a>闭包有什么用</h3><p>闭包不允许外部访问，要解决的问题就是让外部间接访问函数内部的数据。事实上，通过使用闭包，我们可以做很多事情。比如模拟面向对象的代码风格；更优雅，更简洁的表达出代码；在某些方面提升代码的执行效率。利用闭包可以实现如下需求：</p>
<ul>
<li>匿名自执行函数一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。</li>
<li>缓存闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</li>
<li>实现封装</li>
<li>模拟面向对象的代码风格</li>
</ul>
<h3 id="闭包的基本模型"><a href="#闭包的基本模型" class="headerlink" title="闭包的基本模型"></a>闭包的基本模型</h3><ul>
<li><strong>对象模式：</strong>函数内部定义个一个对象，对象中绑定多个函数（方法），返回对象，利用对象的方法访问函数内的数据</li>
<li><strong>函数模式：</strong>函数内部定义一个新函数，返回新函数，用新函数获得函数内的数据</li>
<li><strong>沙箱模式：</strong>沙箱模式就是一个自调用函数，代码写到函数中一样会执行，但是不会与外界有任何的影响</li>
</ul>
<h3 id="闭包的作用举例"><a href="#闭包的作用举例" class="headerlink" title="闭包的作用举例"></a>闭包的作用举例</h3><ul>
<li>获得超过一个数据，返回一个对象</li>
<li>完成读取一个数据和修改这个数据，对象里面的 get、set 方法</li>
</ul>
<h3 id="闭包的性能问题"><a href="#闭包的性能问题" class="headerlink" title="闭包的性能问题"></a>闭包的性能问题</h3><p>函数执行需要内存，那么函数中定义的变量，会在函数执行结束后自动回收，凡是因为闭包结构的，被引出的数据，如果还有变量引用这些数据的话，那么这些数据就不会被回收。<strong>因此在使用闭包的时候如果不使用某些数据了，一定要赋值一个null</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> num = <span class="number">123</span>;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> num;</div><div class="line">	&#125;;</div><div class="line">&#125;)();</div><div class="line"><span class="comment">// f 引用着函数，函数引用着变量num</span></div><div class="line"><span class="comment">// 因此在不使用该数据的时候，最好写上</span></div><div class="line">f = <span class="literal">null</span>;</div></pre></td></tr></table></figure>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h3><p>一句话说明什么是原型：原型能存储我们的方法，构造函数创建出来的实例对象能够引用原型中的方法。</p>
<p>JS中一切皆对象，而每个对象都有一个原型（Object除外），这个原型，大概就像Java中的父类，所以，基本上你可以认为原型就是这个对象的父对象，即每一个对象（Object除外）内部都保存了它自己的父对象，这个父对象就是原型。一般创建的对象如果没有特别指定原型，那么它的原型就是Object(这就很类似Java中所有的类默认继承自Object类)。</p>
<p>ES6通过引入class ,extends等关键字，以一种语法糖的形式把构造函数包装成类的概念，更便于大家理解。是希望开发者不再花精力去关注原型以及原型链，也充分说明原型的设计意图和类是一样的。</p>
<h3 id="查看对象的原型"><a href="#查看对象的原型" class="headerlink" title="查看对象的原型"></a>查看对象的原型</h3><p>当对象被创建之后，查看它们的原型的方法不止一种，以前一般使用对象的<code>_proto__</code>属性，ES6推出后，推荐用 Object.getPrototypeOf()方法来获取对象的原型.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = <span class="string">'lala'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line"><span class="built_in">console</span>.log(a.__proto__)</div><div class="line"><span class="comment">//输出：Object &#123;&#125;</span></div><div class="line">  </div><div class="line"><span class="comment">//推荐使用这种方式获取对象的原型</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(a))</div><div class="line"><span class="comment">//输出：Object &#123;&#125;</span></div></pre></td></tr></table></figure>
<p>无论对象是如何创建的，默认原型都是Object，在这里需要提及的比较特殊的一点就是，通过构造函数来创建对象，函数A本身也是一个对象，而A有两个指向表示原型的属性，分别是proto和prototype，而且两个属性并不相同</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name=<span class="string">'lala'</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> A();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(A.prototype) </div><div class="line"><span class="comment">//输出：Object &#123;&#125;</span></div><div class="line">  </div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(A.__proto__) </div><div class="line"><span class="comment">//输出：function () &#123;&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(A))</div><div class="line"><span class="comment">//输出：function () &#123;&#125;</span></div></pre></td></tr></table></figure>
<p>函数的 prototype 属性只有在当作构造函数创建的时候，把自身的 prototype 属性值赋给对象的原型。而实际上，作为函数本身，它的原型应该是function对象，然后function对象的原型才是Object。</p>
<p><strong>总之，建议使用ES6推荐的查看原型和设置原型的方法。</strong></p>
<h3 id="原型的用法"><a href="#原型的用法" class="headerlink" title="原型的用法"></a>原型的用法</h3><p>其实原型和类的继承的用法是一致的：当你想用某个对象的属性时，将当前对象的原型指向该对象，你就拥有了该对象的使用权了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name=<span class="string">'world '</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.bb=<span class="string">"hello"</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> A();</div><div class="line"></div><div class="line"><span class="keyword">var</span> b=<span class="keyword">new</span> B();</div><div class="line"><span class="comment">//将b设置为a的原型,此处有一个问题，即a的constructor也指向了B构造函数，可能需要纠正 </span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(a,b);</div><div class="line"></div><div class="line">a.constructor=A;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a.bb); <span class="comment">//hello</span></div></pre></td></tr></table></figure>
<p>如果使用ES6来做的话则简单许多，甚至不涉及到prototype这个属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</div><div class="line"></div><div class="line">     <span class="keyword">constructor</span>()&#123;</div><div class="line"></div><div class="line">         <span class="keyword">this</span>.bb=<span class="string">'hello'</span></div><div class="line"></div><div class="line">     &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</div><div class="line"></div><div class="line">     <span class="keyword">constructor</span>()&#123;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>();</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.name=<span class="string">'world'</span>;</div><div class="line"></div><div class="line">     &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">  </div><div class="line"></div><div class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> A();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a.bb+<span class="string">" "</span>+a.name); <span class="comment">//hello world   </span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(A))  <span class="comment">//"function"</span></div></pre></td></tr></table></figure>
<p>怎么样？是不是已经完全看不到原型的影子了？活脱脱就是类继承，但是你也看得到实际上类A 的类型是 function，所以说，本质上 class 在 JS 中是一种语法糖，JS 继承的本质依然是原型，不过，ES6 引入 class，extends 来掩盖原型的概念也是一个很友好的举动，对于长期学习那些类继承为基础的面对对象编程语言的程序员而言。</p>
<p><strong>尽可能理解原型，尽可能用class这种语法糖。</strong></p>
<p>好了，问自己两个问题：</p>
<ol>
<li>为什么要使用原型？ –提高函数的复用性</li>
<li>为什么属性不放在原型上而方法要放在原型上？<ul>
<li>利用对象的动态特性：构造函数.prototype.xxx = vvv</li>
<li>利用直接替换</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> Student.prototype = &#123;</div><div class="line"></div><div class="line">    <span class="attr">sayHello</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</div><div class="line"></div><div class="line">    <span class="attr">study</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h3><p>凡是对象就有原型，那么原型又是对象，因此凡是给定一个对象，那么就可以找到他的原型，原型还有原型，那么如此下去，就构成一个对象的序列，称该结构为原型链。</p>
<p>这个概念其实也变得比较简单，可以类比类的继承链条，即每个对象的原型往上追溯，一直到Object为止，这组成了一个链条，将其中的对象串联起来，当查找当前对象的属性时，如果没找到，就会沿着这个链条去查找，一直到Object，如果还没发现，就会报undefined。</p>
<h3 id="原型链的结构"><a href="#原型链的结构" class="headerlink" title="原型链的结构"></a>原型链的结构</h3><p>凡是使用构造函数，创建出对象，并且没有利用赋值的方式修改原型，就说该对象保留默认的原型链。</p>
<p>默认原型链结构是什么样子呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"><span class="comment">//p 具有默认的原型链</span></div></pre></td></tr></table></figure>
<p>默认的原型链结构就是：<em>当前对象 -&gt; 构造函数.prototype -&gt; Object.prototype -&gt; null</em></p>
<p>在实现继承的时候，有时候会利用替换原型链结构的方式实现原型继承，那么原型链结构就会发生改变</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">DunizbCollection</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">DunizbCollection.prototype = [];</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> DunizbCollection();</div></pre></td></tr></table></figure>
<p>此时arr对象的原型链结构被指向了数组对象的原型链结构了：<em>arr -&gt; [] -&gt; Array.prototype -&gt; Object.prototype -&gt; null</em></p>
<h3 id="用图形表示对象的原型链结构"><a href="#用图形表示对象的原型链结构" class="headerlink" title="用图形表示对象的原型链结构"></a>用图形表示对象的原型链结构</h3><p>以如下代码为例绘制原型链结构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<p>原型链结构图为：<br><img src="http://ww3.sinaimg.cn/large/006y8mN6jw1fac8coydvnj30hb0bo0tk.jpg" alt=""></p>
<p>使用原型需要注意两点：</p>
<ol>
<li>原型继承链条不要太长，否则会出现效率问题</li>
<li>指定原型时，注意 constructor 也会改变</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>实现继承有两种常见方式：</p>
<h4 id="混合式继承："><a href="#混合式继承：" class="headerlink" title="混合式继承："></a>混合式继承：</h4><p>最简单的继承就是将别的对象的属性强加到我身上，那么我就有这个成员了。<br>混合式继承的简单描述：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">Person.prototype.extend = <span class="function"><span class="keyword">function</span> (<span class="params"> o </span>) </span>&#123;</div><div class="line">     <span class="keyword">for</span> ( <span class="keyword">var</span> k <span class="keyword">in</span> o ) &#123;</div><div class="line">          <span class="keyword">this</span>[ k ] = o[ k ];</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line">Person.prototype.extend(&#123;</div><div class="line">      <span class="attr">run</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">'我能跑了'</span> ); &#125;,</div><div class="line">      <span class="attr">eat</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">'我可以吃了'</span> ); &#125;,</div><div class="line">      <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">'我吃饱了'</span> ); &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><p>利用原型也可以实现继承，不需要在我身上添加任何成员，只要原型有了我就有了。</p>
<h4 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h4><p>这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数，而函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在（将来）新创建的对象上执行构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"> name, age, gender </span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">        <span class="keyword">this</span>.gender = gender;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 需要提供一个 Student 的构造函数创建学生对象</span></div><div class="line"><span class="comment">// 学生也应该有 name, age, gender, 同时还需要有 course 课程</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params"> name, age, gender, course </span>) </span>&#123;</div><div class="line">        Person.call( <span class="keyword">this</span>, name, age, gender )；</div><div class="line">        <span class="keyword">this</span>.course = course;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在《JavaScript高级程序设计（第三版）》中详细介绍了继承的6种方式</p>
<h2 id="函数的四种调用模式"><a href="#函数的四种调用模式" class="headerlink" title="函数的四种调用模式"></a>函数的四种调用模式</h2><h3 id="函数模式"><a href="#函数模式" class="headerlink" title="函数模式"></a>函数模式</h3><p>就是一个简单的函数调用。函数名的前面没有任何引导内容。</p>
<h3 id="方法模式"><a href="#方法模式" class="headerlink" title="方法模式"></a>方法模式</h3><p>方法一定式依附于一个对象，将函数赋值给对象的一个属性，那么就成了方法。</p>
<h3 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h3><p>创建对象的时候构造函数做了什么？由于构造函数只是给 this 添加成员，没有做其他事情。而方法也可以完成这个操作，就是 this 而言，构造函数与方法没有本质的区别。</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ol>
<li>使用 new 关键字，来引导函数</li>
<li>构造函数中的 this 与方法中的一样，表示对象，但是构造函数中的对象是刚刚创建出来的对象</li>
<li>构造函数中不需要 return，就会默认的 return this<ul>
<li>如果手动添加return ，就相当于 return this</li>
<li>如果手动的添加 return 基本类型，无效，还是保留原来 返回 this</li>
<li>如果手动添加的 return null，或 return undefined ，无效</li>
<li>如果手动添加 return 对象类型，那么原来创建的 this 就会被丢掉，返回的是 return 后面的对象</li>
</ul>
</li>
</ol>
<h3 id="创建对象的模式"><a href="#创建对象的模式" class="headerlink" title="创建对象的模式"></a>创建对象的模式</h3><ol>
<li>工厂方法。工厂就是用来生产的，因此如果函数创建对象并返回，就称该函数为工厂函数</li>
<li>构造方法</li>
<li>寄生式创建</li>
<li>混合式创建</li>
</ol>
<h3 id="上下文调用模式"><a href="#上下文调用模式" class="headerlink" title="上下文调用模式"></a>上下文调用模式</h3><p>上下文就是环境。就是自定义设置 this 的含义</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul>
<li>函数名.apply(对象,[参数]);</li>
<li>函数名.call(对象，参数);</li>
</ul>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><ol>
<li>函数名就是表示函数本身，使用函数进行调用的时候默认 this 是全局变量</li>
<li>函数名也可以是方法提供，使用方法调用的时候，this 是指向当前对象</li>
<li>使用 apply 进行调用后，无论是函数还是方法都无效了，我们的 this ，由 apply 的第一个参数决定</li>
</ol>
<h4 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h4><p>无论是 call 还是 apply 在没有后面的参数的情况下（函数无参数，方法无参数）是完全一致的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span> );</div><div class="line">&#125;</div><div class="line">foo.apply( obj );</div><div class="line">foo.call( obj );</div></pre></td></tr></table></figure>
<p>第一个参数的使用也是有规则的:</p>
<p>1.如果传入的是一个对象，那么就相当于设置该函数中的 this 为参数</p>
<p>2.如果不传入参数，或传入 null 、undefined 等，那么相当于 this 默认为 window</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">foo();</div><div class="line">foo.apply();</div><div class="line">foo.apply( <span class="literal">null</span> );</div><div class="line">foo.call( <span class="literal">undefined</span> );</div></pre></td></tr></table></figure>
<p>3.如果传入的是基本类型，那么 this 就是基本类型对应的包装类型的引用<br>在使用上下文调用的时候，原函数（方法）可能会带有参数，那么这个参数再上下文调用中使用 第二个（第 n 个）参数来表示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"> num </span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( num );</div><div class="line">&#125;</div><div class="line">foo.apply( <span class="literal">null</span>, [ <span class="number">123</span> ] );</div><div class="line"><span class="comment">// 等价于</span></div><div class="line">foo( <span class="number">123</span> );</div></pre></td></tr></table></figure>
<hr>
<p><strong>参考资料</strong></p>
<ul>
<li>本文原型部分部分引用自<a href="http://www.admin10000.com/document/9336.html" target="_blank" rel="external">《JavaScript原型详解》</a>，版权归原作者所有</li>
<li><a href="http://blog.csdn.net/sunlylorn/article/details/6534610" target="_blank" rel="external">js闭包的用途</a></li>
</ul>
<hr>
<p>本文首发于 <a href="http://www.imooc.com/u/173711/articles" target="_blank" rel="external">慕课网</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/12/02/object-oriented-programming-core/" class="archive-article-date">
  	<time datetime="2016-12-02T01:12:54.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-12-02</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript面向对象/">JavaScript面向对象</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2016/12/02/object-oriented-programming-notes/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          （转）《JavaScript面向对象精要》读书笔记
        
      </div>
    </a>
  
  
    <a href="/2016/11/24/cross-domain/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">跨域-知识</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>








<section id="comments">
  <!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="post-object-oriented-programming-core" data-title="（转）JavaScript面向对象核心知识归纳" data-url="http://zhangchuanfeng.me/2016/12/02/object-oriented-programming-core/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"chuckzhang"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0]
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->
</section>


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 张传峰
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/JavaScript面向对象/" style="font-size: 15px;">JavaScript面向对象</a> <a href="/tags/Mac/" style="font-size: 15px;">Mac</a> <a href="/tags/RequireJS/" style="font-size: 10px;">RequireJS</a> <a href="/tags/Webstorm/" style="font-size: 10px;">Webstorm</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/布局/" style="font-size: 10px;">布局</a> <a href="/tags/建站/" style="font-size: 20px;">建站</a> <a href="/tags/快捷键/" style="font-size: 15px;">快捷键</a> <a href="/tags/方法论/" style="font-size: 10px;">方法论</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/跨域/" style="font-size: 10px;">跨域</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.ruanyifeng.com/home.html">阮一峰的个人网站</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.liaoxuefeng.com">廖雪峰的官方网站</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.dandyweng.com">翁天信</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.lixuejiang.me">风君子</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.kquanr.com">PhotoArtLife</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://liuyanwei.jumppo.com/index.html">刘彦玮的技术博客</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://jser.me">草依山的Javascript世界</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">stormzhang</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://heeroluo.net">Heero&#39;s Blog</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://luckykun.com/">luckykun</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://jcidea.cc">刘健超(Jc)&#39;s Blog</a>
  	        
  	        </div>
  		
    	</section>
    

    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

    
  </div>
</body>
</html>
