<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张传峰的博客</title>
  <subtitle>一直在路上</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangchuanfeng.me/"/>
  <updated>2016-12-02T12:12:52.000Z</updated>
  <id>http://zhangchuanfeng.me/</id>
  
  <author>
    <name>张传峰</name>
    <email>wfhtzcf@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《JavaScript面向对象精要》读书笔记</title>
    <link href="http://zhangchuanfeng.me/2016/12/02/%E3%80%8AJavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B2%BE%E8%A6%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://zhangchuanfeng.me/2016/12/02/《JavaScript面向对象精要》读书笔记/</id>
    <published>2016-12-02T13:05:16.000Z</published>
    <updated>2016-12-02T12:12:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript面向对象精要》这本书虽然不够100页，但都是精华，不愧是《JavaScript高级程序设计》作者 Nicholas C.Zakas 的最新力作。</p>
<p>下面是我的读书笔记（ES5）：</p>
<p>##1.原始类型和引用类型</p>
<p>###1.1 什么是类型<br><strong>原始类型</strong> 保存为简单数据值。<br><strong>引用类型</strong> 保存为对象，其本质是指向内存位置的引用。</p>
<p>为了让开发者能够把原始类型和引用类型按相同的方式处理，JavaScript花费了很大的努力来保证语言的一致性。</p>
<p>其他编程语言用栈存原始类型，用对存储引用类型。而JavaScript则完全不同：它使用一个变量对象追踪变量的生存期。原始值被直接保存在变量对象内，而引用值则作为一个指针保存在变量对象内，该指针指向实际对象在内存中的存储位置。<br><a id="more"></a></p>
<p>###1.2 原始类型<br>原始类型代表照原样保存的一些简单数据。<br>JavaScript共有 <strong>5</strong> 种原始类型：</p>
<ul>
<li>boolean    布尔，值为 <code>true</code> or <code>false</code></li>
<li>number     数字，值为任何整型或浮点数值</li>
<li>string     字符串，值为由单引号或双引号括住的单个字符或连续字符</li>
<li>null       空类型，仅有一个值：null</li>
<li>undefined  未定义，只有一个值：undefined（undefined会被赋给一个还没有初始化的变量）</li>
</ul>
<p>JavaScript和许多其他语言一样，原始类型的变量直接保存原始值（而不是一个指向对象的指针）。</p>
<pre><code>var color1 = &quot;red&quot;;
var color2 = color1;

console.log(color1); // &quot;red&quot;
console.log(color2); // &quot;red&quot;

color1 = &quot;blue&quot;;

console.log(color1); // &quot;blue&quot;
console.log(color2); // &quot;red&quot;
</code></pre><p>####鉴别原始类型<br>鉴别原始类型的最佳方式是使用 <code>typeof</code> 操作符。</p>
<pre><code>console.log(typeof &quot;Nicholas&quot;); // &quot;string&quot;
console.log(typeof 10);         // &quot;number&quot;
console.log(typeof true);       // &quot;boolean&quot;
console.log(typeof undefined);  // &quot;undefined&quot;
</code></pre><p>至于空类型（null）则有些棘手。</p>
<pre><code>console.log(typeof null); // &quot;object&quot;
</code></pre><p>对于 typeof null，结果是”object”。（其实这已被设计和维护JavaScript的委员会TC39认定是一个错误。在逻辑上，你可以认为 <code>null</code> 是一个空的对象指针，所以结果为”object”，但这还是很令人困惑。）</p>
<p>判断一个值是否为空类型（null）的最佳方式是直接和 <code>null</code> 比较：</p>
<pre><code>console.log(value === null); // true or false
</code></pre><blockquote>
<p><strong>注意：以上这段代码使用了三等号（全等===）</strong>，因为三等号（全等）不会将变量强制转换为另一种类型。</p>
</blockquote>
<pre><code>console.log(&quot;5&quot; == 5); // true
console.log(&quot;5&quot; === 5); // false

console.log(undefined == null); // true
console.log(undefined === null); // false
</code></pre><p>####原始方法<br>虽然字符串、数字和布尔值是原始类型，但是它们也拥有方法（null和undefined没有方法）。</p>
<pre><code>var name = &quot;Nicholas&quot;;
var lowercaseName = name.toLowerCase(); // 转为小写

var count = 10;
var fixedCount = count.toFixed(2); // 转为10.00

var flag = true;
var stringFlag = flag.toString(); // 转为&quot;true&quot;

console.log(&quot;YIBU&quot;.charAt(0)); // 输出&quot;Y&quot;
</code></pre><blockquote>
<p>尽管原始类型拥有方法，但它们不是对象。JavaScript使它们看上去像对象一样，以此来提高语言上的一致性体验。</p>
</blockquote>
<p>###1.3 引用类型<br>引用类型是指JavaScript中的对象，同时也是你在该语言中能找到最接近类的东西。<br>引用值是引用类型的实例，也是对象的同义词（后面将用对象指代引用值）。对象是属性的无序列表。属性包含键（始终是字符串）和值。如果一个属性的值是函数，它就被称为方法。除了函数可以运行以外，一个包含数组的属性和一个包含函数的属性没有什么区别。</p>
<p>####创建对象<br>有时候，把JavaScript对象想象成哈希表可以帮助你更好地理解对象结构。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/Object_hash.jpg" alt="Object"></p>
<p>JavaScript 有好几种方法可以创建对象，或者说实例化对象。第一种是使用 <code>new</code> 操作符和构造函数。<br>构造函数就是通过 <code>new</code> 操作符来创建对象的函数——任何函数都可以是构造函数。根据命名规范，JavaScript中的构造函数用<strong>首字母大写</strong>来跟非构造函数进行区分。</p>
<pre><code>var object = new Object();
</code></pre><p>因为引用类型不再变量中直接保存对象，所以本例中的 <code>object</code> 变量实际上并<strong>不包含对象的实例，而是一个指向内存中实际对象所在位置的指针（或者说引用）</strong>。这是对象和原始值之间的一个基本差别，原始值是直接保存在变量中。</p>
<p>当你将一个对象赋值给变量时，实际是赋值给这个变量一个指针。这意味着，将一个变量赋值给另外一个变量时，两个变量各获得了一份指针的拷贝，指向内存中的同一个对象。</p>
<pre><code>var obj1 = new Object();
var obj2 = obj1;
</code></pre><p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/copy_obj.jpg" alt="copy_obj"></p>
<p>####对象引用解除<br>JavaScript语言有垃圾收集的功能，因此当你使用引用类型时无需担心内存分配。<strong>但最好在不使用对象时将其引用解除，让垃圾收集器对那块内存进行释放。解除引用的最佳手段是将对象变量设置为 <code>null</code>。</strong></p>
<pre><code>var obj1 = new Object();
// dosomething
obj1 = null; // dereference
</code></pre><p>####添加删除属性<br>在JavaScript中，你可以随时添加和删除其属性。</p>
<pre><code>var obj1 = new Object();
var obj2 = obj1;

obj1.myCustomProperty = &quot;Awsome!&quot;;
console.log(obj2.myCustomProperty); // &quot;Awsome!&quot; 因为obj1和obj2指向同一个对象。
</code></pre><p>###1.4 内建类型实例化<br>内建类型如下：</p>
<ul>
<li>Array       数组类型，以数字为索引的一组值的有序列表</li>
<li>Date        日期和时间类型</li>
<li>Error       运行期错误类型</li>
<li>Function    函数类型</li>
<li>Object      通用对象类型</li>
<li>RegExp      正则表达式类型    </li>
</ul>
<p>可使用 <code>new</code> 来实例化每一个内建引用类型：</p>
<pre><code>var items = new Array();
var new = new Date();
var error = new Error(&quot;Something bad happened.&quot;);
var func = new Function(&quot;console.log(&apos;HI&apos;);&quot;);
var object = new Object();
var re = new RegExp();
</code></pre><p>####字面形式<br>内建引用类型有字面形式。字面形式允许你在不需要使用 <code>new</code> 操作符和构造函数显示创建对象的情况下生成引用值。属性的<strong>键</strong>可以是标识符或字符串（若含有空格或其他特殊字符）</p>
<pre><code>var book = {
    name: &quot;Book_name&quot;,
    year: 2016
}
</code></pre><p>上面代码与下面这段代码等价：</p>
<pre><code>var book = new Object();
book.name = &quot;Book_name&quot;;
book.year = 2016;
</code></pre><blockquote>
<p>虽然使用字面形式并没有调用 new Object()，但是JavaScript引擎背后做的工作和 new Object()一样，除了没有调用构造函数。其他引用类型的字面形式也是如此。</p>
</blockquote>
<p>###1.5 访问属性<br>可通过 <code>.</code> 和 <code>中括号</code> 访问对象的属性。<br>中括号<code>[]</code>在需要动态决定访问哪个属性时，特别有用。因为你可以用<strong>变量</strong>而不是字符串字面形式来指定访问的属性。</p>
<p>###1.6 鉴别引用类型<br>函数是最容易鉴别的引用类型，因为对函数使用 <code>typeof</code> 操作符时，返回”function”。</p>
<pre><code>function reflect(value){
    return value;
}
console.log(typeof reflect); // &quot;function&quot;
</code></pre><p>对其他引用类型的鉴别则较为棘手，因为对于所有非函数的引用类型，<code>typeof</code> 返回 <code>object</code>。为了更方便地鉴别引用类型，可以使用 JavaScript 的 <code>instanceof</code> 操作符。</p>
<pre><code>var items = [];
var obj = {};
function reflect(value){
    return value;
}

console.log(items instanceof Array); // true;
console.log(obj instanceof Object); // true;
console.log(reflect instanceof Function); // true;
</code></pre><p><code>instanceof</code> 操作符可鉴别继承类型。这意味着所有对象都是 <code>Oject</code> 的实例，因为所有引用类型都继承自 <code>Object</code>。</p>
<blockquote>
<p>虽然 instanceof 可以鉴别对象类型（如数组），但是有一个列外。JavaScript 的值可以在同一个网页的不用框架之间传来传去。由于每个网页拥有它自己的全局上下文——Object、Array以及其他内建类型的版本。所以当你把一个对象（如数组）从一个框架传到另外一个框架时，instanceof就无法识别它。</p>
</blockquote>
<p>###1.8 原始封装类型<br>原始封装类型有 <code>3</code> 种：String、Number 和 Boolean。<br>当读取字符串、数字或布尔值时，原始封装类型将被自动创建。</p>
<pre><code>var name = &quot;Nicholas&quot;;
var firstChar = name.charAt(0); // &quot;N&quot;
</code></pre><p>这在背后发生的事情如下：</p>
<pre><code>var name = &quot;Nichola&quot;;
var temp = new String(name);
var firstChar = temp.charAt(0);
temp = null;
</code></pre><p>由于第二行把字符串当成对象使用，JavaScript引擎创建了一个字符串的实体让 <code>charAt(0)</code> 可以工作。字符串对象的存在仅用于该语句并在随后销毁（一种被称为自动打包的过程）。为了测试这一点，试着给字符串添加一个属性看看它是不是对象。</p>
<pre><code>var name = &quot;Nicholas&quot;;
name.last = &quot;Zakas&quot;;

console.log(name.last); // undefined;
</code></pre><p>下面是在JavaScript引擎中实际发生的事情：</p>
<pre><code>var name = &quot;Nicholas&quot;;
var temp = new String(name);
temp.last = &quot;Zakas&quot;;
temp = null; // temporary object destroyed

var temp = new String(name);
console.log(temp.last);
temp = null;
</code></pre><p>新属性 <code>last</code> 实际上是在一个立刻就被销毁的临时对象上而不是字符串上添加。之后当你试图访问该属性时，另一个不同的临时对象被创建，而新属性并不存在。</p>
<p>虽然原始封装类型会被自动创建，在这些值上进行 <code>instanceof</code> 检查对应类型的返回值却是 <code>false</code>。<br>这是因为<strong>临时对象仅在值被读取时创建</strong>。<code>instanceof</code> 操作符并没有真的读取任何东西，也就没有临时对象的创建。</p>
<p>当然你也可以手动创建原始封装类型。</p>
<pre><code>var str = new String(&quot;me&quot;);
str.age = 18;

console.log(typeof str); // object
console.log(str.age); // 18
</code></pre><p>如你所见，手动创建原始封装类型实际会创建出一个 <code>object</code>。这意味着 <code>typeof</code> 无法鉴别出你实际保存的数据的类型。</p>
<p>另外，手动创建原始封装类型和使用原始值是有一定区别的。所以尽量避免使用。</p>
<pre><code>var found = new Boolean(false);
if(found){
    console.log(&quot;Found&quot;); // 执行到了，尽管对象的值为 false
}
</code></pre><p>这是因为一个对象(如 <code>{}</code> )在条件判断语句中总被认为是 <code>true</code>;</p>
<blockquote>
<p>MDN:Any object whose value is not undefined or null, including a Boolean oject whose value is false, evaluates to true when passed to a conditional statement.</p>
</blockquote>
<p>###1.9 总结<br>第一章的东西都是我们一些比较熟悉的知识。但是也有一些需要注意的地方：</p>
<ul>
<li>正确区分原始类型和引用类型</li>
<li>对于 <code>5</code> 种原始类型都可以用typeof来鉴别，而空类型必须直接跟 <code>null</code> 进行全等比较。</li>
<li>函数也是对象，可用 <code>typeof</code> 鉴别。其它引用类型，可用 <code>instanceof</code> 和一个构造函数来鉴别。（当然可以用  <code>Object.prototype.toString.call()</code> 鉴别，它会返回[object Array]之类的）。</li>
<li>为了让原始类型看上去更像引用类型，JavaScript提供了 <code>3</code> 种封装类型。JavaScript会在背后创建这些对象使得你能够像使用普通对象那样使用原始值。但这些临时对象在使用它们的语句结束时就立刻被销毁。虽然可手动创建，但不建议。</li>
</ul>
<p>##2. 函数<br>函数也是对象，使对象不同于其它对象的决定性特点是函数存在一个被称为 <code>[[Call]]</code> 的内部属性。<br><strong>内部属性无法通过代码访问而是定义了代码执行时的行为</strong>。ECMAScript为JavaScript的对象定义了多种内部属性，这些<strong>内部属性都用双重中括号来标注</strong>。</p>
<p><strong>[[Call]]属性是函数独有的，表明该对象可以被执行。由于仅函数拥有该属性，ECMAScript 定义typeof操作符对任何具有[[Call]]属性的对象返回”function”</strong>。过去因某些浏览器曾在正则表达式中包含 <code>[[Call]]</code> 属性，导致正则表达式被错误鉴别为函数。</p>
<p>###2.1 声明还是表达式<br>两者的一个重要区别是：函数声明会被提升至上下文（要么是该函数被声明时所在的函数范围，要么是全局范围）的顶部。</p>
<p>###2.2 函数就是值<br>可以像使用对象一样使用函数（因为函数本来就是对象，Function构造函数更加容易说明）。</p>
<p>###2.3 参数<br>函数参数保存在类数组对象 <code>argument</code> （<code>Array.isArray(arguments)</code> 返回 <code>false</code>）中。可以接收任意数量的参数。<br>函数的 <code>length</code> 属性表明其期望的参数个数。</p>
<p>###2.4 重载<br>大多数面向对象语言支持函数重载，它能让一个函数具有多个签名。函数签名由函数的名字、参数的个数及其类型组成。<br>而JavaScript可以接收任意数量的参数且参数类型完全没有限制。这说明JavaScript函数根本就没有签名，因此也不存在重载。</p>
<pre><code>function sayMessage(message){
    console.log(message);
}
function sayMessage(){
    console.log(&quot;Default Message&quot;);
}

sayMessage(&quot;Hello!&quot;); // 输出&quot;Default Message&quot;;
</code></pre><p>在Javscript里，当你试图定义多个同名的函数时，只有最后的定义有效，之前的函数声明被完全删除（函数也是对象，变量只是存指针)。</p>
<pre><code>var sayMessage = new Function(&quot;message&quot;, &quot;console.log(message)&quot;);
var sayMessage = new Function(&quot;console.log(\&quot;Default Message\&quot;);&quot;);

sayMessage(&quot;Hello!&quot;); 
</code></pre><p>当然，你可以根据传入参数的数量来模仿重载。</p>
<p>###2.5 对象方法<br>对象的值是函数，则该属性被称为方法。</p>
<p>####2.5.1 this对象<br>JavaScript 所有的函数作用域内都有一个 <code>this</code> 对象代表调用该函数的对象。在全局作用域中，<code>this</code> 代表全局对象（浏览器里的window）。当一个函数作为对象的方法调用时，默认 <code>this</code> 的值等于该对象。<br><strong>this在函数调用时才被设置。</strong></p>
<pre><code>function sayNameForAll(){
    console.log(this.name);
}

var person1 = {
    name: &quot;Nicholas&quot;,
    sayName: sayNameForAll
}

var name = &quot;Jack&quot;;

person1.sayName(); // 输出 &quot;Nicholas&quot;
sayNameforAll(); // 输出 &quot;Jack&quot;
</code></pre><p>####2.5.2 改变this<br>有 <code>3</code> 种函数方法运行你改变 <code>this</code> 值。</p>
<ol>
<li>fun.call(thisArg[, arg1[, arg2[, …]]]);</li>
<li>fun.apply(thisArg, [argsArray]);</li>
<li>fun.bind(thisArg[, arg1[, arg2[, …]]])</li>
</ol>
<p>使用 <code>call</code> 或 <code>apply</code> 方法，就不需要将函数加入每个对象——你显示地指定了 <code>this</code> 的值而不是让JavaScript引擎自动指定。</p>
<p><code>call</code> 与 <code>apply</code> 的不同地方是，<code>call</code> 需要把所有参数一个个列出来，而 <code>apply</code> 的参数需要一个数组或者类似数组的对象（如 <code>arguments</code> 对象）。</p>
<p><code>bind</code> 是ECMAScript 5 新增的，它会创建一个新函数返回。其参数与 <code>call</code> 类似，而且其所有参数代表需要被<strong>永久</strong>设置在新函数中的命名参数（绑定了的参数（没绑定的参数依然可以传入），就算调用时再传入其它参数，也不会影响这些绑定的参数）。</p>
<pre><code>function sayNameForAll(label){
    console.log(label + &quot;:&quot; + this.name);
}
var person = {
    name: &quot;Nicholas&quot;
}

var sayNameForPerson = sayNameForAll.bind(person);
sayNameForPerson(&quot;Person&quot;); // 输出&quot;Person:Nicholas&quot;

var sayName = sayNameForAll.bind(person, &quot;Jc&quot;);

sayName(&quot;change&quot;); // 输出&quot;Jc:Nicholas&quot; 因为绑定的形参，会忽略调用时再传入参数
</code></pre><p>###2.6 总结</p>
<ul>
<li>函数也是对象，所以它可以被访问、复制和覆盖。</li>
<li>函数与其他对象最大的区别在于它们有一个特殊的内部属性 <code>[[Call]]</code>，包含了该函数的执行指令。</li>
<li>函数声明会被提升至上下文的顶部。</li>
<li>函数是对象，所以存在一个 <code>Function</code> 构造函数。但这会使你的代码难以理解和调试，除非函数的真实形式要直到运行时才能确定的时候才会利用它。</li>
</ul>
<p>##理解对象<br>JavaScript中的对象是动态的，可在代码执行的任意时刻发生改变。基于类的语言会根据类的定义锁定对象。</p>
<p>###3.1 定义属性<br>当一个属性第一次被添加到对象时，JavaScript会在对象上调用一个名为 <code>[[Put]]</code> 的内部方法。<code>[[Put]]</code> 方法会在对象上创建一个新节点来保存属性。<br>当一个已有的属性被赋予一个新值时，调用的是一个名为 <code>[[Set]]</code> 的方法。</p>
<p>###3.2 属性探测<br>检查对象是否已有一个属性。JavaScript开发新手错误地使用以下模式检测属性是否存在。</p>
<pre><code>if(person.age){
    // do something with ag
}
</code></pre><p>上面的问题在于JavaScript的类型强制会影响该模式的输出结果。<br>当if判断中的值如下时，会判断为<strong>真</strong>：</p>
<ul>
<li>对象</li>
<li>非空字符串</li>
<li>非零</li>
<li>true</li>
</ul>
<p>当if判断中的值如下时，会判断为<strong>假</strong>：</p>
<ul>
<li>null</li>
<li>undefined</li>
<li>0</li>
<li>false</li>
<li>NaN</li>
<li>空字符串</li>
</ul>
<p>因此判断属性是否存在的方法是使用 <code>in</code> 操作符。<br><code>in</code> 操作符会检查<strong>自有属性和原型属性</strong>。<br>所有的对象都拥有的 <code>hasOwnProperty()</code> 方法（其实是 <code>Object.prototype</code> 原型对象的），该方法在给定的属性存在且为<strong>自有属性</strong>时返回 <code>true</code>。</p>
<pre><code>var person = {
    name: &quot;Nicholas&quot;
}

console.log(&quot;name&quot; in person); // true
console.log(person.hasOwnpropert(&quot;name&quot;)); // true

console.log(&quot;toString&quot; in person); // true
console.log(person.hasOwnproperty(&quot;toString&quot;)); // false
</code></pre><p>###3.3 删除属性<br>设置一个属性的值为 <code>null</code> 并不能从对象中彻底移除那个属性，这只是调用 <code>[[Set]]</code> 将 <code>null</code> 值替换了该属性原来的值而已。<br><code>delete</code> 操作符针对单个对象属性调用名为 <code>[[Delete]]</code> 的内部方法。删除成功时，返回 <code>true</code>。</p>
<pre><code>var person = {
    name: &quot;Nicholas&quot;
}

person.name = null;
console.log(&quot;name&quot; in person); // true
delete person.name;
console.log(person.name); // undefined 访问一个不存在的属性将返回 undefined
console.log(&quot;name&quot; in person); // false
</code></pre><p>###3.4 属性枚举<br>所有人为添加的属性默认都是可枚举的。可枚举的内部特征 <code>[[Enumerable]]</code> 都被设置为 <code>true</code>。<br><code>for-in</code> 循环会枚举一个对象所有的可枚举属性。</p>
<blockquote>
<p>我的备注：在Chrome中，对象属性会按ASCII表排序，而不是定义时的顺序。</p>
</blockquote>
<p>ECMAScript 5 的 Object() 方法可以获取可枚举属性的名字的数组。</p>
<pre><code>var person = {
    name: &quot;Ljc&quot;,
    age: 18
}

Object.keys(person); // [&quot;name&quot;, &quot;age&quot;];
</code></pre><p><code>for-in</code> 与 <code>Object.keys()</code> 的一个区别是：前者也会遍历原型属性，而后者返回自有(实例)属性。</p>
<p>实际上，对象的大部分原生方法的 <code>[[Enumerable]]</code> 特征都被设置为 <code>false</code>。可用 <code>propertyIsEnumerable()</code> 方法检查一个属性是否为可枚举的。</p>
<pre><code>var arr = [&quot;abc&quot;, 2];
console.log(arr.propertyIsEnumerable(&quot;length&quot;)); // false
</code></pre><p>###3.5 属性类型<br>属性有两种类型：<strong>数据属性</strong>和<strong>访问器属性</strong>。<br>数据属性包含一个值。<code>[[Put]]</code> 方法的默认行为是创建<strong>数据属性</strong>。<br>访问器属性不包含值而是定义了一个当属性被读取时调用的函数（称为<code>getter</code>）和一个当属性被写入时调用的函数（称为<code>setter</code>）。访问器属性仅需要 <code>getter</code> 或 <code>setter</code> 两者中的任意一个，当然也可以两者。</p>
<pre><code>// 对象字面形式中定义访问器属性有特殊的语法：
var person = {
    _name: &quot;Nicholas&quot;,

    get name(){
        console.log(&quot;Reading name&quot;);
        return this._name;
    },
    set name(value){
        console.log(&quot;Setting name to %s&quot;, value);
        this._name = value;
    }
};

console.log(person.name); // &quot;Reading name&quot; 然后输出 &quot;Nicholas&quot;

person.name = &quot;Greg&quot;;
console.log(person.name); // &quot;Setting name to Greg&quot; 然后输出 &quot;Greg&quot;
</code></pre><blockquote>
<p>前置下划线_ 是一个约定俗成的命名规范，表示该属性是私有的，实际上它还是公开的。</p>
</blockquote>
<p>访问器就是定义了我们在对象读取或设置属性时，触发的动作（函数），<code>_name</code> 相当于一个内部变量。<br>当你希望赋值（读取）操作会触发一些行为，访问器就会非常有用。</p>
<blockquote>
<p>当只定义getter或setter其一时，该属性就会变成只读或只写。</p>
</blockquote>
<p>###3.6 属性特征<br>在ECMAScript 5 之前没有办法指定一个属性是否可枚举。实际上根本没有方法访问属性的任何内部特征。为了改变这点，ECMAScript 5引入了多种方法来和属性特征值直接互动。</p>
<p>####3.6.1 通用特征<br>数据属性和访问器属性均由以下两个属性特制：<br><code>[[Enumerable]]</code> 决定了是否可以遍历该属性；<br><code>[[Configurable]]</code> 决定了该属性是否可配置。</p>
<p>所有人为定义的属性默认都是可枚举、可配置的。</p>
<p>可以用 <code>Object.defineProperty()</code> 方法改变属性特征。<br>其参数有三：拥有该属性的对象、属性名和包含需要设置的特性的属性描述对象。</p>
<pre><code>var person = {
    name: &quot;Nicholas&quot;
}
Object.defineProperty(person, &quot;name&quot;, {
    enumerable: false
})

console.log(&quot;name&quot; in person); // true
console.log(person.propertyIsEnumerable(&quot;name&quot;)); // false

var properties = Object.keys(person);
console.log(properties.length); // 0

Object.defineProperty(person, &quot;name&quot;,{
    configurable: false
})

delete person.name; // false
console.log(&quot;name&quot; in person); // true

Object.defineProperty(person, &quot;name&quot;,{ // error! 
// 在 chrome：Uncaught TypeError: Cannot redefine property: name
    configurable: true
})
</code></pre><blockquote>
<p>无法将一个不可配置的属性变为可配置，相反则可以。</p>
</blockquote>
<p>####3.6.2 数据属性特征<br>数据属性额外拥有两个访问器属性不具备的特征。<br><code>[[Value]]</code> 包含属性的值(哪怕是函数)。<br><code>[[Writable]]</code> 布尔值，指示该属性是否可写入。所有属性默认都是可写的。</p>
<pre><code>var person = {};

Object.defineProperty(person, &quot;name&quot;, {
    value: &quot;Nicholas&quot;,
    enumerable: true,
    configurable: true,
    writable: true
})
</code></pre><p>在 <code>Object.defineProperty()</code> 被调用时，如果属性本来就有，则会按照新定义属性特征值去覆盖默认属性特征（<code>enumberable</code>、<code>configurable</code> 和 <code>writable</code> 均为 <code>true</code>）。但如果用该方法定义新的属性时，没有为所有的特征值指定一个值，则所有布尔值的特征值会被默认设置为 <code>false</code>。即不可枚举、不可配置、不可写的。<br>当你用 <code>Object.defineProperty()</code> 改变一个已有的属性时，只有你指定的特征会被改变。</p>
<p>####3.6.3 访问器属性特征<br>访问器属性额外拥有两个特征。<code>[[Get]]</code> 和 <code>[[Set]]</code>，内含 <code>getter</code> 和 <code>setter</code> 函数。<br>使用访问其属性特征比使用对象字面形式定义访问器属性的优势在于：可以为已有的对象定义这些属性。而后者只能在创建时定义访问器属性。</p>
<pre><code>var person = {
    _name: &quot;Nicholas&quot;
};

Object.defineProperty(person, &quot;name&quot;, {
    get: function(){
        return this._name;
    },
    set: function(value){
        this._name = value;
    },
    enumerable: true,
    configurable: true
})

for(var x in person){
    console.log(x); // _name \n(换行) name（访问器属性）
}
</code></pre><p>设置一个不可配置、不可枚举、不可以写的属性：</p>
<pre><code>Object.defineProperty(person, &quot;name&quot;,{
    get: function(){
        return this._name;
    }
})
</code></pre><p>对于一个新的访问器属性，没有显示设置值为布尔值的属性，默认为 <code>false</code>。</p>
<p>####3.6.4 定义多重属性<br><code>Object.defineProperties()</code> 方法可以定义任意数量的属性，甚至可以同时改变已有的属性并创建新属性。</p>
<pre><code>var person = {};

Object.defineProperties(person, {

    // data property to store data
    _name: {
        value: &quot;Nicholas&quot;,
        enumerable: true,
        configurable: true,
        writable: true
    },

    // accessor property
    name: {
        get: function(){
            return this._name;
        },
        set: function(value){
            this._name = value;
        }
    }
})
</code></pre><p>####3.6.5 获取属性特征<br><code>Object.getOwnPropertyDescriptor()</code> 方法。该方法接受两个参数：对象和属性名。如果属性存在，它会返回一个属性描述对象，内涵<code>4</code>个属性：<code>configurable</code> 和 <code>enumerable</code>，另外两个属性则根据属性类型决定。</p>
<pre><code>var person = {
    name: &quot;Nicholas&quot;
}

var descriptor = Object.getOwnPropertyDescriptor(person, &quot;name&quot;);

console.log(descriptor.enumerable); // true
console.log(descriptor.configuable); // true
console.log(descriptor.value); // &quot;Nicholas&quot;
console.log(descriptor.wirtable); // true
</code></pre><p>###3.7 禁止修改对象<br>对象和属性一样具有指导其行为的内部特性。其中， <code>[[Extensible]]</code> 是布尔值，指明该对象本身是否可以被修改。默认是 <code>true</code>。当值为 <code>false</code> 时，就能禁止新属性的添加。</p>
<blockquote>
<p>建议在 “use strict”; 严格模式下进行。</p>
</blockquote>
<p>####3.7.1 禁止扩展<br><code>Object.preventExtensions()</code> 创建一个不可扩展的对象（即<strong>不能添加新属性</strong>）。<br><code>Object.isExtensible()</code> 检查 <code>[[Extensible]]</code> 的值。</p>
<pre><code>var person = {
    name: &quot;Nocholas&quot;
}

Object.preventExtensions(person);

person.sayName = function(){
    console.log(this.name)
}

console.log(&quot;sayName&quot; in person); // false
</code></pre><p>####3.7.2 对象封印<br>一个被封印的对象是不可扩展的且其所有属性都是不可配置的（即不能添加、删除属性或修改其属性类型（从数据属性变成访问器属性或相反））。<strong>只能读写它的属性</strong>。<br>Object.seal()。调用此方法后，该对象的 <code>[[Extensible]]</code> 特征被设置为 <code>false</code>，其所有属性的 <code>[[configurable]]</code> 特征被设置为 <code>false</code>。<br><code>Object.isSealed()</code> 判断一个对象是否被封印。</p>
<p>####3.7.3 对象冻结<br>被冻结的对象不能添加或删除属性，不能修改属性类型，也不能写入任何数据属性。简言而之，被冻结对象是一个<strong>数据属性都为只读</strong>的被封印对象。<br><code>Object.freeze()</code> 冻结对象。<br><code>Object.isFrozen()</code> 判断对象是否被冻结。</p>
<p>###3.8 总结</p>
<ul>
<li><code>in</code> 操作符检测自有属性和原型属性，而 <code>hasOwnProperty()</code> 只检查自有属性。</li>
<li>用 <code>delete</code> 操作符删除对象属性。</li>
<li>属性有两种类型：数据属性和访问器属性。</li>
<li>所有属性都有一些相关特征。<code>[[Enumerable]]</code> 和 <code>[[Configurable]]</code> 的两种属性都有的，而数据属性还有 <code>[[Value]]</code> 和 <code>[[Writable]]</code>，访问器属性还有 <code>[[Get]]</code> 和 <code>[[Set]]</code>。可通过 <code>Object.defineProperty()</code> 和 <code>Object.defineProperties()</code> 改变这些特征。用 <code>Object.getOwnPropertyDescriptor()</code> 获取它们。</li>
<li>有 <code>3</code> 种可以锁定对象属性的方式。</li>
</ul>
<p>##4. 构造函数和原型对象<br>由于JavaScript(ES5)缺乏类，但可用构造函数和原型对象给对象带来与类相似的功能。</p>
<p>###4.1 构造函数<br>构造函数的函数名首字母应大写，以此区分其他函数。<br>当没有需要给构造函数传递参数，可忽略小括号：</p>
<pre><code>var Person = {
    // 故意留空
}
var person = new Person;
</code></pre><p>尽管 Person 构造函数没有显式返回任何东西，但 new 操作符会自动创建给定类型的对象并返回它们。</p>
<p>每个对象在创建时都自动拥有一个构造函数属性（constructor，其实是它们的原型对象上的属性），其中包含了一个指向其构造函数的引用。<br>通过对象字面量形式（{}）或Object构造函数创建出来的泛用对象，其构造函数属性（constructor）指向 Object；而那些通过自定义构造函数创建出来的对象，其构造函数属性指向创建它的构造函数。</p>
<pre><code>console.log(person.constructor === Person); // true
console.log(({}).constructor === Object); // true
console.log(([1,2,3]).constructor === Object); // true

// 证明 constructor是在原型对象上
console.log(person.hasOwnPrototype(&quot;constructor&quot;)); // false
console.log(person.constructor.prototype.hasOwnPrototype(&quot;constructor&quot;)); // true
</code></pre><p>尽管对象实例及其构造函数之间存在这样的关系，但还是建议使用 <code>instanceof</code> 来检查对象类型。这是因为构造函数属性可以被覆盖。（person.constructor = “”）。</p>
<p>当你调用构造函数时，new 会自动创建 this 对象，且其类型就是构造函数的类型（构造函数就好像类，相当于一种数据类型）。</p>
<blockquote>
<p>你也可以在构造函数中显式调用 return。如果返回值是一个对象，它会代替新创建的对象实例而返回，如果返回值是一个原始类型，它会被忽略，新创建的对象实例会被返回。</p>
</blockquote>
<p>始终确保要用 new 调用构造函数；否则，你就是在冒着改变全局对象的风险，而不是创建一个新的对象。</p>
<pre><code>var person = Person(&quot;Nicholas&quot;); // 缺少 new

console.log(person instanceof Person); // false
console.log(person); // undefined，因为没用 new，就相当于一个普通函数，默认返回 undefined
console.log(name); // &quot;Nicholas&quot;
</code></pre><p>当Person不是被 new 调用时，构造函数中的 this 对象等于全局 this 对象。</p>
<blockquote>
<p>在严格模式下，会报错。因为严格模式下，并没有为全局对象设置 this，this 保持为 undefined。</p>
</blockquote>
<p>以下代码，通过 new 实例化 100 个对象，则会有 100 个函数做相同的事。因此可用 <code>prototype</code> 共享同一个方法会更高效。</p>
<pre><code>var person = {
    name: &quot;Nicholas&quot;,
    sayName: function(){
        console.log(this.name);
    }
}
</code></pre><p>###4.2 原型对象<br>可以把原型对象看作是对象的基类。几乎所有的函数（除了一些内建函数）都有一个名为 prototype 的属性，该属性是一个原型对象用来创建新的对象实例。所有创建的对象实例（同一构造函数，当然，可能访问上层的原型对象）<strong>共享</strong>该原型对象，且这些对象实例可以访问原型对象的属性。例如，hasOwnProperty()定义在 Object 的原型对象中，但却可被任何对象当作自己的属性访问。</p>
<pre><code>var book = {
    title : &quot;book_name&quot;
}

&quot;hasOwnProperty&quot; in book; // true
book.hasOwnProperty(&quot;hasOwnProperty&quot;); // false
Object.property.hasOwnProperty(&quot;hasOwnProperty&quot;); // true
</code></pre><p><strong>鉴别一个原型属性</strong></p>
<pre><code>function hasPrototypeProperty(object, name){
    return name in object &amp;&amp; !object.hasOwnProperty(name);
}
</code></pre><p>####4.2.1 [[Prototype]] 属性<br>一个对象实例通过内部属性 [[Prototype]] 跟踪其原型对象。该属性是一个指向该实例使用的原型对象的指针。当你用 new 创建一个新的对象时，构造函数的原型对象就会被赋给该对象的 [[Prototype]] 属性。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/prototype.jpg" alt="prototype"></p>
<p>由上图可以看出，[[Prototype]] 属性是如何让多个对象实例引用同一个原型对象来减少重复代码。</p>
<p>Object.getPrototypeOf() 方法可读取 [[Prototype]] 属性的值。</p>
<pre><code>var obj = {};
var prototype = Object.getPrototypeOf(Object);

console.log(prototype === Object.prototype); // true
</code></pre><blockquote>
<p>大部分JavaScript引擎在所有对象上都支持一个名为 <code>__proto__</code> 的属性。该属性使你可以直接读写 [[Prototype]] 属性。</p>
</blockquote>
<p>isPrototypeOf() 方法会检查某个对象是否是另一个对象的原型对象，该方法包含在所有对象中。</p>
<pre><code>var obj = {}
console.log(Object.prototype.isPrototypeOf(obj)); // true
</code></pre><p>当读取一个对象的属性时，JavaScript 引擎首先在该对象的自有属性查找属性名。如果找到则返回。否则会搜索 [[Prototype]] 中的对象，找到则返回，找不到则返回 undefined。</p>
<pre><code>var obj = new Object();
console.log(obj.toString()); // &quot;[object Object]&quot;

obj.toString = function(){
    return &quot;[object Custom]&quot;;
}
console.log(obj.toString()); // &quot;[object Custom]&quot;

delete obj.toString; // true
console.log(obj.toString()); // &quot;[object Object]&quot;

delete obj.toString; // 无效，delete不能删除一个对象从原型继承而来的属性
cconsole.log(obj.toString()); // // &quot;[object Object]&quot;
</code></pre><blockquote>
<p>MDN：delete 操作符不能删除的属性有：①显式声明的全局变量不能被删除,该属性不可配置（not configurable）； ②内置对象的内置属性不能被删除； ③不能删除一个对象从原型继承而来的属性(不过你可以从原型上直接删掉它)。</p>
</blockquote>
<p>一个重要概念：无法给一个对象的原型属性赋值。但我们可以通过 <code>obj.constructor.prototype.sayHi = function(){console.log(&quot;Hi!&quot;)}</code> 向原型对象添加属性。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/%E6%97%A0%E6%A0%87%E9%A2%98.jpg" alt="此处输入图片的描述"><br>（图片中间可以看出，为对象obj添加的toString属性代替了原型属性）</p>
<p>####4.2.2 在构造函数中使用原型对象</p>
<p>构造函数模式的缺点：无法共享方法<br>原型模式的缺点：当原型对象的属性为引用类型时，对其进行修改会反映到所有实例中。  </p>
<p>因此我们将两者结合，<strong>对象的属性使用构造函数模式创建，方法则使用原型模式创建</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    Person.prototype=&#123;</div><div class="line">        <span class="attr">constructor</span>:Person,</div><div class="line">        <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            alert(<span class="keyword">this</span>.name);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'mncu'</span>,<span class="number">120</span>);</div><div class="line">    p1.name;  <span class="comment">// 'mncu'</span></div></pre></td></tr></table></figure>
<p>#####在原型对象上定义公用方法</p>
<p>#####在原型对象上定义数据类型<br>开发中需要注意原型对象的数据是否共享。</p>
<pre><code>function Person(name){
    this.name = name
}

Person.prototype.sayName = function(){
    console.log(this.name);
}

Person.prototype.position = &quot;school&quot;;
Person.prototype.arr = [];

var person1 = new Person(&quot;xiaoming&quot;);
var person2 = new Person(&quot;Jc&quot;);

console.log(&quot;原始类型&quot;)
console.log(person1.position); // &quot;school&quot;
console.log(person2.position); // &quot;school&quot;

person1.position = 2; // 这是在当前属性设置position，引用类型同理
console.log(person1.hasOwnProperty(&quot;position&quot;)); // true
console.log(person2.hasOwnProperty(&quot;position&quot;)); // false

console.log(&quot;引用类型&quot;);
person1.arr.push(&quot;pizza&quot;); // 这是在原型对象上设置，而不是直接在对象上
person2.arr.push(&quot;quinoa&quot;); // 这是在原型对象上设置
console.log(person1.hasOwnProperty(&quot;arr&quot;)); // false
console.log(person2.hasOwnProperty(&quot;arr&quot;)); // false
console.log(person1.arr); // [&quot;pizza&quot;, &quot;quinoa&quot;]
console.log(person2.arr); // [&quot;pizza&quot;, &quot;quinoa&quot;]
</code></pre><p>上面是在原型对象上一一添加属性，下面一种更简洁的方式：以一个对象字面形式替换原型对象</p>
<pre><code>function Person(name){
    this.name
}

Person.prototype = {
    sayName: function(){
        console.log(this.name);
    },
    toString: function(){
        return &quot;[Person ]&quot; + this.name + &quot;]&quot;;
    }
}
</code></pre><p>这种方式有一种副作用：因为原型对象上具有一个 <code>constructor</code> 属性，这是其他对象实例所没有的。当一个函数被创建时，它的  <code>prototype</code> 属性也会被创建，且该原型对象的 <code>constructor</code> 属性指向该函数。当使用字面量时，因没显式设置原型对象的 <code>constructor</code> 属性，因此其 <code>constructor</code> 属性是指向 <code>Object</code> 的。<br>因此，当通过此方式设置原型对象时，可手动设置 <code>constructor</code> 属性。</p>
<pre><code>function Person(name){
    this.name
}

// 建议第一个属性就是设置其 constructor 属性。
Person.prototype = {
    constructor: Person,

    sayName: function(){
        console.log(this.name);
    },
    toString: function(){
        return &quot;[Person ]&quot; + this.name + &quot;]&quot;;
    }
}
</code></pre><p>构造函数、原型对象和对象实例之间的关系最有趣的一方面也许是：<br>对象实例和构造函数直接没有直接联系。（对象实例只有 <code>[[Prototype]]</code> 属性指向其相应的原型对象，而原型对象的 <code>constructor</code> 属性指向构造函数，而构造函数的 <code>prototype</code> 指向原型对象）<br><img src="http://7xq7nb.com1.z0.glb.clouddn.com/obj_constructor_prototype.jpg" alt="obj_constructor_prototype"></p>
<p>####4.2.3 改变原型对象<br>因为每个对象的 <code>[[Prototype]]</code> 只是一个指向原型对象的指针，所以原型对象的改动会立刻反映到所有引用它的对象。<br>当对一个对象使用封印 <code>Object.seal()</code> 或冻结 <code>Object.freeze()</code> 时，完全是在操作对象的自有属性，但任然可以通过在原型对象上添加属性来扩展这些对象实例。</p>
<p>####4.2.4 内建对象（如Array、String）的原型对象</p>
<pre><code>String.prototype.capitalize = function(){
    return this.charAt(0).toUpperCase() + this.substring(1);
}
</code></pre><p>###总结</p>
<ul>
<li>构造函数就是用 <code>new</code> 操作符调用的普通函数。可用过 <code>instanceof</code> 操作符或直接访问 <code>constructor</code>(实际上是原型对象的属性) 来鉴别对象是被哪个构造函数所创建的。</li>
<li>每个函数都有一个 <code>prototype</code> 对象，它定义了该构造函数创建的所有对象共享的属性。而 <code>constructor</code> 属性实际上是定义在原型对象里，供所有对象实例共享。</li>
<li>每个对象实例都有 <code>[[Prototype]]</code> 属性，它是指向原型对象的指针。当访问对象的某个属性时，先从对象自身查找，找不到的话就到原型对象上找。</li>
<li>内建对象的原型对象也可被修改</li>
</ul>
<p>##5. 继承</p>
<p>###5.1 原型对象链和 Object.prototype<br>JavaScript内建的继承方法被称为 原型对象链（又叫原型对象继承）。<br>原型对象的属性可经由对象实例访问，这就是继承的一种形式。对象实例继承了原型对象的属性，而原型对象也是一个对象，它也有自己的原型对象并继承其属性，以此类推。这就是原型对象链。</p>
<p>所有对象（包括自义定的）都自动继承自 <code>Object</code>，除非你另有指定。更确切地说，所有对象都继承自 <code>Object.prototype</code>。任何以对象字面量形式定义的对象，其 <code>[[Prototype]]</code> 的值都被设为 <code>Object.prototype</code>，这意味着它继承 <code>Object.prototype</code> 的属性。</p>
<p>####5.1.1 继承自 Object.prototype 的方法<br>Object.prototype 一般有以下几个方法</p>
<ul>
<li>hasOwnProperty()             检测是否存在一个给定名字的自有属性</li>
<li>propertyIsemumerable()       检查一个自有属性是否可枚举</li>
<li>isPrototypeOf                检查一个对象是否是另一个对象的原型对象</li>
<li>valueOf()                    返回一个对象的值表达</li>
<li>toString()                   返回一个对象的字符串表达</li>
</ul>
<p>这 5 种方法经由继承出现在所有对象中。<br>因为所有对象都默认继承自 <code>Object.prototype</code>，所以改变它就会影响所有的对象。所以不建议。</p>
<p>###5.2 继承<br>对象继承是最简单的继承类型。你唯需要做的是指定哪个对象是新对象的 <code>[[Prototype]]</code>。对象字面量形式会隐式指定 <code>Object.prototype</code> 为其 <code>[[Protoype]]</code>。当然我们可以用 ES5 的 <code>Object.create()</code> 方法显式指定。该方法接受两个参数，第一个是新对象的的 <code>[[Prototype]]</code> 所指向的对象。第二个参数是可选的一个属性描述对象，其格式与 <code>Object.definePrototies()</code>一样。</p>
<pre><code>var obj = {
    name: &quot;Ljc&quot;
};

// 等同于
var obj = Object.create(Object.prototype, {
    name: {
        value: &quot;Ljc&quot;,
        configurable: true,
        enumberable: true,
        writable: true
    }
});
</code></pre><p>下面是继承其它对象：</p>
<pre><code>var person = {
    name: &quot;Jack&quot;,
    sayName: function(){
        console.log(this.name);
    }
}

var student = Object.create(person, {
    name:{
        value: &quot;Ljc&quot;
    },
    grade: {
        value: &quot;fourth year of university&quot;,
        enumerable: true,
        configurable: true,
        writable: true
    }
});

person.sayName(); // &quot;Jack&quot;
student.sayName(); // &quot;Ljc&quot;

console.log(person.hasOwnProperty(&quot;sayName&quot;)); // true
console.log(person.isPrototypeOf(student)); // true
console.log(student.hasOwnProperty(&quot;sayName&quot;)); // false
console.log(&quot;sayName&quot; in student); // true
</code></pre><p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF.jpg" alt="对象继承"></p>
<p>当访问一个对象属性时，JavaScript引擎会执行一个搜索过程。如果在对象实例存在该自有属性，则返回，否则，根据其私有属性 <code>[[Protoype]]</code> 所指向的原型对象进行搜索，找到返回，否则继承上述操作，知道继承链末端。末端通常是 <code>Object.prototype</code>，其 <code>[[Prototype]]</code> 是 <code>null</code>。</p>
<p>当然，也可以用 <code>Object.create()</code> 常见一个 <code>[[Prototype]]</code> 为 <code>null</code> 的对象。</p>
<pre><code>var obj = Object.create(null);

console.log(&quot;toString&quot; in obj); // false
</code></pre><p>该对象是一个没有原型对象链的对象，即是一个没有预定义属性的白板。</p>
<p>###5.3 构造函数继承<br>JavaScript 中的对象继承也是构造函数继承的基础。<br>第四章提到，几乎所有函数都有 <code>prototype</code> 属性，它可被修改或替换。该 <code>prototype</code> 属性被自动设置为一个新的继承自 <code>Object.prototype</code> 的泛用对象，该对象(原型对象)有一个自有属性 <code>constructor</code>。实际上，JavaScript 引擎为你做了下面的事情。</p>
<pre><code>// 你写成这样
function YourConstructor(){
    // initialization
}

// JavaScript引擎在背后为你做了这些处理
YourConstructor.prototype = Object.create(Object.prototype, {
    constructor: {
        configurable: true,
        enumerable: true,
        value: YourConstructor,
        writable: true
    }
})
</code></pre><p>你不需要做额外的工作，这段代码帮你把构造函数的 <code>prototype</code> 属性设置为一个继承自 <code>Object.prototype</code> 的对象。这意味着 <code>YourConstructor</code> 创建出来的任何对象都继承自 <code>Object.prototype</code>。</p>
<p>由于 prototype 可写，你可以通过改变它来改变原型对象链。</p>
<blockquote>
<p>MDN:instanceof 运算符可以用来判断某个构造函数的 prototype 属性是否存在另外一个要检测对象的原型链上。</p>
</blockquote>
<pre><code>function Rectangle(length, width){
    this.length = length;
    this.width = width
}

Rectangle.prototype.getArea = function(){
    return this.length * this.width
}

Rectangle.prototype.toString = function(){
    return &quot;[Rectangle &quot; + this.length + &quot;x&quot; + this.width + &quot;]&quot;;
}


// inherits from Rectangle
function Square(size){
    this.length = size;
    this.width = size;
}

Square.prototype = new Rectangle(); // 尽管是 Square.prototype 是指向了 Rectangle 的对象实例，即Square的实例对象也能访问该实例的属性（如果你提前声明了该对象，且给该对象新增属性）。
// Square.prototype = Rectangle.prototype; // 这种实现没有上面这种好，因为Square.prototype 指向了 Rectangle.prototype，导致修改Square.prototype时，实际就是修改Rectangle.prototype。
console.log(Square.prototype.constructor); // 输出 Rectangle 构造函数

Square.prototype.constructor = Square; // 重置回 Square 构造函数
console.log(Square.prototype.constructor); // 输出 Square 构造函数

Square.prototype.toString = function(){
    return &quot;[Square &quot; + this.length + &quot;x&quot; + this.width + &quot;]&quot;;
}

var rect = new Rectangle(5, 10);
var square = new Square(6);

console.log(rect.getArea()); // 50
console.log(square.getArea()); // 36

console.log(rect.toString()); // &quot;[Rectangle 5 * 10]&quot;, 但如果是Square.prototype = Rectangle.prototype，则这里会&quot;[Square 5 * 10]&quot;
console.log(square.toString()); // &quot;[Square 6 * 6]&quot;

console.log(square instanceof Square); // true
console.log(square instanceof Rectangle); // true
console.log(square instanceof Object); // true
</code></pre><p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF.jpg" alt="构造函数继承"></p>
<p><code>Square.prototype</code> 并不真的需要被改成为一个 <code>Rectangle</code> 对象。事实上，是 <code>Square.prototype</code> 需要指向 <code>Rectangle.prototype</code> 使得继承得以实现。这意味着可以用 <code>Object.create()</code> 简化例子。</p>
<pre><code>// inherits from Rectangle
function Square(size){
    this.length = size;
    this.width = size;
}

Square.prototype= Object.create(Rectangle.prototype, {
    constructor: {
        configurable: true,
        enumerable: true,
        value: Square,
        writable: true
    }
})
</code></pre><blockquote>
<p>在对原型对象添加属性前要确保你已经改成了原型对象，否则在改写时会丢失之前添加的方法（因为继承是将被继承对象赋值给需要继承的原型对象，相当于重写了需要继承的原型对象）。</p>
</blockquote>
<p>###5.4 构造函数窃取<br>由于JavaScript中的继承是通过原型对象链来实现的，因此不需要调用对象的父类的构造函数。如果确实需要在子类构造函数中调用父类构造函数，那就可以在子类的构造函数中利用 <code>call</code>、<code>apply</code>方法调用父类的构造函数。</p>
<pre><code>// 在上面的代码基础上作出修改
// inherits from Rectangle
function Square(size){
    Rectangle.call(this, size, size);

    // optional: add new properties or override existing ones here
}
</code></pre><p>一般来说，需要修改 <code>prototype</code> 来继承方法并用构造函数窃取来设置属性，由于这种做法模仿了那些基于类的语言的类继承，所以这通常被称为伪类继承。</p>
<p>###5.5 访问父类方法<br>其实也是通过指定 <code>call</code> 或 <code>apply</code> 的子对象调用父类方法。</p>
<p>##6 对象模式</p>
<p>###6.1 私有成员和特权成员<br>JavaScipt 对象的所有属性都是公有的，没有显式的方法指定某个属性不能被外界访问。</p>
<p>####6.1.1 模块模式<br>模块模式是一种用于创建<strong>拥有私有数据的单件对象</strong>的模式。<br>基本做法是使用立即调用函数表达式（IIFE）来返回一个对象。原理是利用闭包。</p>
<pre><code>var yourObj = (function(){
    // private data variables

    return {
        // public methods and properties
    }
}());
</code></pre><p>模块模式还有一个变种叫暴露模块模式，它将所有的变量和方法都放在 <code>IIFE</code> 的头部，然后将它们设置到需要被返回的对象上。</p>
<pre><code>//  一般写法
var yourObj = (function(){
    var age = 25;

    return {
        name: &quot;Ljc&quot;,

        getAge: function(){
            return agel
        }
    }
}());

// 暴露模块模式
var yourObj = (function(){
    var age = 25;
    function getAge(){
        return agel
    };
    return {
        name: &quot;Ljc&quot;,
        getAge: getAge
    }
}());
</code></pre><p>####6.1.2 构造函数的私有成员（不能通过对象直接访问）<br>模块模式在定义单个对象的私有属性十分有效，但对于那些同样需要私有属性的自定义类型呢？你可以在构造函数中使用类似的模式来创建每个实例的私有数据。</p>
<pre><code>function Person(name){
    // define a variable only accessible inside of the Person constructor
    var age = 22;

    this.name = name;
    this.getAge = function(){
        return age;
    };
    this.growOlder = function(){
        age++;
    }
}

var person = new Person(&quot;Ljc&quot;);

console.log(person.age); // undefined
person.age = 100;
console.log(person.getAge()); // 22

person.growOlder();
console.log(person.getAge()); // 23
</code></pre><p>这里有个问题：如果你需要<strong>对象实例</strong>拥有私有数据，就不能将相应方法放在 <code>prototype</code> 上。</p>
<p>如果你需要所有实例共享私有数据。则可结合模块模式和构造函数，如下：</p>
<pre><code>var Person = (function(){
    var age = 22;

    function InnerPerson(name){
        this.name = name;
    }

    InnerPerson.prototype.getAge = function(){
        return age;
    }
    InnerPerson.prototype.growOlder = function(){
        age++;
    };

    return InnerPerson;
}());

var person1 = new Person(&quot;Nicholash&quot;);
var person2 = new Person(&quot;Greg&quot;);

console.log(person1.name); // &quot;Nicholash&quot;
console.log(person1.getAge()); // 22

console.log(person2.name); // &quot;Greg&quot;
console.log(person2.getAge()); // 22

person1.growOlder();
console.log(person1.getAge()); // 23
console.log(person2.getAge()); // 23
</code></pre><p>###6.2 混入<br>这是一种伪继承。一个对象在不改变原型对象链的情况下得到了另外一个对象的属性被称为“混入”。因此，和继承不同，混入让你在创建对象后无法检查属性来源。<br>纯函数实现：</p>
<pre><code>function mixin(receiver, supplier){
    for(var property in supplier){
        if(supplier.hasOwnProperty(property)){
            receiver[property] = supplier[property];
        }
    }
}
</code></pre><p>这是浅拷贝，如果属性的值是一个引用，那么两者将指向同一个对象。</p>
<p>###6.3 作用域安全的构造函数<br>构造函数也是函数，所以不用 new 也能调用它们来改变 <code>this</code> 的值。在非严格模式下， <code>this</code> 被强制指向全局对象。而在严格模式下，构造函数会抛出一个错误（因为严格模式下没有为全局对象设置 <code>this</code>，<code>this</code> 保持为 <code>undefined</code>）。<br>而很多内建构造函数，例如 <code>Array</code>、<code>RegExp</code> 不需要 <code>new</code> 也能正常工作，这是因为它们被设计为作用域安全的构造函数。<br>当用 <code>new</code> 调用一个函数时，<code>this</code> 指向的新创建的对象是属于该构造函数所代表的自定义类型。因此，可在函数内用 <code>instanceof</code> 检查自己是否被 <code>new</code> 调用。</p>
<pre><code>function Person(name){
    if(this instanceof Person){
        // called with &quot;new&quot;
    }else{
        // called without &quot;new&quot;
    }
}
</code></pre><p>具体案例：</p>
<pre><code>function Person(name){
    if(this instanceof Person){
        this.name = name;
    }else{
        return new Person(name);
    }
}
</code></pre><p>##总结<br>看了两天的书，做了两天的笔记。当然这只是ES5的。过几天 ES6 新书又来了。最后感谢 <a href="http://www.epubit.com.cn/" target="_blank" rel="external">异步社区</a> 送我这本好书 <a href="http://www.epubit.com.cn/book/details/1798" target="_blank" rel="external">《JavaScript面向对象精要》</a>，让我的前端根基更加稳固，希望自己的前端之路越走越顺。</p>
<hr>
<p>本文转载自 <a href="http://jcidea.cc/2016/01/20/2016-1-19-object-oriented-programming-notes/" target="_blank" rel="external">刘健超(Jc)’s Blog</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript面向对象精要》这本书虽然不够100页，但都是精华，不愧是《JavaScript高级程序设计》作者 Nicholas C.Zakas 的最新力作。&lt;/p&gt;
&lt;p&gt;下面是我的读书笔记（ES5）：&lt;/p&gt;
&lt;p&gt;##1.原始类型和引用类型&lt;/p&gt;
&lt;p&gt;###1.1 什么是类型&lt;br&gt;&lt;strong&gt;原始类型&lt;/strong&gt; 保存为简单数据值。&lt;br&gt;&lt;strong&gt;引用类型&lt;/strong&gt; 保存为对象，其本质是指向内存位置的引用。&lt;/p&gt;
&lt;p&gt;为了让开发者能够把原始类型和引用类型按相同的方式处理，JavaScript花费了很大的努力来保证语言的一致性。&lt;/p&gt;
&lt;p&gt;其他编程语言用栈存原始类型，用对存储引用类型。而JavaScript则完全不同：它使用一个变量对象追踪变量的生存期。原始值被直接保存在变量对象内，而引用值则作为一个指针保存在变量对象内，该指针指向实际对象在内存中的存储位置。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript面向对象" scheme="http://zhangchuanfeng.me/tags/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="读书笔记" scheme="http://zhangchuanfeng.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript面向对象核心知识归纳</title>
    <link href="http://zhangchuanfeng.me/2016/12/02/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/"/>
    <id>http://zhangchuanfeng.me/2016/12/02/JavaScript面向对象核心知识归纳/</id>
    <published>2016-12-02T01:12:54.000Z</published>
    <updated>2016-12-02T03:06:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol>
<li>面向对象就是使用对象。面向对象开发就是使用对象开发。</li>
<li>面向过程就是用过程的方式进行开发。面向对象是对面向过程的封装。</li>
</ol>
<h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="抽象性"><a href="#抽象性" class="headerlink" title="抽象性"></a>抽象性</h3><p>所谓的抽象性就是：如果需要一个对象描述数据，需要抽取这个对象的核心数据</p>
<ol>
<li>提出需要的核心属性和方法</li>
<li>不在特定的环境下无法明确对象的具体意义</li>
</ol>
<h3 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h3><p>对象是将数据与共组合到一起，即封装<br><a id="more"></a></p>
<ol>
<li>JS 对象就是键值对的集合，键值如果是数据（基本数据、符合数据、空数据）就称为属性，如果键值是函数那么就称为方法</li>
<li>对象就是将属性与方法封装起来</li>
<li>方法是将过程封装起来</li>
</ol>
<h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>所谓继承性就是自己没有但别人有，拿过来成为自己的，就是继承。继承是实现复用的一种手段</p>
<ul>
<li>在 Java 等语言中继承满足一个 class 的规则，类是一个 class，它规定了一个对象有什么属性和方法</li>
<li>在这些语言中继承是 class 之间的继承，一个 class 继承另一个 class 创建出来的对象就同时具有两个 class 的成员</li>
</ul>
<p>在 JS 中没有明确的继承语法（ES6提供了 class extend 语法），一般都是按照继承的理念实现对象的成员扩充实现继承，因此 JS 中实现继承的方法非常多。</p>
<p>传统继承基于类，JS 继承基于对象</p>
<p>一个简单的继承模式：混入（mix）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span> (<span class="params">o1,o2</span>)</span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> o2)&#123;</div><div class="line">		o1[k] = o2[k];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="关于面向对象的其他概念"><a href="#关于面向对象的其他概念" class="headerlink" title="关于面向对象的其他概念"></a>关于面向对象的其他概念</h2><h3 id="类-class：在-JS-中就是构造函数"><a href="#类-class：在-JS-中就是构造函数" class="headerlink" title="类 class：在 JS 中就是构造函数"></a>类 class：在 JS 中就是构造函数</h3><ul>
<li>在传统的面向对象语言中，使用一个叫类的东西定义模板，然后使用模板创建对象</li>
<li>在构造方法中也有类似的功能，因此也称其为类</li>
</ul>
<h3 id="实例（instance）与对象（object）"><a href="#实例（instance）与对象（object）" class="headerlink" title="实例（instance）与对象（object）"></a>实例（instance）与对象（object）</h3><ul>
<li>实例一般是指某一个构造函数创建出来的对象，我们称为 XXXX 构造函数的实例</li>
<li>实例就是对象。对象是一个泛称</li>
<li>实例与对象是一个近义词</li>
</ul>
<h3 id="键值对与属性和方法"><a href="#键值对与属性和方法" class="headerlink" title="键值对与属性和方法"></a>键值对与属性和方法</h3><ul>
<li>在 JS 中键值对的集合称为对象</li>
<li>如果值为数据（非函数），就称该键值对为属性</li>
<li>如果值为函数（方法），就称该键值对为方法 method</li>
</ul>
<h3 id="父类与子类（基类和派生类）"><a href="#父类与子类（基类和派生类）" class="headerlink" title="父类与子类（基类和派生类）"></a>父类与子类（基类和派生类）</h3><ul>
<li>传统的面向对象语言中使用类来实现继承那么就有父类、子类的概念</li>
<li>父类又称为基类，子类又称为派生类</li>
<li>在 JS 中没有类的概念，在 JS 中常常称为父对象、子对象，基对象、派生对象</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="构造函数是干什么用的"><a href="#构造函数是干什么用的" class="headerlink" title="构造函数是干什么用的"></a>构造函数是干什么用的</h3><ul>
<li>初始化数据的</li>
<li>在 JS 中给对象添加属性用的，初始化属性值用的</li>
</ul>
<h3 id="面向对象的过程"><a href="#面向对象的过程" class="headerlink" title="面向对象的过程"></a>面向对象的过程</h3><ol>
<li>代码： var p = new Person();</li>
<li>首先运算符 new 创建了一个对象，类似于{}，是一个没有任何（自定义）成员的对象<ul>
<li>使用 new 创建对象，那么对象的类型就是创建他的构造函数名</li>
<li>使用{}无论如何都是 Object 类型，相当于 new Object</li>
</ul>
</li>
<li>然后调用构造函数，为其初始化成员<ul>
<li>构造函数在调用的一开始，有一个赋值操作，即 this = 刚刚创立出来的对象</li>
<li>因此在构造函数中 this 表示刚刚创建出来的对象</li>
</ul>
</li>
<li>在构造函数中利用对象的动态特性为其对象添加成员</li>
</ol>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h3><p>域表示的就是范围，即作用域，就是一个名字在什么地方可以使用，什么地方不能使用</p>
<h3 id="JS-中词法作用域的规则"><a href="#JS-中词法作用域的规则" class="headerlink" title="JS 中词法作用域的规则"></a>JS 中词法作用域的规则</h3><ul>
<li>函数允许访问函数外部的数据</li>
<li>整个代码结构中只有函数可以限定作用域</li>
<li>作用规则首先使用提升规则分析</li>
<li>如果当前作用域中有了名字了，就不考虑外面的名字</li>
</ul>
<h3 id="属性搜索原则"><a href="#属性搜索原则" class="headerlink" title="属性搜索原则"></a>属性搜索原则</h3><ul>
<li>所谓的属性搜索原则，就是对象在访问属性或方法的时候，首先在当前对象中查找</li>
<li>如果当前对象中存储着属性或方法，停止查找，直接使用该属性或方法</li>
<li>如果当前对象没有该成员，那么再在其原型对象中查找</li>
<li>如果原型对象中含有该成员，那么停止查找，直接使用</li>
<li>如果原型中还没有，就到原型的原型中查找</li>
<li>如此往复，直到Object.protitype还没有，那么就返回undefined</li>
<li>如果是调用方法就报错，该xxx不是一个函数</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><p>闭包的含义就是闭合，包起来，简单的来说，就是一个具有封闭功能与包裹功能的结构。所谓的闭包就是一个具有封闭的对外不公开的，包裹结构，或空间。</p>
<h3 id="为什么函数可以构成闭包？"><a href="#为什么函数可以构成闭包？" class="headerlink" title="为什么函数可以构成闭包？"></a>为什么函数可以构成闭包？</h3><p>闭包就是一个具有封闭与包裹功能的结构，是为了实现具有私有访问空间的函数的。函数可以构成闭包。函数内部定义的数据函数外部无法访问，即函数具有封闭性；函数可以封装代码即具有包裹性，所以函数可以构成闭包。</p>
<h3 id="闭包有什么用"><a href="#闭包有什么用" class="headerlink" title="闭包有什么用"></a>闭包有什么用</h3><p>闭包不允许外部访问，要解决的问题就是让外部间接访问函数内部的数据。事实上，通过使用闭包，我们可以做很多事情。比如模拟面向对象的代码风格；更优雅，更简洁的表达出代码；在某些方面提升代码的执行效率。利用闭包可以实现如下需求：</p>
<ul>
<li>匿名自执行函数一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。</li>
<li>缓存闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</li>
<li>实现封装</li>
<li>模拟面向对象的代码风格</li>
</ul>
<h3 id="闭包的基本模型"><a href="#闭包的基本模型" class="headerlink" title="闭包的基本模型"></a>闭包的基本模型</h3><ul>
<li><strong>对象模式：</strong>函数内部定义个一个对象，对象中绑定多个函数（方法），返回对象，利用对象的方法访问函数内的数据</li>
<li><strong>函数模式：</strong>函数内部定义一个新函数，返回新函数，用新函数获得函数内的数据</li>
<li><strong>沙箱模式：</strong>沙箱模式就是一个自调用函数，代码写到函数中一样会执行，但是不会与外界有任何的影响</li>
</ul>
<h3 id="闭包的作用举例"><a href="#闭包的作用举例" class="headerlink" title="闭包的作用举例"></a>闭包的作用举例</h3><ul>
<li>获得超过一个数据，返回一个对象</li>
<li>完成读取一个数据和修改这个数据，对象里面的 get、set 方法</li>
</ul>
<h3 id="闭包的性能问题"><a href="#闭包的性能问题" class="headerlink" title="闭包的性能问题"></a>闭包的性能问题</h3><p>函数执行需要内存，那么函数中定义的变量，会在函数执行结束后自动回收，凡是因为闭包结构的，被引出的数据，如果还有变量引用这些数据的话，那么这些数据就不会被回收。<strong>因此在使用闭包的时候如果不使用某些数据了，一定要赋值一个null</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> num = <span class="number">123</span>;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> num;</div><div class="line">	&#125;;</div><div class="line">&#125;)();</div><div class="line"><span class="comment">// f 引用着函数，函数引用着变量num</span></div><div class="line"><span class="comment">// 因此在不使用该数据的时候，最好写上</span></div><div class="line">f = <span class="literal">null</span>;</div></pre></td></tr></table></figure>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h3><p>一句话说明什么是原型：原型能存储我们的方法，构造函数创建出来的实例对象能够引用原型中的方法。</p>
<p>JS中一切皆对象，而每个对象都有一个原型（Object除外），这个原型，大概就像Java中的父类，所以，基本上你可以认为原型就是这个对象的父对象，即每一个对象（Object除外）内部都保存了它自己的父对象，这个父对象就是原型。一般创建的对象如果没有特别指定原型，那么它的原型就是Object(这就很类似Java中所有的类默认继承自Object类)。</p>
<p>ES6通过引入class ,extends等关键字，以一种语法糖的形式把构造函数包装成类的概念，更便于大家理解。是希望开发者不再花精力去关注原型以及原型链，也充分说明原型的设计意图和类是一样的。</p>
<h3 id="查看对象的原型"><a href="#查看对象的原型" class="headerlink" title="查看对象的原型"></a>查看对象的原型</h3><p>当对象被创建之后，查看它们的原型的方法不止一种，以前一般使用对象的<code>_proto__</code>属性，ES6推出后，推荐用 Object.getPrototypeOf()方法来获取对象的原型.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = <span class="string">'lala'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line"><span class="built_in">console</span>.log(a.__proto__)</div><div class="line"><span class="comment">//输出：Object &#123;&#125;</span></div><div class="line">  </div><div class="line"><span class="comment">//推荐使用这种方式获取对象的原型</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(a))</div><div class="line"><span class="comment">//输出：Object &#123;&#125;</span></div></pre></td></tr></table></figure>
<p>无论对象是如何创建的，默认原型都是Object，在这里需要提及的比较特殊的一点就是，通过构造函数来创建对象，函数A本身也是一个对象，而A有两个指向表示原型的属性，分别是proto和prototype，而且两个属性并不相同</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name=<span class="string">'lala'</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> A();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(A.prototype) </div><div class="line"><span class="comment">//输出：Object &#123;&#125;</span></div><div class="line">  </div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(A.__proto__) </div><div class="line"><span class="comment">//输出：function () &#123;&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(A))</div><div class="line"><span class="comment">//输出：function () &#123;&#125;</span></div></pre></td></tr></table></figure>
<p>函数的 prototype 属性只有在当作构造函数创建的时候，把自身的 prototype 属性值赋给对象的原型。而实际上，作为函数本身，它的原型应该是function对象，然后function对象的原型才是Object。</p>
<p><strong>总之，建议使用ES6推荐的查看原型和设置原型的方法。</strong></p>
<h3 id="原型的用法"><a href="#原型的用法" class="headerlink" title="原型的用法"></a>原型的用法</h3><p>其实原型和类的继承的用法是一致的：当你想用某个对象的属性时，将当前对象的原型指向该对象，你就拥有了该对象的使用权了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name=<span class="string">'world '</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.bb=<span class="string">"hello"</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> A();</div><div class="line"></div><div class="line"><span class="keyword">var</span> b=<span class="keyword">new</span> B();</div><div class="line"><span class="comment">//将b设置为a的原型,此处有一个问题，即a的constructor也指向了B构造函数，可能需要纠正 </span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(a,b);</div><div class="line"></div><div class="line">a.constructor=A;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a.bb); <span class="comment">//hello</span></div></pre></td></tr></table></figure>
<p>如果使用ES6来做的话则简单许多，甚至不涉及到prototype这个属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</div><div class="line"></div><div class="line">     <span class="keyword">constructor</span>()&#123;</div><div class="line"></div><div class="line">         <span class="keyword">this</span>.bb=<span class="string">'hello'</span></div><div class="line"></div><div class="line">     &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</div><div class="line"></div><div class="line">     <span class="keyword">constructor</span>()&#123;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>();</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.name=<span class="string">'world'</span>;</div><div class="line"></div><div class="line">     &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">  </div><div class="line"></div><div class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> A();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a.bb+<span class="string">" "</span>+a.name); <span class="comment">//hello world   </span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(A))  <span class="comment">//"function"</span></div></pre></td></tr></table></figure>
<p>怎么样？是不是已经完全看不到原型的影子了？活脱脱就是类继承，但是你也看得到实际上类A 的类型是 function，所以说，本质上 class 在 JS 中是一种语法糖，JS 继承的本质依然是原型，不过，ES6 引入 class，extends 来掩盖原型的概念也是一个很友好的举动，对于长期学习那些类继承为基础的面对对象编程语言的程序员而言。</p>
<p><strong>尽可能理解原型，尽可能用class这种语法糖。</strong></p>
<p>好了，问自己两个问题：</p>
<ol>
<li>为什么要使用原型？ –提高函数的复用性</li>
<li>为什么属性不放在原型上而方法要放在原型上？<ul>
<li>利用对象的动态特性：构造函数.prototype.xxx = vvv</li>
<li>利用直接替换</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> Student.prototype = &#123;</div><div class="line"></div><div class="line">    <span class="attr">sayHello</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</div><div class="line"></div><div class="line">    <span class="attr">study</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h3><p>凡是对象就有原型，那么原型又是对象，因此凡是给定一个对象，那么就可以找到他的原型，原型还有原型，那么如此下去，就构成一个对象的序列，称该结构为原型链。</p>
<p>这个概念其实也变得比较简单，可以类比类的继承链条，即每个对象的原型往上追溯，一直到Object为止，这组成了一个链条，将其中的对象串联起来，当查找当前对象的属性时，如果没找到，就会沿着这个链条去查找，一直到Object，如果还没发现，就会报undefined。</p>
<h3 id="原型链的结构"><a href="#原型链的结构" class="headerlink" title="原型链的结构"></a>原型链的结构</h3><p>凡是使用构造函数，创建出对象，并且没有利用赋值的方式修改原型，就说该对象保留默认的原型链。</p>
<p>默认原型链结构是什么样子呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"><span class="comment">//p 具有默认的原型链</span></div></pre></td></tr></table></figure>
<p>默认的原型链结构就是：<em>当前对象 -&gt; 构造函数.prototype -&gt; Object.prototype -&gt; null</em></p>
<p>在实现继承的时候，有时候会利用替换原型链结构的方式实现原型继承，那么原型链结构就会发生改变</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">DunizbCollection</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">DunizbCollection.prototype = [];</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> DunizbCollection();</div></pre></td></tr></table></figure>
<p>此时arr对象的原型链结构被指向了数组对象的原型链结构了：<em>arr -&gt; [] -&gt; Array.prototype -&gt; Object.prototype -&gt; null</em></p>
<h3 id="用图形表示对象的原型链结构"><a href="#用图形表示对象的原型链结构" class="headerlink" title="用图形表示对象的原型链结构"></a>用图形表示对象的原型链结构</h3><p>以如下代码为例绘制原型链结构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<p>原型链结构图为：<br><img src="http://ww3.sinaimg.cn/large/006y8mN6jw1fac8coydvnj30hb0bo0tk.jpg" alt=""></p>
<p>使用原型需要注意两点：</p>
<ol>
<li>原型继承链条不要太长，否则会出现效率问题</li>
<li>指定原型时，注意 constructor 也会改变</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>实现继承有两种常见方式：</p>
<h4 id="混合式继承："><a href="#混合式继承：" class="headerlink" title="混合式继承："></a>混合式继承：</h4><p>最简单的继承就是将别的对象的属性强加到我身上，那么我就有这个成员了。<br>混合式继承的简单描述：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">Person.prototype.extend = <span class="function"><span class="keyword">function</span> (<span class="params"> o </span>) </span>&#123;</div><div class="line">     <span class="keyword">for</span> ( <span class="keyword">var</span> k <span class="keyword">in</span> o ) &#123;</div><div class="line">          <span class="keyword">this</span>[ k ] = o[ k ];</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line">Person.prototype.extend(&#123;</div><div class="line">      <span class="attr">run</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">'我能跑了'</span> ); &#125;,</div><div class="line">      <span class="attr">eat</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">'我可以吃了'</span> ); &#125;,</div><div class="line">      <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">'我吃饱了'</span> ); &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><p>利用原型也可以实现继承，不需要在我身上添加任何成员，只要原型有了我就有了。</p>
<h4 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h4><p>这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数，而函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在（将来）新创建的对象上执行构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"> name, age, gender </span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">        <span class="keyword">this</span>.gender = gender;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 需要提供一个 Student 的构造函数创建学生对象</span></div><div class="line"><span class="comment">// 学生也应该有 name, age, gender, 同时还需要有 course 课程</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params"> name, age, gender, course </span>) </span>&#123;</div><div class="line">        Person.call( <span class="keyword">this</span>, name, age, gender )；</div><div class="line">        <span class="keyword">this</span>.course = course;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在《JavaScript高级程序设计（第三版）》中详细介绍了继承的6种方式</p>
<h2 id="函数的四种调用模式"><a href="#函数的四种调用模式" class="headerlink" title="函数的四种调用模式"></a>函数的四种调用模式</h2><h3 id="函数模式"><a href="#函数模式" class="headerlink" title="函数模式"></a>函数模式</h3><p>就是一个简单的函数调用。函数名的前面没有任何引导内容。</p>
<h3 id="方法模式"><a href="#方法模式" class="headerlink" title="方法模式"></a>方法模式</h3><p>方法一定式依附于一个对象，将函数赋值给对象的一个属性，那么就成了方法。</p>
<h3 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h3><p>创建对象的时候构造函数做了什么？由于构造函数只是给 this 添加成员，没有做其他事情。而方法也可以完成这个操作，就是 this 而言，构造函数与方法没有本质的区别。</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ol>
<li>使用 new 关键字，来引导函数</li>
<li>构造函数中的 this 与方法中的一样，表示对象，但是构造函数中的对象是刚刚创建出来的对象</li>
<li>构造函数中不需要 return，就会默认的 return this<ul>
<li>如果手动添加return ，就相当于 return this</li>
<li>如果手动的添加 return 基本类型，无效，还是保留原来 返回 this</li>
<li>如果手动添加的 return null，或 return undefined ，无效</li>
<li>如果手动添加 return 对象类型，那么原来创建的 this 就会被丢掉，返回的是 return 后面的对象</li>
</ul>
</li>
</ol>
<h3 id="创建对象的模式"><a href="#创建对象的模式" class="headerlink" title="创建对象的模式"></a>创建对象的模式</h3><ol>
<li>工厂方法。工厂就是用来生产的，因此如果函数创建对象并返回，就称该函数为工厂函数</li>
<li>构造方法</li>
<li>寄生式创建</li>
<li>混合式创建</li>
</ol>
<h3 id="上下文调用模式"><a href="#上下文调用模式" class="headerlink" title="上下文调用模式"></a>上下文调用模式</h3><p>上下文就是环境。就是自定义设置 this 的含义</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul>
<li>函数名.apply(对象,[参数]);</li>
<li>函数名.call(对象，参数);</li>
</ul>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><ol>
<li>函数名就是表示函数本身，使用函数进行调用的时候默认 this 是全局变量</li>
<li>函数名也可以是方法提供，使用方法调用的时候，this 是指向当前对象</li>
<li>使用 apply 进行调用后，无论是函数还是方法都无效了，我们的 this ，由 apply 的第一个参数决定</li>
</ol>
<h4 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h4><p>无论是 call 还是 apply 在没有后面的参数的情况下（函数无参数，方法无参数）是完全一致的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span> );</div><div class="line">&#125;</div><div class="line">foo.apply( obj );</div><div class="line">foo.call( obj );</div></pre></td></tr></table></figure>
<p>第一个参数的使用也是有规则的:</p>
<p>1.如果传入的是一个对象，那么就相当于设置该函数中的 this 为参数</p>
<p>2.如果不传入参数，或传入 null 、undefined 等，那么相当于 this 默认为 window</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">foo();</div><div class="line">foo.apply();</div><div class="line">foo.apply( <span class="literal">null</span> );</div><div class="line">foo.call( <span class="literal">undefined</span> );</div></pre></td></tr></table></figure>
<p>3.如果传入的是基本类型，那么 this 就是基本类型对应的包装类型的引用<br>在使用上下文调用的时候，原函数（方法）可能会带有参数，那么这个参数再上下文调用中使用 第二个（第 n 个）参数来表示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"> num </span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( num );</div><div class="line">&#125;</div><div class="line">foo.apply( <span class="literal">null</span>, [ <span class="number">123</span> ] );</div><div class="line"><span class="comment">// 等价于</span></div><div class="line">foo( <span class="number">123</span> );</div></pre></td></tr></table></figure>
<hr>
<p><strong>参考资料</strong></p>
<ul>
<li>本文原型部分部分引用自<a href="http://www.admin10000.com/document/9336.html" target="_blank" rel="external">《JavaScript原型详解》</a>，版权归原作者所有</li>
<li><a href="http://blog.csdn.net/sunlylorn/article/details/6534610" target="_blank" rel="external">js闭包的用途</a></li>
</ul>
<hr>
<p>本文首发于 <a href="http://www.imooc.com/u/173711/articles" target="_blank" rel="external">慕课网</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;面向对象就是使用对象。面向对象开发就是使用对象开发。&lt;/li&gt;
&lt;li&gt;面向过程就是用过程的方式进行开发。面向对象是对面向过程的封装。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;三大特性&quot;&gt;&lt;a href=&quot;#三大特性&quot; class=&quot;headerlink&quot; title=&quot;三大特性&quot;&gt;&lt;/a&gt;三大特性&lt;/h2&gt;&lt;h3 id=&quot;抽象性&quot;&gt;&lt;a href=&quot;#抽象性&quot; class=&quot;headerlink&quot; title=&quot;抽象性&quot;&gt;&lt;/a&gt;抽象性&lt;/h3&gt;&lt;p&gt;所谓的抽象性就是：如果需要一个对象描述数据，需要抽取这个对象的核心数据&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提出需要的核心属性和方法&lt;/li&gt;
&lt;li&gt;不在特定的环境下无法明确对象的具体意义&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;封装性&quot;&gt;&lt;a href=&quot;#封装性&quot; class=&quot;headerlink&quot; title=&quot;封装性&quot;&gt;&lt;/a&gt;封装性&lt;/h3&gt;&lt;p&gt;对象是将数据与共组合到一起，即封装&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript面向对象" scheme="http://zhangchuanfeng.me/tags/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>跨域-知识</title>
    <link href="http://zhangchuanfeng.me/2016/11/24/%E8%B7%A8%E5%9F%9F-%E7%9F%A5%E8%AF%86/"/>
    <id>http://zhangchuanfeng.me/2016/11/24/跨域-知识/</id>
    <published>2016-11-24T12:18:56.000Z</published>
    <updated>2016-11-25T01:28:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章目录：</p>
<ul>
<li><a href="http://www.cnblogs.com/scottckt/archive/2011/11/12/2246557.html" target="_blank" rel="external">跨域-知识</a>  </li>
<li><a href="http://www.cnblogs.com/scottckt/archive/2011/11/12/2246557.html" target="_blank" rel="external">跨域-使用 JSONP</a>  </li>
<li><a href="http://www.cnblogs.com/scottckt/archive/2011/11/12/2246749.html" target="_blank" rel="external">跨域-使用 js 文件</a></li>
<li><a href="http://www.cnblogs.com/scottckt/archive/2011/11/12/2246787.html" target="_blank" rel="external">跨域-使用 window.name</a></li>
<li><a href="http://www.cnblogs.com/scottckt/archive/2011/11/12/2246793.html" target="_blank" rel="external">跨域-使用 Proxy page 或 Cross Frame</a></li>
</ul>
<hr>
<h2 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h2><p>  跨域可简单理解为 JavaScript 同源策略的限制。</p>
<h2 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h2><p>在客户端编程语言中，如JavaScript和ActionScript，同源策略是一个很重要的安全理念，它在保证数据的安全性方面有着重要的意义。同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。那么什么叫相同域，什么叫不同的域呢？当两个域具有相同的协议(如http), 相同的端口(如80)，相同的host（如www.example.org)，那么我们就可以认为它们是相同的域。<br><a id="more"></a><br>比如 <a href="http://www.example.org/index.html和http://www.example.org/sub/index.html是同域，而http://www.example.org" target="_blank" rel="external">http://www.example.org/index.html和http://www.example.org/sub/index.html是同域，而http://www.example.org</a>, <a href="https://www.example.org" target="_blank" rel="external">https://www.example.org</a>, <a href="http://www.example.org:8080" target="_blank" rel="external">http://www.example.org:8080</a>, <a href="http://sub.example.org中的任何两个都将构成跨域。同源策略还应该对一些特殊情况做处理，比如限制file协议下脚本的访问权限。本地的HTML文件在浏览器中是通过file协议打开的，如果脚本能通过file协议访问到硬盘上其它任意文件，就会出现安全隐患，目前IE8还有这样的隐患。" target="_blank" rel="external">http://sub.example.org中的任何两个都将构成跨域。同源策略还应该对一些特殊情况做处理，比如限制file协议下脚本的访问权限。本地的HTML文件在浏览器中是通过file协议打开的，如果脚本能通过file协议访问到硬盘上其它任意文件，就会出现安全隐患，目前IE8还有这样的隐患。</a><br>受到同源策略的影响，跨域资源共享就会受到制约。但是随着人们的实践和浏览器的进步，目前在跨域请求的技巧上，有很多宝贵经验的沉淀和积累。这里我把跨域资源共享分成两种，一种是单向的数据请求，还有一种是双向的消息通信。</p>
<p> 详细情况请看下表：<br> <img src="http://ww3.sinaimg.cn/large/65e4f1e6jw1fa3gxszn3mj20he0fnmzb.jpg" alt=""></p>
<h2 id="单向跨域"><a href="#单向跨域" class="headerlink" title="单向跨域"></a>单向跨域</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP (JSON with Padding)是一个简单高效的跨域方式，HTML中的script标签可以加载并执行其他域的JavaScript，于是我们可以通过script标记来动态加载其他域的资源。例如我要从域A的页面pageA加载域B的数据，那么在域B的页面pageB中我以JavaScript的形式声明pageA 需要的数据，然后在pageA中用script标签把pageB加载进来，那么pageB中的脚本就会得以执行。JSONP在此基础上加入了回调函数，pageB加载完之后会执行pageA中定义的函数，所需要的数据会以参数的形式传递给该函数。JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。但是在受信任的双方传递数据，JSONP是非常合适的选择。</p>
<h3 id="Flash-URLLoader"><a href="#Flash-URLLoader" class="headerlink" title="Flash URLLoader"></a>Flash URLLoader</h3><p>Flash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。当跨域访问资源时，例如从域www.a.com请求域www.b.com上的数据，我们可以借助Flash来发送 HTTP请求。首先，修改域www.b.com上的crossdomain.xml(一般存放在根目录，如果没有需要手动创建) ，把www.a.com加入到白名单。其次，通过Flash URLLoader发送HTTP请求，最后，通过Flash API把响应结果传递给JavaScript。Flash URLLoader是一种很普遍的跨域解决方案，不过需要支持iOS的话，这个方案就无能为力了。</p>
<h3 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h3><p>Access Control是比较超越的跨域方式，目前只在很少的浏览器中得以支持，这些浏览器可以发送一个跨域的HTTP请求（Firefox, Google Chrome等通过XMLHTTPRequest实现，IE8下通过XDomainRequest实现），请求的响应必须包含一个Access- Control-Allow-Origin的HTTP响应头，该响应头声明了请求域的可访问权限。例如www.a.com对www.b.com下的 asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头：header(“Access-Control-Allow-Origin: <a href="http://www.a.com%22);%7f/" target="_blank" rel="external">http://www.a.com%22);%7f/</a></p>
<h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><p>window对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。那么我们可以在页面A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给 window.name，iframe加载完成之后，页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出window.name的值了。这个方式非常适合单向的数据请求，而且协议简单、安全。不会像JSONP那样不做限制地执行外部脚本。</p>
<h3 id="server-proxy"><a href="#server-proxy" class="headerlink" title="server proxy"></a>server proxy</h3><p>在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。例如当www.a.com域下的页面需要请求www.b.com下的资源文件asset.txt时，直接发送一个指向 www.b.com/asset.txt的ajax请求肯定是会被浏览器阻止。这时，我们在www.a.com下配一个代理，然后把ajax请求绑定到这个代理路径下，例如www.a.com/proxy/, 然后这个代理发送HTTP请求访问<a href="http://www.b.com/下的asset.txt，跨域的HTTP请求是在服务器端进行的，客户端并没有产生跨域的ajax请求。这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。" target="_blank" rel="external">http://www.b.com/下的asset.txt，跨域的HTTP请求是在服务器端进行的，客户端并没有产生跨域的ajax请求。这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。</a></p>
<h2 id="双向跨域"><a href="#双向跨域" class="headerlink" title="双向跨域"></a>双向跨域</h2><h3 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h3><p>通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。同域策略认为域和子域隶属于不同的域，比如 www.a.com和sub.a.com是不同的域，这时，我们无法在www.a.com下的页面中调用sub.a.com中定义的JavaScript 方法。但是当我们把它们document的domain属性都修改为a.com，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的 method来通信了。</p>
<h3 id="FIM-–-Fragment-Identitier-Messaging"><a href="#FIM-–-Fragment-Identitier-Messaging" class="headerlink" title="FIM – Fragment Identitier Messaging"></a>FIM – Fragment Identitier Messaging</h3><p>不同的域之间，JavaScript只能做很有限的访问和操作，其实我们利用这些有限的访问权限就可以达到跨域通信的目的了。FIM (Fragment Identitier Messaging)就是在这个大前提下被发明的。父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为frag，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带frag，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。FIM的原理就是改变URL的frag部分来进行双向通信。每个window通过改变其他 window的location来发送消息，并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，URL在浏览器下有长度限制，这个制约了每次传送的数据量。</p>
<h3 id="Flash-LocalConnection"><a href="#Flash-LocalConnection" class="headerlink" title="Flash LocalConnection"></a>Flash LocalConnection</h3><p>页面上的双向通信也可以通过Flash来解决，Flash API中有LocalConnection这个类，该类允许两个SWF之间通过进程通信，这时SWF可以播放在独立的Flash Player或者AIR中，也可以嵌在HTML页面或者是PDF中。遵循这个通信原则，我们可以在不同域的HTML页面各自嵌套一个SWF来达到相互传递数据的目的了。SWF通过LocalConnection交换数据是很快的，但是每次的数据量有40kb的大小限制。用这种方式来跨域通信过于复杂，而且需要了2个SWF文件，实用性不强。</p>
<h3 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h3><p>window.postMessage是HTML5定义的一个很新的方法，这个方法可以很方便地跨window通信。由于它是一个很新的方法，所以在很旧和比较旧的浏览器中都无法使用。</p>
<h3 id="Cross-Frame"><a href="#Cross-Frame" class="headerlink" title="Cross Frame"></a>Cross Frame</h3><p>Cross Frame是FIM的一个变种，它借助了一个空白的iframe，不会产生多余的浏览器历史记录，也不需要轮询URL的改变，在可用性和性能上都做了很大的改观。它的基本原理大致是这样的，假设在域www.a.com上有页面A.html和一个空白代理页面proxyA.html, 另一个域www.b.com上有个页面B.html和一个空白代理页面proxyB.html，A.html需要向B.html中发送消息时，页面会创建一个隐藏的iframe, iframe的src指向proxyB.html并把message作为URL frag，由于B.html和proxyB.html是同域，所以在iframe加载完成之后，B.html可以获得iframe的URL，然后解析出 message，并移除该iframe。当B.html需要向A.html发送消息时，原理一样。Cross Frame是很好的双向通信方式，而且安全高效，但是它在Opera中无法使用，不过在Opera下面我们可以使用更简单的 window.postMessage来代替。</p>
<p>本文参考文章：<br><a href="">http://www.cnblogs.com/scottckt/archive/2011/11/12/2246531.html</a></p>
<p><a href="">http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html</a></p>
<p><a href="">http://www.cnblogs.com/cat3/archive/2011/06/15/2081559.html</a></p>
<hr>
<p>相关文章：</p>
<p><a href="https://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html" target="_blank" rel="external">JavaScript跨域总结与解决办法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/scottckt/archive/2011/11/12/2246557.html&quot;&gt;跨域-知识&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/scottckt/archive/2011/11/12/2246557.html&quot;&gt;跨域-使用 JSONP&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/scottckt/archive/2011/11/12/2246749.html&quot;&gt;跨域-使用 js 文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/scottckt/archive/2011/11/12/2246787.html&quot;&gt;跨域-使用 window.name&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/scottckt/archive/2011/11/12/2246793.html&quot;&gt;跨域-使用 Proxy page 或 Cross Frame&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;什么是跨域？&quot;&gt;&lt;a href=&quot;#什么是跨域？&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域？&quot;&gt;&lt;/a&gt;什么是跨域？&lt;/h2&gt;&lt;p&gt;  跨域可简单理解为 JavaScript 同源策略的限制。&lt;/p&gt;
&lt;h2 id=&quot;什么是同源策略&quot;&gt;&lt;a href=&quot;#什么是同源策略&quot; class=&quot;headerlink&quot; title=&quot;什么是同源策略&quot;&gt;&lt;/a&gt;什么是同源策略&lt;/h2&gt;&lt;p&gt;在客户端编程语言中，如JavaScript和ActionScript，同源策略是一个很重要的安全理念，它在保证数据的安全性方面有着重要的意义。同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。那么什么叫相同域，什么叫不同的域呢？当两个域具有相同的协议(如http), 相同的端口(如80)，相同的host（如www.example.org)，那么我们就可以认为它们是相同的域。&lt;br&gt;
    
    </summary>
    
    
      <category term="跨域" scheme="http://zhangchuanfeng.me/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSS 布局</title>
    <link href="http://zhangchuanfeng.me/2016/11/23/CSS%E5%B8%83%E5%B1%80/"/>
    <id>http://zhangchuanfeng.me/2016/11/23/CSS布局/</id>
    <published>2016-11-23T12:40:31.000Z</published>
    <updated>2016-11-24T12:47:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天偶然发现 <a href="http://zh.learnlayout.com" target="_blank" rel="external">学习 CSS 布局</a> 这个网站，又从头到尾把 CSS 布局有关的知识梳理了一遍，做成了下面的思维导图。</p>
<a id="more"></a>
<p><img src="http://ww4.sinaimg.cn/large/65e4f1e6jw1fa3hgr3kwdj20w40rn0ug.jpg" alt=""></p>
<p>通过梳理，发现自己对 Flex 布局还不了解，谷歌后发现阮一峰大大的教程不错，打算跟着学习一下。</p>
<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">Flex 布局教程：语法篇</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="external">Flex 布局教程：实例篇</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天偶然发现 &lt;a href=&quot;http://zh.learnlayout.com&quot;&gt;学习 CSS 布局&lt;/a&gt; 这个网站，又从头到尾把 CSS 布局有关的知识梳理了一遍，做成了下面的思维导图。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="http://zhangchuanfeng.me/tags/CSS/"/>
    
      <category term="布局" scheme="http://zhangchuanfeng.me/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>如何在短时间内掌握一项技能--知乎 Live</title>
    <link href="http://zhangchuanfeng.me/2016/11/22/%E5%A6%82%E4%BD%95%E5%9C%A8%E7%9F%AD%E6%97%B6%E9%97%B4%E5%86%85%E6%8E%8C%E6%8F%A1%E4%B8%80%E9%A1%B9%E6%8A%80%E8%83%BD--%E7%9F%A5%E4%B9%8E%20Live/"/>
    <id>http://zhangchuanfeng.me/2016/11/22/如何在短时间内掌握一项技能--知乎 Live/</id>
    <published>2016-11-22T10:24:48.000Z</published>
    <updated>2016-11-23T06:50:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Live-简介"><a href="#Live-简介" class="headerlink" title="Live 简介"></a>Live 简介</h2><p>我是 Scott Young ，一位因为快速学习而成名的神奇小子，应用自己发明的学习方法，完成了 10 天搞定线性代数、 1 年学习 4 年 MIT 课程的「不可能任务」，最近又在尝试一年学习四门外语（包括中文哦），经营着世界上最大的学习博客之一。从高中开始，我几乎课下不学习，尽管如此，还是以全班第 2 名的成绩毕业。读大学时，大考之前一般每天学习不过两个小时。不过， 4 年来，平均成绩总在 A 和 A+ 之间。毕业后登上 TEDx 的演讲台，向全世界宣讲自己的学习经验，是不折不扣的超级学霸。</p>
<p>本次 Live 我将带来对高效学习的更多心得，以及泛学习领域的各种心得，高效率的学习能够带给我们生活、工作更多的改变。</p>
<p>本次 Live 主要包括以下问题：</p>
<ul>
<li>如何高效学习？  </li>
<li>如何改变习惯？</li>
<li>在办公室外如何思考？</li>
<li>超效率手册是什么？  </li>
</ul>
<h2 id="Live-笔记思维导图"><a href="#Live-笔记思维导图" class="headerlink" title="Live 笔记思维导图"></a>Live 笔记思维导图</h2><p><img src="http://ww3.sinaimg.cn/large/006tNc79jw1fa14x5jhh0j30qc0h1ab5.jpg" alt=""></p>
<blockquote>
<p>通过视频和主题阅读来建立一个知识体系，形成知识地图，通过对基础概念和知识点的深入理解构建知识体系的主体框架，理论来说就是用80%的时间和精力集中在20%最重要的知识点上。同时需要把新学到的知识点跟大脑中以前的知识点做好连接。并根据每节课的学习进度进行实时反馈测试掌握情况，找出理解中的弱点进行补充完善。最后通过合理的记忆和复习技巧对知识点进行巩固。<br>作者：warfalcon<br>链接：<a href="https://www.zhihu.com/question/20571226/answer/15516872" target="_blank" rel="external">https://www.zhihu.com/question/20571226/answer/15516872</a><br>来源：知乎<br>著作权归作者所有，转载请联系作者获得授权。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Live-简介&quot;&gt;&lt;a href=&quot;#Live-简介&quot; class=&quot;headerlink&quot; title=&quot;Live 简介&quot;&gt;&lt;/a&gt;Live 简介&lt;/h2&gt;&lt;p&gt;我是 Scott Young ，一位因为快速学习而成名的神奇小子，应用自己发明的学习方法，完成了 1
    
    </summary>
    
    
      <category term="方法论" scheme="http://zhangchuanfeng.me/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>hexo 命令及 Markdown 语法</title>
    <link href="http://zhangchuanfeng.me/2016/11/20/hexo-%E5%91%BD%E4%BB%A4%E5%8F%8A-Markdown-%E8%AF%AD%E6%B3%95/"/>
    <id>http://zhangchuanfeng.me/2016/11/20/hexo-命令及-Markdown-语法/</id>
    <published>2016-11-20T02:58:50.000Z</published>
    <updated>2016-11-20T06:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><p>Hexo是使用 Markdown 编辑文章的，我写的这些文章也都是用这种标记语言完成的。所以，我们先从 Markdown 说起。</p>
<ul>
<li>什么是 Markdown</li>
<li>Markdown 语法</li>
<li>实战</li>
</ul>
<p>你可以使用 vim 工具直接编辑 .md 文件，也可以用记事本打开 .md 文件编辑你的文章，也可以 Markdown 的编辑器编写——这就是 Markdown 的特别之处，它不像 .doc 一样需要专门的软件打开。我是Mac系统，用的一个叫 MacDown 的编辑器，还比较好用。关于 Markdown 编辑器的选择，你可以查看以下文章：</p>
<ul>
<li><a href="http://www.jianshu.com/p/6ea395a6a35b" target="_blank" rel="external">Markdown编辑器一览,总有一款适合你</a></li>
</ul>
<h3 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h3><blockquote>
<p>Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯和亚伦·斯沃茨。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML文档”。 ——维基百科</p>
</blockquote>
<p>下面简单介绍一下 Markdown 的语法，具体使用相信您看到例子机会明白了。<br><a id="more"></a></p>
<h3 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h3><p><strong>1、 分段：</strong> <code>两个回车</code><br><strong>2、 换行：</strong> <code>两个空格 + 回车</code><br><strong>3、标题：</strong> <code>#</code>~<code>######</code> 井号的个数代表几级标题<br><strong>4、引用：</strong> <code>&gt;</code><br><strong>5、列表</strong> <code>*</code>,<code>+</code>,<code>-</code>,<code>1.</code> 均可，注意其后有个空格<br><strong>6、代码：</strong> 只有一行，用`将语句包起来。如果为多行，可以将```置于这段代码的首行和末行。<br><strong>7、链接：</strong> <code>[文字](链接地址)</code><br><strong>8：图片</strong> <code>![图片说明](图片链接)</code> ，图片链接可以是本地路径，也可以是网络地址<br><strong>9、强调：</strong> <code>**文字**</code>，<code>__文字__</code>，<code>_文字_</code><br><strong>10、斜体：</strong> <code>*文字*</code></p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>光看不练假本身，动手看看效果吧！<br>在线编辑器例文： <a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">传送门</a><br>MacDown 编辑器： <a href="http://macdown.uranusjr.com" target="_blank" rel="external">下载地址</a></p>
<h2 id="Hexo-常用命令"><a href="#Hexo-常用命令" class="headerlink" title="Hexo 常用命令"></a>Hexo 常用命令</h2><p><strong>1、新建</strong>  </p>
<pre><code>hexo new &quot;new post&quot;    
</code></pre><p>新建的文件在<code>hexo/source/_posts/new-post.md</code>，可前往打开编辑</p>
<p><strong>2、 编译</strong>  </p>
<pre><code>hexo g 
</code></pre><p>一般部署前都要编译一下，将所有的 .md 文件编译成 .html 文件并储存在<code>public</code> 文件夹  </p>
<p><strong>3、开启本地服务</strong>  </p>
<pre><code>hexo s  
</code></pre><p>开启本地服务后，就可以通过<code>http://localhost:4000/</code> 访问你的博客</p>
<p><strong>4、部署</strong></p>
<pre><code>hexo d  
</code></pre><p>部署到 git 等</p>
<p><strong>5、清除缓存</strong></p>
<pre><code>hexo c  
</code></pre><p>当<code>source</code>文件夹中的部分资源更改过之后，特别是对文件进行了删除或者路径的改变之后，需要执行这个命令，然后重新编译。</p>
<p>以上这些都是我在使用过程中经常用到的一些hexo命令。最为详细、最为全面的说明文档当然还是在<a href="http://zespia.tw/hexo/docs/commands.html" target="_blank" rel="external">官网</a>。请各位猛戳。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇博文介绍了常用的 Hexo 命令和 Markdown 语法，多练习多使用方能掌握~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Markdown&quot;&gt;&lt;a href=&quot;#Markdown&quot; class=&quot;headerlink&quot; title=&quot;Markdown&quot;&gt;&lt;/a&gt;Markdown&lt;/h2&gt;&lt;p&gt;Hexo是使用 Markdown 编辑文章的，我写的这些文章也都是用这种标记语言完成的。所以，我们先从 Markdown 说起。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是 Markdown&lt;/li&gt;
&lt;li&gt;Markdown 语法&lt;/li&gt;
&lt;li&gt;实战&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以使用 vim 工具直接编辑 .md 文件，也可以用记事本打开 .md 文件编辑你的文章，也可以 Markdown 的编辑器编写——这就是 Markdown 的特别之处，它不像 .doc 一样需要专门的软件打开。我是Mac系统，用的一个叫 MacDown 的编辑器，还比较好用。关于 Markdown 编辑器的选择，你可以查看以下文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/6ea395a6a35b&quot;&gt;Markdown编辑器一览,总有一款适合你&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;什么是-Markdown&quot;&gt;&lt;a href=&quot;#什么是-Markdown&quot; class=&quot;headerlink&quot; title=&quot;什么是 Markdown&quot;&gt;&lt;/a&gt;什么是 Markdown&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯和亚伦·斯沃茨。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML文档”。 ——维基百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面简单介绍一下 Markdown 的语法，具体使用相信您看到例子机会明白了。&lt;br&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://zhangchuanfeng.me/tags/hexo/"/>
    
      <category term="markdown" scheme="http://zhangchuanfeng.me/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>11.14-11.16 回家之行</title>
    <link href="http://zhangchuanfeng.me/2016/11/17/11-14-11-16-%E5%9B%9E%E5%AE%B6%E4%B9%8B%E8%A1%8C/"/>
    <id>http://zhangchuanfeng.me/2016/11/17/11-14-11-16-回家之行/</id>
    <published>2016-11-17T11:53:25.000Z</published>
    <updated>2016-11-17T11:57:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么回家"><a href="#为什么回家" class="headerlink" title="为什么回家"></a>为什么回家</h2><ol>
<li>去银行办点事</li>
<li>碰巧姐姐和外甥女在家，而且我们很长时间没见了</li>
<li>表妹正好也回家，顺路    </li>
</ol>
<h2 id="回家做了什么"><a href="#回家做了什么" class="headerlink" title="回家做了什么"></a>回家做了什么</h2><a id="more"></a>
<ol>
<li>银行的事情处理完毕</li>
<li>见了姐姐和外甥女，三天相处蛮愉快</li>
<li>见了表妹和她好朋友（maybe GF…）</li>
<li>帮伯伯把台式电脑从新房运到了老家并组装好，维护了系统，顺便谈妥寒假借房学习的事宜。</li>
</ol>
<h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><ol>
<li>去的工商银行办事效率太慢，两次去柜员都是五六十岁的中老年人，一会儿喝点水，一会儿泡点茶，不紧不慢，让人捉急</li>
<li>外甥女会说简单的话了，听到她叫“舅舅”时我十分兴奋。问她吃饭吗，她说“吃”；问她这（坏事）是你干的吗？回答“不是”，太有意思了。我们开玩笑说得把她当成人看了</li>
<li>之前不太了解伯伯，这次又有新的发现。首先伯伯注重仪表，给人一种给体面的感觉，让人肃然起敬；其次，在伯伯的书架上看到孙子兵法全集，还有一些其他的书，要知道伯伯平时非常忙，看不看书我不知道，但起码有这个心态；再次，事分轻重，理解并支持子女。总之伯伯给我的感觉就是一个优秀的人。</li>
<li>据说嫂子怀孕两个月了，哥哥也去了中国农业大学做博士后，工作两年后全家都会有北京户口，基本在北京扎根了。哥哥从小就充满青春气息。记得小时候他早晨起来在院里吼几嗓子，我也跟着吼。他在社交网络上也表现得积极向上。如今这般功成名就，努力获得回报，真是让人开心</li>
<li>关于<strong>健康</strong> 回家后得知二姨夫胃癌晚期，想不到这种事会发生在自己的亲戚身上。我刚开始很惊讶，后来想起来二姨夫经常吃热腾腾的食物，比如饺子。刚出锅的饺子，别人都不敢动口，二姨夫就狼吞虎咽地吃掉，还因此出名。在跟爸爸的交流中我发现我们和另一个衣服的想法不谋而合：可能这不是主要病因，但这绝对有影响。近期健康出问题的还有姐姐的婆婆，突发脑溢血晕倒，在医院快一个月了还有半边身子不太会动。所以关于健康，年轻时珍惜身体，不要太拼；年老时每年体检，及时发现问题。像以上两位，病情严重前都有感觉的，只不过他们或许是不在意， 或许是不舍得花钱、不想让亲人担心，所以都拖到了不能再拖的情况。</li>
</ol>
<h2 id="迷茫和不安"><a href="#迷茫和不安" class="headerlink" title="迷茫和不安"></a>迷茫和不安</h2><p>眼看秋招就快结束了，还没有找到工作，究其原因还是我不想将就本专业的工作，而对于前端开发的工作还没有达到任职要求。我需要时间，去细嚼慢咽，去仔细品味。</p>
<p><em>我虽然走地慢，但我不曾停下脚步。</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么回家&quot;&gt;&lt;a href=&quot;#为什么回家&quot; class=&quot;headerlink&quot; title=&quot;为什么回家&quot;&gt;&lt;/a&gt;为什么回家&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;去银行办点事&lt;/li&gt;
&lt;li&gt;碰巧姐姐和外甥女在家，而且我们很长时间没见了&lt;/li&gt;
&lt;li&gt;表妹正好也回家，顺路    &lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;回家做了什么&quot;&gt;&lt;a href=&quot;#回家做了什么&quot; class=&quot;headerlink&quot; title=&quot;回家做了什么&quot;&gt;&lt;/a&gt;回家做了什么&lt;/h2&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://zhangchuanfeng.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>腾讯公益404页面无法返回自己首页的解决办法</title>
    <link href="http://zhangchuanfeng.me/2016/11/13/%E8%85%BE%E8%AE%AF%E5%85%AC%E7%9B%8A404%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E8%BF%94%E5%9B%9E%E8%87%AA%E5%B7%B1%E9%A6%96%E9%A1%B5%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://zhangchuanfeng.me/2016/11/13/腾讯公益404页面无法返回自己首页的解决办法/</id>
    <published>2016-11-13T09:23:27.000Z</published>
    <updated>2016-11-13T09:42:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯公益404页面是个非常好的想法，<a href="http://www.qq.com/404/" target="_blank" rel="external">官方页面</a>说明如下：<br><img src="http://ww4.sinaimg.cn/large/006y8lVajw1f9qlzvnua2j30rb0kpq6c.jpg" alt=""><br>更人性化的一点是，其提供“返回腾讯网”超链接的可定制化能力，只需要修改两个参数即可：<br><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f9qm1cf8nwj30qu0k4tbl.jpg" alt=""><br>然而博主按照说明修改了两个参数，超链接文字却没有发生改变——依然是“返回腾讯网”，经一番搜索，终于找到了解决方法：<br><a id="more"></a><br>复制<a href="https://github.com/songjinzhong/404html/blob/master/404.html" target="_blank" rel="external">该页面</a>提供的代码到本地，然后修改第11行和第113行的参数为你的即可。效果如下：<br><img src="http://ww1.sinaimg.cn/large/006y8lVajw1f9qm85vlimj30ul0le78e.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;腾讯公益404页面是个非常好的想法，&lt;a href=&quot;http://www.qq.com/404/&quot;&gt;官方页面&lt;/a&gt;说明如下：&lt;br&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006y8lVajw1f9qlzvnua2j30rb0kpq6c.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;更人性化的一点是，其提供“返回腾讯网”超链接的可定制化能力，只需要修改两个参数即可：&lt;br&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/006y8lVajw1f9qm1cf8nwj30qu0k4tbl.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;然而博主按照说明修改了两个参数，超链接文字却没有发生改变——依然是“返回腾讯网”，经一番搜索，终于找到了解决方法：&lt;br&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://zhangchuanfeng.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>域名申请与解析</title>
    <link href="http://zhangchuanfeng.me/2016/11/13/%E5%9F%9F%E5%90%8D%E7%94%B3%E8%AF%B7%E4%B8%8E%E8%A7%A3%E6%9E%90/"/>
    <id>http://zhangchuanfeng.me/2016/11/13/域名申请与解析/</id>
    <published>2016-11-13T04:10:36.000Z</published>
    <updated>2016-11-13T07:10:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="域名申请与解析"><a href="#域名申请与解析" class="headerlink" title="域名申请与解析"></a>域名申请与解析</h1><h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>个人博客的网址是 github.io 一类的网址未免普通（Bigger 不够），而博主想正好借这次机会体验一下购买域名的流程，所以就开始选服务商啦！<br><a id="more"></a></p>
<h2 id="域名服务商的选择"><a href="#域名服务商的选择" class="headerlink" title="域名服务商的选择"></a>域名服务商的选择</h2><p>godaddy 口碑不错，推荐的人挺多，博主刚开始在上面选择好了域名，到了结算时，发现还有 WhoisGuard （涉及域名所有人的隐私）需要考虑，而 godaddy 一年的费用要70￥，博主又去选别的服务商了（学生党…）去知乎转了一圈发现 namecheap 口碑也不错，而且<a href="https://www.domcomp.com/?refcode=582684121300007f36f19420" target="_blank" rel="external">domcomp</a> 还有返利，于是就选择了它。</p>
<h2 id="域名申请步骤"><a href="#域名申请步骤" class="headerlink" title="域名申请步骤"></a>域名申请步骤</h2><p>首先去<a href="https://www.domcomp.com/?refcode=582684121300007f36f19420" target="_blank" rel="external">domcomp</a> </p>
<p><img src="http://ww4.sinaimg.cn/large/006y8lVajw1f9qb7umgf0j312i0ez77u.jpg" alt=""></p>
<p>在列表中选择 <em>Namecheap</em>，跳转到 Namecheap 主页，然后在搜索框中输入自己想要的域名（可不带后缀）</p>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f9qbayg3wbj312h0dhjz4.jpg" alt=""></p>
<p>点击 <em>Search</em>，可以看到各种不同后缀的域名搜索结果</p>
<p><img src="http://ww3.sinaimg.cn/large/006y8lVajw1f9qbctqr1fj30s80m3dio.jpg" alt=""></p>
<p>选择一个自己满意的，点击灰色的购物车图标即可添加到购物车（关于价格，博主购买一年期，价格就是黑色字体的价格），然后查看购物车</p>
<p><img src="http://ww4.sinaimg.cn/large/006y8lVajw1f9qbgdjgsqj31060fhwhn.jpg" alt=""></p>
<p>可以看到购买当前域名的价格（部分域名包含<a href="https://www.namecheap.com/legal/domains/icann-fee.aspx" target="_blank" rel="external">ICANN fee</a>），注意 Namecheap 送免费的 WhoisGuard ！好良心有木有！确认好了之后就可以点击右侧的 <em>Confirm Order</em> ，进入付款页面</p>
<p><img src="http://ww1.sinaimg.cn/large/006y8lVajw1f9qbk7xu54j31270icwgy.jpg" alt=""></p>
<p>付款方式选方便自己的（PayPal 支持银联袄！）</p>
<p>下方是账单地址，这个根据自己的情况填就可以，博主就不贴出来了</p>
<p><strong>注意</strong> 下方的续期选项，如果到期后不想续期就把下面的对勾<em>取消</em>掉</p>
<p><img src="http://ww1.sinaimg.cn/large/006y8lVajw1f9qbmqknxdj30sh0iftan.jpg" alt=""></p>
<p>确认信息无误，点击 <em>Continue</em>，进入付款页面。付款完成，等待 Namecheap 确认完成后即可进入控制台管理自己的域名。</p>
<h2 id="域名管理"><a href="#域名管理" class="headerlink" title="域名管理"></a>域名管理</h2><p><img src="http://ww3.sinaimg.cn/large/006y8lVajw1f9qbp55v72j311j0ejjtm.jpg" alt=""></p>
<p>点击 <em>MANAGE</em>，看看到如下界面</p>
<p><img src="http://ww3.sinaimg.cn/large/006y8lVajw1f9qbqqjtw9j312k0m20vs.jpg" alt=""></p>
<p>博主选择了国内的 DNSPod 免费域名解析服务，可以很方便得设置国内国外分别走不同线路，推荐您跟我一样进行设置。</p>
<p>在<em>NAMESERVERS</em>处选择<em>Custom DNS</em> ，然后填入以下两个 DNS： f1g1ns1.dnspod.net 和  f1g1ns2.dnspod.net 。填好后，点击该部分右上角的对勾保存设置。</p>
<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><h3 id="DNSPod-的设置"><a href="#DNSPod-的设置" class="headerlink" title="DNSPod 的设置"></a>DNSPod 的设置</h3><p>到 <a href="www.dnspod.cn">DNSPod</a> 注册并登录（可直接使用 QQ 账号登录），然后点击左侧的<em>域名解析</em>，再点击<em>添加域名</em></p>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f9qc5q9e7fj30z40ch0wg.jpg" alt=""></p>
<p>输入你注册的域名，点击确定后系统会自动扫描已有 DNS 记录</p>
<p><img src="http://ww4.sinaimg.cn/large/006y8lVajw1f9qc796ks5j30mg0by3zd.jpg" alt=""></p>
<p>点击<em>添加记录</em> </p>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f9qc9bhmeyj30m90a80u2.jpg" alt=""></p>
<p>鼠标每移动到每一项均有说明。</p>
<blockquote>
<p>如果只添加了 @ 的记录，那么别人就无法通过 www.yoursite.com 访问你的网站</p>
<p><em>记录值</em>为你要定向到的地址，比如我想别人在访问我的域名时获取我的 github pages 上的内容，所以<em>记录值</em> 处应该填 ChuanfengZhang.github.io.</p>
<p>同样也给 coding 添加记录</p>
</blockquote>
<p><strong>github pages 的<em>线路类型选国外</em>，这样国外的网友访问你的域名时会解析到 github，比 coding 速度更快</strong></p>
<p>设置好了以后我们需要分别到 github 和 coding 设置。</p>
<h3 id="github-的设置"><a href="#github-的设置" class="headerlink" title="github 的设置"></a>github 的设置</h3><p>进入到 github 上你的博客仓库，点击<em>Create new file</em> 在建立一个名为<strong>CNAME</strong>的文件（文件名大写），文件内容为你的域名。</p>
<h3 id="coding-的设置"><a href="#coding-的设置" class="headerlink" title="coding 的设置"></a>coding 的设置</h3><p>coding 设置相对来说简单些，只需在自定义域名输入框输入你的域名，点击添加即可</p>
<p><img src="http://ww4.sinaimg.cn/large/006y8lVajw1f9qcogtv88j30y30hm420.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们的域名申请和解析工作就完成了，访问你的域名看能不能显示出你的博客呢？</p>
<p><img src="http://ww1.sinaimg.cn/large/006y8lVajw1f9qcqub2kpj312q0k3n0x.jpg" alt=""></p>
<p>如果你在这个过程中遇到了什么问题或者有什么疑问，欢迎在评论中写出或通过其他方式联系我:-)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;域名申请与解析&quot;&gt;&lt;a href=&quot;#域名申请与解析&quot; class=&quot;headerlink&quot; title=&quot;域名申请与解析&quot;&gt;&lt;/a&gt;域名申请与解析&lt;/h1&gt;&lt;h2 id=&quot;初衷&quot;&gt;&lt;a href=&quot;#初衷&quot; class=&quot;headerlink&quot; title=&quot;初衷&quot;&gt;&lt;/a&gt;初衷&lt;/h2&gt;&lt;p&gt;个人博客的网址是 github.io 一类的网址未免普通（Bigger 不够），而博主想正好借这次机会体验一下购买域名的流程，所以就开始选服务商啦！&lt;br&gt;
    
    </summary>
    
    
      <category term="建站" scheme="http://zhangchuanfeng.me/tags/%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>将hexo博客同时托管到 github 和 coding</title>
    <link href="http://zhangchuanfeng.me/2016/11/12/%E5%B0%86hexo%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%97%B6%E6%89%98%E7%AE%A1%E5%88%B0%20github%20%E5%92%8C%20coding/"/>
    <id>http://zhangchuanfeng.me/2016/11/12/将hexo博客同时托管到 github 和 coding/</id>
    <published>2016-11-12T13:01:20.000Z</published>
    <updated>2016-11-13T09:43:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前我们把hexo托管在github，但是毕竟github是国外的，访问速度上还是有点慢，所以想也部署一套在国内的托管平台，国内目前比较好的就是 coding 了。接下来就看下怎样将hexo博客同时托管到 github 和 coding<br><a id="more"></a></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><hr>
<p>_config.yml 配置</p>
<hr>
<p>之前只部署到一个平台时，_config.yml 内容是这样的：  </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">deploy:</span></div><div class="line"><span class="attr">  type:</span> git</div><div class="line"><span class="attr">  repository:</span> git@github.com:ChuanfengZhang/ChuanfengZhang.github.io.git</div><div class="line"><span class="attr">  branch:</span> master</div></pre></td></tr></table></figure>
<p>如果我们想同时部署到两个平台，就需要将其改为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">deploy:</span></div><div class="line"><span class="attr">  type:</span> git</div><div class="line"><span class="attr">  repository:</span></div><div class="line"><span class="attr">    github:</span> git@github.com:ChuanfengZhang/ChuanfengZhang.github.io.git,master</div><div class="line"><span class="attr">    coding:</span> https://git.coding.net/chuanfengzhang/chuanfengzhang.git,master</div></pre></td></tr></table></figure>
<p><strong>注意：coding 仓库创建以及配置等内容与 github 类似，在此就不展开了</strong>  </p>
<p>将 hexo 部署到 coding 后，推荐使用 pages 方式，因为可以绑定域名。pages 方式也很简单，就是在 source/ 创建一个空白文件，至于原因，是因为 coding 需要这个文件来作为以静态文件部署的标志。就是说看到这个Staticfile就知道按照静态文件来发布。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd source/</div><div class="line">touch Staticfile  #名字必须是Staticfile</div></pre></td></tr></table></figure>
<p><img src="http://ww3.sinaimg.cn/large/006y8lVajw1f9pmwinfj1j313u0i3dkz.jpg" alt=""></p>
<p>然后开启 pages 服务即可</p>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f9pn4aa9scj313u0hsdkz.jpg" alt=""></p>
<p>点击页面提示的地址就可以访问了。</p>
<p>以后执行<code>hexo d -g</code>就可以同时部署到 github 和 conding 了，是不是很方便呢？</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<p><a href="http://www.jianshu.com/p/7ad9d3cd4d6e" target="_blank" rel="external">hexo干货系列：（四）将hexo博客同时托管到github和coding</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>这么一设置，以后就方便同时部署到两个平台了，为以后国内国外分别访问两个平台的 pages 打下了基础，下一篇文章是关于域名申请和解析的，敬请期待哦！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前我们把hexo托管在github，但是毕竟github是国外的，访问速度上还是有点慢，所以想也部署一套在国内的托管平台，国内目前比较好的就是 coding 了。接下来就看下怎样将hexo博客同时托管到 github 和 coding&lt;br&gt;
    
    </summary>
    
    
      <category term="建站" scheme="http://zhangchuanfeng.me/tags/%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>域名不加www无法访问?</title>
    <link href="http://zhangchuanfeng.me/2016/11/12/%E5%9F%9F%E5%90%8D%E4%B8%8D%E5%8A%A0www%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE?/"/>
    <id>http://zhangchuanfeng.me/2016/11/12/域名不加www无法访问?/</id>
    <published>2016-11-12T12:18:47.000Z</published>
    <updated>2016-11-12T12:52:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>问：我的网站<a href="www.zhangchuanfeng.me">www.zhangchuanfeng.me</a>，为何输www.zhangchuanfeng.me可以打开，而直接输入zhangchuanfeng.me打不开？</p>
<p>答：虚拟主机开通的时候默认只绑定www.abcd.com,所以abcd.com需要绑定后才能打开。<br>操作步骤：<br><a id="more"></a>  </p>
<ol>
<li><p>登录管理中心，点 业务管理&gt;域名服务，找到相关的域名，点 管理，然后点 dns解析管理,点　增加ip,</p>
<p>添加: A 记录<br>主机名:    填入 @<br>对应值:    填入你的虚拟主机ip (在　虚拟主机管理中心可以查到）<br>(注意： 这一步一般已经由我们的程序自动完成了，如果您发现在：dns解析管理中 有一个@记录，指向了你的ip,你就可以跳过这一步了）。   </p>
<p>​</p>
</li>
<li><p>点业务管理&gt;虚拟主机管理　</p>
<p>在域名绑定一栏　输入您想绑定的域名zhangchuanfeng.me,然后点添加就行了。</p>
</li>
</ol>
<p>这样，您就可以直接输入zhangchuanfeng.me打开你的网站了。</p>
<p>如果你想绑定其他的域名，其步骤也是一样的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问：我的网站&lt;a href=&quot;www.zhangchuanfeng.me&quot;&gt;www.zhangchuanfeng.me&lt;/a&gt;，为何输www.zhangchuanfeng.me可以打开，而直接输入zhangchuanfeng.me打不开？&lt;/p&gt;
&lt;p&gt;答：虚拟主机开通的时候默认只绑定www.abcd.com,所以abcd.com需要绑定后才能打开。&lt;br&gt;操作步骤：&lt;br&gt;
    
    </summary>
    
    
      <category term="建站" scheme="http://zhangchuanfeng.me/tags/%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>我的博客建好啦！</title>
    <link href="http://zhangchuanfeng.me/2016/11/10/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%BB%BA%E5%A5%BD%E5%95%A6%EF%BC%81/"/>
    <id>http://zhangchuanfeng.me/2016/11/10/我的博客建好啦！/</id>
    <published>2016-11-10T11:27:23.000Z</published>
    <updated>2016-11-11T03:26:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>跟着<a href="http://leopardpan.github.io" target="_blank" rel="external">潘柏信的博客</a>教程一步一步搭建起来的，比想象中简单。<br>下一步就换主题咯！<br>双11没有买买买，只有学学学！(^o^)/</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跟着&lt;a href=&quot;http://leopardpan.github.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;潘柏信的博客&lt;/a&gt;教程一步一步搭建起来的，比想象中简单。&lt;br&gt;下一步就换主题咯！&lt;br&gt;双11没有买买买，只有学学学！(^o^)
    
    </summary>
    
    
      <category term="随笔" scheme="http://zhangchuanfeng.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
