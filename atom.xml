<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张传峰的博客</title>
  <subtitle>一直在路上</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangchuanfeng.me/"/>
  <updated>2016-12-02T13:20:29.000Z</updated>
  <id>http://zhangchuanfeng.me/</id>
  
  <author>
    <name>张传峰</name>
    <email>wfhtzcf@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《图解 HTTP》读书笔记</title>
    <link href="http://zhangchuanfeng.me/2016/12/02/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://zhangchuanfeng.me/2016/12/02/《图解HTTP》读书笔记/</id>
    <published>2016-12-02T13:22:54.000Z</published>
    <updated>2016-12-02T13:20:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>HTTP（HyperText Transfer Protocol，超文转移协议，超文本传输协议的译法并不严谨。）</p>
<h3 id="网络基础-TCP-IP"><a href="#网络基础-TCP-IP" class="headerlink" title="网络基础 TCP/IP"></a>网络基础 TCP/IP</h3><h4 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP/IP 协议族"></a>TCP/IP 协议族</h4><p>TCP/IP 协议族是互联网相关联的协议的集合。从电缆的规格到IP地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及Web页面显示需要处理的步骤，等等。而HTTP是属于它内部的一个子集。</p>
<h4 id="TCP-IP-的分层管理"><a href="#TCP-IP-的分层管理" class="headerlink" title="TCP/IP 的分层管理"></a>TCP/IP 的分层管理</h4><p>TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。<br>分层的好处：把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。而且，层次化之后，设计也变得相对简单。处于应用层上的应用可以只考虑分派给自己的任务，而无需弄清对方在地球上哪个地方、对方的传输路线、是否能确保传输送达等问题。</p>
<ul>
<li>应用层：决定了向用户提供应用服务时通信的活动。<br>TCP/IP 协议族预存了各类通用的应用服务。如 FTP（File Transfer Protocol）、DNS（Domain Name System）和 HTTP。</li>
<li>传输层：该层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。TCP（Transmission Control Protocol）和 UDP（User Data Protocol，用户数据报协议）。</li>
<li>网络层：网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎么样的路径到达对方计算机，并把数据包传送给对方。</li>
<li>链路层：用来处理网络的硬件部分。</li>
</ul>
<h4 id="TCP-IP-通信传输流"><a href="#TCP-IP-通信传输流" class="headerlink" title="TCP/IP 通信传输流"></a>TCP/IP 通信传输流</h4><p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-9.jpg" alt="缺一张照片P9"></p>
<p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。</p>
<p>用HTTP 举例来说：首先作为发送端的客户端在应用层（HTTP协议）发出一个HTTP请求。<br>接着，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分隔，并在各个报文上打上标记序号及端口号后转发给网络层。<br>在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这就让发往网络的通信请求准备齐全了。<br>接收端的服务器在链路层接收到数据后，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到客户端发送过来的HTTP请求。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-10.jpg" alt="&gt; 缺一张照片P10"></p>
<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。<br>把数据信息包装起来的做法称为封装。</p>
<h3 id="与HTTP关系密切的协议：IP、TCP和DNS"><a href="#与HTTP关系密切的协议：IP、TCP和DNS" class="headerlink" title="与HTTP关系密切的协议：IP、TCP和DNS"></a>与HTTP关系密切的协议：IP、TCP和DNS</h3><h4 id="负责传输的-IP-协议"><a href="#负责传输的-IP-协议" class="headerlink" title="负责传输的 IP 协议"></a>负责传输的 IP 协议</h4><p>IP（网际协议）位于网络层。该协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中最重要的两个条件是 IP 地址和 MAC地址。<br>IP 地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。</p>
<p><strong>使用ARP协议凭借MAC地址进行通信</strong><br>IP间通信通信依赖MAC地址。通信的双方通常会经过多台计算机和网络设备中转才能连接到对方，而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会采用ARP协议。该协议是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-12.jpg" alt="此处输入图片的描述"></p>
<h4 id="确保可靠性的TCP协议"><a href="#确保可靠性的TCP协议" class="headerlink" title="确保可靠性的TCP协议"></a>确保可靠性的TCP协议</h4><p>TCP属于传输层，提供可靠的字节流服务。<br>字节流服务是指：为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。<br>这就是为什么下载高清大图时，图片会一块一块地加载。</p>
<p><strong>三次握手</strong><br>为了准确无误地将数据送达目标处，TCP协议在发送数据的准备阶段采用了三次握手策略（若在握手过程中某个阶段中断，TCP协议会再次以相同的顺序发送相同的数据包）。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-13.jpg" alt="&gt; 缺图片P13"></p>
<p>当然，除了三次握手，TCP还有其它各种手段确保通信的可靠性。</p>
<h3 id="负责域名解析的-DNS-服务"><a href="#负责域名解析的-DNS-服务" class="headerlink" title="负责域名解析的 DNS 服务"></a>负责域名解析的 DNS 服务</h3><p>DNS服务提供域名到IP 地址之间的解析服务。<br>即可通过域名查找IP，或逆向从IP地址反查域名服务。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-14.jpg" alt="此处输入图片的描述"></p>
<p>因为域名解析也需要时间，所以可以 <a href="http://fanyi.jobbole.com/14191/" target="_blank" rel="external">提前获取DNS来提升网页加载速度</a>。</p>
<h3 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h3><p>URI（uniform Resource Identifier）<br>Uniform：规定统一的格式可方便处理多种不同类型的资源。<br>Resource：可标识的任何东西<br>Identifier：标识符</p>
<p>URI就是某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称，如http、ftp。</p>
<p>URI 用字符串标识某一个互联网资源，而URL表示资源的地点。URL是URI的子集。</p>
<p>表示指定的URI，要使用涵盖全部必要信息的绝对URI、绝对URL以及相对URL。相对URL是指从浏览器中基本URI处指定的URL，如 <code>/image/logo.gif</code>。</p>
<p>绝对URI的格式如下：</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-18.jpg" alt="图片P18"></p>
<h2 id="第二章-简单的HTTP协议"><a href="#第二章-简单的HTTP协议" class="headerlink" title="第二章 简单的HTTP协议"></a>第二章 简单的HTTP协议</h2><p>HTTP协议规定，先从客户端开始建立通信，服务端在没有接收到请求之前不会发送响应。</p>
<p>请求报文由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。</p>
<p> <img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-24.jpg" alt="&gt; 图片P24"></p>
<p> 响应报文基本上由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-25.jpg" alt="&gt; 图片P25"></p>
<h3 id="HTTP是不保存状态的协议"><a href="#HTTP是不保存状态的协议" class="headerlink" title="HTTP是不保存状态的协议"></a>HTTP是不保存状态的协议</h3><p>HTTP是无状态协议。自身不对请求和响应之间通信状态进行保存（即不做持久化处理）。<br>HTTP之所以设计得如此简单，是为了更快地处理大量事物，确保协议的可伸缩性。<br>HTTP/1.1 随时无状态协议，但可通过 Cookie 技术保存状态。</p>
<h3 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h3><ul>
<li>GET：获取资源</li>
<li>POST：传输实体主体</li>
<li>PUT：传输文件</li>
<li>HEAD：获得报文首部，与GET方法一样，只是不返回报文主体内容。用于确认URI的有效性及资源更新的日期时间等。</li>
<li>DELETE：删除文件，与PUT相反（响应返回204 No Content）。</li>
<li>OPTIONS：询问支持的方法，查询针对请求URI指定的资源支持的方法（Allow:GET、POST、HEAD、OPTIONS）。</li>
<li>TRACE：追踪路径</li>
<li>CONNECT：要求用隧道协议连接代理（主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输）。</li>
</ul>
<p>向请求URI指定的资源发送请求报文时，采用称为方法的命令。方法名区分大小写，主要要用大写字母。</p>
<h3 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="headerlink" title="持久连接节省通信量"></a>持久连接节省通信量</h3><h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><p>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-34.jpg" alt="此处输入图片的描述"></p>
<p>发送请求一份包含多张图片的HTML文档对应的Web页面，会产生大量通信开销。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-35.jpg" alt="此处输入图片的描述"><br>为了解决上述TCP连接的问题，HTTP/1.1和一部分的HTTP/1.0想出了持久连接（HTTP Persistent Connections，也称为HTTP keep-alive 或 HTTP Connection resue）的方法。<br><strong>持久连接的特点</strong>是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-36.jpg" alt="TCP持久连接"></p>
<p>持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP请求和响应能够更早地结束，这样Web页面的显示速度也相应提高了。</p>
<p>在HTTP/1.1中，所有连接默认都是持久连接，但在HTTP/1.0内并未标准化。<br>毫无疑问，除了服务器端，客户端也需要支持持久连接。</p>
<h4 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h4><p>持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求（并行发送多个请求）。</p>
<p>注意：尽管HTTP管线化可以克服同域并行请求限制带来的阻塞， 但HTTP/1.x 有严格的串行返回响应机制，服务器通过 TCP 连接返回响应时，就是必须 按照客户端的请求顺序进行响应 ，前一个响应没有完成，下一个响应就不能返回。所以使用“ HTTP 管道”技术时，万一第一个响应时间很长，那么后面的响应处理完了也无法发送，只能被缓存起来，占用服务器内存，这就是传说中的“队首阻塞”。</p>
<blockquote>
<p>每个浏览器支持的请求并发数不同，但可在页面中使用多个域名加大并发量（因为浏览器是基于domain的并发控制，而不是page），不过过多的散布会导致DNS解析上付出额外的代价。</p>
</blockquote>
<h3 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h3><p>Cookie技术通过在请求和响应报文中写入cookie信息来控制客户端的状态。<br>Cookie会根据从服务器端发送的响应报文内的一个叫做 <code>Set-Cookie</code> 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。</p>
<p>如果您在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击。</p>
<blockquote>
<p>Cookie-free Domains：用户在请求静态资源时，也会发送cookie信息。对于一个拥有多个静态资源的网站，这无疑会产生不必要的流量。因此我们可以启用与主站不同的域名（包括子域名）来放置静态资源。</p>
</blockquote>
<h2 id="第三章-HTTP报文内的HTTP信息"><a href="#第三章-HTTP报文内的HTTP信息" class="headerlink" title="第三章 HTTP报文内的HTTP信息"></a>第三章 HTTP报文内的HTTP信息</h2><p>用于HTTP协议交互的信息被称为HTTP报文。请求端的HTTP报文叫做请求报文，响应端的叫做响应报文。HTTP报文本身是由多行（用CR+LF做换行符）数据构成的字符串文本。</p>
<p>HTTP报文大致可分为报文首部和报文主体两部块。两者由最初出现的空行（CR+LF、回车符+换行符）来划分。通常，并不一定要有报文主体。</p>
<h3 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h3><p>HTTP在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率，但这会消耗更多的CPU等资源。</p>
<h4 id="报文主体和实体主体的差异"><a href="#报文主体和实体主体的差异" class="headerlink" title="报文主体和实体主体的差异"></a>报文主体和实体主体的差异</h4><p>报文：是HTTP通信中的基本单位，由8位组字节流组成，通过HTTP通信传输。<br>实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。</p>
<p>HTTP报文的主体用于传输请求或响应的实体主体。<br>通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p>
<h4 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a>压缩传输的内容编码</h4><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。<br>常见的内容编码有：gzip（GNU zip）、compress（UNIX系统的标准压缩）、deflate（zlib）、identity（不进行编码）</p>
<h4 id="分隔发送的分块传输编码"><a href="#分隔发送的分块传输编码" class="headerlink" title="分隔发送的分块传输编码"></a>分隔发送的分块传输编码</h4><p>在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。<br>这种把实体主体分块的功能称为<strong>分块传输编码</strong>（Chunked Transfer Coding）。</p>
<p>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0（CR+LF）”来标记。</p>
<p>使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。</p>
<h3 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h3><p>HTTP协议中采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常实在图片或文本文件等上传时使用。</p>
<h3 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h3><p>下载大尺寸的图片的过程中，如果网络中断，则需要重新下载。因此需要一种可恢复的机制。<br>实现该功能需要指定下载的实体范围，像这样，指定范围发送的请求叫做<strong>范围请求</strong>。<br>执行范围请求时，会用到首部字段Range来指定资源的byte范围。响应会返回状态码206 Partial Content。</p>
<p>如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。</p>
<h3 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="headerlink" title="内容协商返回最合适的内容"></a>内容协商返回最合适的内容</h3><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。</p>
<h2 id="返回结果的HTTP状态码"><a href="#返回结果的HTTP状态码" class="headerlink" title="返回结果的HTTP状态码"></a>返回结果的HTTP状态码</h2><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。<br>状态码如200 OK，以3为数字和原因短语组成。<br>数字中的第一位定义了响应类别，后两位无分类。响应类别有以下五种：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">类别</th>
<th style="text-align:center">原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1XX</td>
<td style="text-align:center">Informational(信息性状态码)</td>
<td style="text-align:center">接收的请求正在处理</td>
</tr>
<tr>
<td style="text-align:center">2XX</td>
<td style="text-align:center">Success（成功状态码）</td>
<td style="text-align:center">请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:center">3XX</td>
<td style="text-align:center">Redirection（重定向状态码）</td>
<td style="text-align:center">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:center">4XX</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:center">5XX</td>
<td style="text-align:center">Server Error（服务器错误状态码）</td>
<td style="text-align:center">服务器处理请求出错</td>
</tr>
</tbody>
</table>
<p>只要遵守状态码类别的定义，即使改变 <a href="https://datatracker.ietf.org/doc/rfc2616/" target="_blank" rel="external">RFC2616</a> 中定义的状态码，或服务器端自行创建状态码都没问题。</p>
<h3 id="常用的状态码14种："><a href="#常用的状态码14种：" class="headerlink" title="常用的状态码14种："></a>常用的状态码14种：</h3><h4 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h4><ul>
<li>200 OK：请求被正常处理</li>
<li>204 No Content：一般在只需从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</li>
<li>206 Partial Content：客户端进行范围请求</li>
</ul>
<h4 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h4><ul>
<li>301 Moved Permanently：永久重定向。表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。<br>也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存。</li>
<li>302 Found：临时性重定向。表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。<br>和301 Moved Permanently状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。比如，用户把URI保存成书签，但不会像301状态码出现时那样去更新书签，而是仍旧保留返回302状态码的页面对应的URI（在Chrome中，还是会保存为重定向后的URI，不解）。</li>
<li>303 See Other：表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。这与302类似，但303明确表示客户端应当采用GET方法获取资源。</li>
<li>304 Not Modified：该状态码表示客户端发送附带条件的请求（指采用GET方法的请求报文中包含If-Match,If-Modified-Since，If-None-March，If-Range，If-Unmodified-Since中任一首部。）时，服务器端允许请求访问资源，但因发生请求为满足条件的情况后，直接返回304（服务器端资源未改变，可直接使用客户端未过期的缓存）。304状态码返回时，不包含任何响应的主体部分。<br>304虽被划分在3XX类别，但是和重定向没有关系。</li>
<li>307 Temporary Redirect：临时重定向。与302有相同含义。307遵守浏览器标准，不会从POST变成GET。</li>
</ul>
<blockquote>
<p>就算是304，也需要发出请求与接收响应，也会耗费资源和时间。</p>
</blockquote>
<h4 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h4><p>4XX的响应结果表明客户端是发生错误的原因所在。</p>
<ul>
<li>400 Bad Request：表示请求报文中存在语法错误。</li>
<li>401 Unauthorized：表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。</li>
<li>403 Forbidden：表明对请求资源的访问被服务器拒绝了。服务器端可在实体的主体部分对原因进行描述（可选）</li>
<li>404 Not Found：表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时时用。</li>
</ul>
<h4 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h4><p>5XX的响应结果表明服务器本身发生错误。</p>
<ul>
<li>500 Interval Server Error：表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。</li>
<li>503 Service Unavailable：表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。</li>
</ul>
<h2 id="第五章-与HTTP协作的Web服务器"><a href="#第五章-与HTTP协作的Web服务器" class="headerlink" title="第五章 与HTTP协作的Web服务器"></a>第五章 与HTTP协作的Web服务器</h2><h3 id="用单台虚拟主机实现多个域名"><a href="#用单台虚拟主机实现多个域名" class="headerlink" title="用单台虚拟主机实现多个域名"></a>用单台虚拟主机实现多个域名</h3><p>HTTP/1.1 规范允许一台HTTP服务器搭建多个Web站点。这是利用虚拟主机（Virtual Host，又称虚拟服务器）的功能。</p>
<p>在互联网上，域名通过DNS服务映射到IP地址之后访问目标网站。可见，当请求发送到服务器时，已经是以IP地址形式访问了。所以，当一台托管了两个域名的服务器接收到请求时就需要弄清楚究竟要访问哪个域名。<br>在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI。</p>
<h3 id="通信数据转发程序：代理、网关、隧道"><a href="#通信数据转发程序：代理、网关、隧道" class="headerlink" title="通信数据转发程序：代理、网关、隧道"></a>通信数据转发程序：代理、网关、隧道</h3><p>HTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关、隧道。它们可以配合服务器工作。</p>
<ul>
<li>代理：是一种有转发功能的应用程序，扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。</li>
<li>网关：是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。</li>
<li>隧道：是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。</li>
</ul>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>代理不改变请求URI，会直接发送给前方持有资源的目标服务器。<br>持有资源实体的服务器被称为源服务器。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-68.jpg" alt="&gt; P68"><br>例如：<br><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-%E4%BB%A3%E7%90%86.png" alt="&gt; 淘宝的via"></p>
<p>每次通过代理服务器转发请求或响应式，会追加写入via首部信息。</p>
<p>使用代理服务器的理由有：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。</p>
<p>代理有多种使用方法，按两种基准分类。一种是是否是否使用缓存，另一种是是否会修改报文。</p>
<ul>
<li>代理缓存：代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。</li>
<li>透明代理：转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。</li>
</ul>
<h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p>网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供<strong>非HTTP协议服务</strong>。<br>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL语句查询数据。另外，在Web购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。</p>
<h4 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h4><p>隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端与服务器进行安全的通信。</p>
<p>隧道本身不会去解析HTTP请求。请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</p>
<h3 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h3><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，节省通信流量和时间。</p>
<p>缓存服务器是代理服务器的一种。当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。</p>
<p>缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了。</p>
<h4 id="缓存的有效期限"><a href="#缓存的有效期限" class="headerlink" title="缓存的有效期限"></a>缓存的有效期限</h4><p>对于缓存服务器和客户端浏览器，当判定缓存过期或客户端要求，会向源服务器确认资源的有效性。若失效，浏览器会再次请求新资源。</p>
<h2 id="第六章-HTTP首部"><a href="#第六章-HTTP首部" class="headerlink" title="第六章 HTTP首部"></a>第六章 HTTP首部</h2><p>HTTP协议的请求和响应报文中必定包含HTTP首部。首部内容为客户端和服务器端分别处理请求和响应提供所需要的信息。</p>
<p>HTTP请求报文：由方法、URI、HTTP版本、HTTP首部字段等构成。<br>HTTP响应报文：由HTTP版本、状态码（数字和原因短语）、HTTP首部字段 3 部分组成。</p>
<h3 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h3><p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p>
<h4 id="4种HTTP首部字段类型"><a href="#4种HTTP首部字段类型" class="headerlink" title="4种HTTP首部字段类型"></a>4种HTTP首部字段类型</h4><p>HTTP首部字段根据实际通途被分为以下4种类型：</p>
<ul>
<li>通用首部字段（General Header Fileds）：请求报文和响应报文两方都会使用的首部</li>
<li>请求首都字段（Request Header Fields）：从客服端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li>
<li>响应首部字段（Response Header Fields）：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</li>
<li>实体首部字段（Entity Header Fields）：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</li>
</ul>
<h4 id="HTTP-1-1首部字段一览"><a href="#HTTP-1-1首部字段一览" class="headerlink" title="HTTP/1.1首部字段一览"></a>HTTP/1.1首部字段一览</h4><p>通用首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cache-Control</td>
<td>控制缓存行为</td>
</tr>
<tr>
<td>Connection</td>
<td>逐跳首部、连接的管理</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的日期时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Trailer</td>
<td>报文末端的首部一览</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>指定报文主体的传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody>
</table>
<p>Cache-Control的no-cache指令代表不缓存过期的资源，而不是不缓存。no-store才是真正不进行缓存。<br>Connection首部字段的值为close时，代表服务器想明确断开连接（HTTP/1.1默认都是持久连接）</p>
<p>请求首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言</td>
</tr>
<tr>
<td>Authorization</td>
<td>Web认证信息</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务器的行为</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记（ETag）</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-Node-Match</td>
<td>比较实体标记（与If-Match相反）</td>
</tr>
<tr>
<td>If-Range</td>
<td>资源未更新时发送实体Byte的范围请求</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>比较资源的更新时间（与If-Modified-Since相反）</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节范围请求</td>
</tr>
<tr>
<td>Referer</td>
<td>对请求中URI的原始获取方</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码的优先级</td>
</tr>
<tr>
<td>User-Agent</td>
<td>HTTP客户端程序的信息</td>
</tr>
</tbody>
</table>
<p>该表的Accept*字段都可以指定权重q（0-1）。当服务器提供多种内容时，将会首先返回权重最高的。<br>If-xxx请求首部字段都称为条件请求，服务器接收到附带条件的请求后，只有判断指定条件为真时，才回执行请求。<br>Referer 的正确拼写应该是Referrer。当直接在浏览器的地址栏输入URI时，或处于安全考虑时，可不发该首部字段。</p>
<p>响应首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Ranges</td>
<td>是否接受字节范围请求</td>
</tr>
<tr>
<td>Age</td>
<td>推算资源创建经过时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>令客户端重定向至指定URI</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发起请求的时机要求</td>
</tr>
<tr>
<td>Server</td>
<td>HTTP服务器的安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
</tr>
</tbody>
</table>
<p>几乎所有浏览器在接收到包含首部字段Location的响应后，都会强制性地尝试对已提示的重定向资源的访问。</p>
<p>实体首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Allow</td>
<td>资源可支持的HTTP方法</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体主体适用的编码方式</td>
</tr>
<tr>
<td>Content-Language</td>
<td>实体主体的自然语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体主体的大小（字节）</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代对应资源的URI</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>实体主体的报文摘要</td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体的位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td>实体主体的媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td>实体主体过期的日期时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源的最后修改日期时间</td>
</tr>
</tbody>
</table>
<p>为Cookie服务的首部字段</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
<th>首部类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set-Cookie</td>
<td>开始状态管理所使用的Cookie信息</td>
<td>响应首部字段</td>
</tr>
<tr>
<td>Cookie</td>
<td>服务器接收到的Cookie信息</td>
<td>请求首部字段</td>
</tr>
</tbody>
</table>
<p>Set-Cookie字段的属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NAME=VALUE</td>
<td>赋予Cookie的名称和其值（必需项）</td>
</tr>
<tr>
<td>expires=DATE</td>
<td>Cookie的有效期（若不明确指定则默认为浏览器关闭前为止）</td>
</tr>
<tr>
<td>path=Path</td>
<td>将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）</td>
</tr>
<tr>
<td>domain=域名</td>
<td>作为Cookie适用对象的域名（若不指定则默认为创建Cookie的服务器的域名）</td>
</tr>
<tr>
<td>Secure</td>
<td>仅在HTTPS安全通信时才会发送Cookie</td>
</tr>
<tr>
<td>HttpOnly</td>
<td>加以限制，使Cookie不能被JavaSript脚本访问</td>
</tr>
</tbody>
</table>
<p>expires：一旦Cookie从服务器端发送至客户端，服务器端就不存在可以显示删除Cookie的方法。但可通过覆盖已过期的Cookie，实现对客户端Cookie的实质性删除操作。<br>path：用来指定cookie被发送到服务器的哪一个目录路径下（即被服务器哪个路径接收cookie），其中”/“指的是站点根目录，可在同一台服务器（即使有多个应用）内共享该cookie。</p>
<h2 id="第七章-确保Web安全的HTTPS"><a href="#第七章-确保Web安全的HTTPS" class="headerlink" title="第七章 确保Web安全的HTTPS"></a>第七章 确保Web安全的HTTPS</h2><h3 id="HTTP的确定"><a href="#HTTP的确定" class="headerlink" title="HTTP的确定"></a>HTTP的确定</h3><ul>
<li>通信使用明文可能会被窃听</li>
<li>不验证通信方的身份就可能遭受伪装</li>
<li>无法验证报文完整性，可能已遭篡改</li>
</ul>
<h3 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP+加密+认证+完整性保护 = HTTPS"></a>HTTP+加密+认证+完整性保护 = HTTPS</h3><h2 id="第八章-确认访问用户身份的认证"><a href="#第八章-确认访问用户身份的认证" class="headerlink" title="第八章 确认访问用户身份的认证"></a>第八章 确认访问用户身份的认证</h2><p>核对的信息通常是指以下这些：</p>
<ul>
<li>密码：只有本人才会知道的字符串信息</li>
<li>动态令牌：仅限本人持有的设备内显示的一次性密码</li>
<li>数字证书：仅限本人（终端）持有的信息</li>
<li>生物认证：指纹和虹膜等本人的生理信息</li>
<li>IC卡等：仅限本人持有的信息</li>
</ul>
<p>HTTP/1.1 使用的认证方式如下所示：</p>
<ul>
<li>BASIC认证（基本认证）</li>
<li>DIGEST 认证（摘要认证）w</li>
<li>SSL 客户端认证</li>
<li>FormBase认证（基于表单认证）</li>
</ul>
<h2 id="第九章-基于HTTP的功能追加协议"><a href="#第九章-基于HTTP的功能追加协议" class="headerlink" title="第九章 基于HTTP的功能追加协议"></a>第九章 基于HTTP的功能追加协议</h2><h3 id="HTTP的瓶颈"><a href="#HTTP的瓶颈" class="headerlink" title="HTTP的瓶颈"></a>HTTP的瓶颈</h3><p>使用HTTP协议探知服务器上是否有内容更新，就必须频繁地从客户端到服务器端进行确认。如果服务器上没有内容更新，那么就会产生徒劳的通信。<br>若想在现有Web实现所需的功能，一下这些HTTP标准就会成为瓶颈：</p>
<ul>
<li>一条连接上只可发送一个请求（前面讲到，持久化可保持TCP连接状态，但仍完成一次请求/响应后才能进行下一次请求/响应，而管线化方式可让一个TCP连接并行发送多个请求。）</li>
<li>请求只能从客户端开始。客户端不可以接收除响应以外的指令</li>
<li>请求/响应首部未经压缩就发送。首部信息越多延迟越大</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多</li>
<li>可任意选择数据压缩格式。非强制压缩发送</li>
</ul>
<h4 id="Comet-的解决方法"><a href="#Comet-的解决方法" class="headerlink" title="Comet 的解决方法"></a>Comet 的解决方法</h4><p>通常，服务器接收到请求，在处理完毕后就立即返回响应，但为了实现推送功能，Comet会先将响应置于<strong>挂起状态</strong>，当服务器端有内容更新时，再返回该响应。<br>内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。另外，Comet仍未解决HTTP协议的本身存在的问题。</p>
<h4 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h4><p>Google 在2010年发布了 SPDY，其开发目标旨在解决HTTP的性能瓶颈，缩短Web页面的加载时间。<br>SPDY没有完全改写HTTP协议，而是在TCP/IP的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY规定通信中使用SSL。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-184.jpg" alt="&gt; P184"></p>
<p>SPDY以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接。因此，可照常使用HTTP的GET和POST等方法、Cookie以及HTTP报文等。</p>
<p>使用 SPDY后，HTTP协议额外获得以下功能。</p>
<ul>
<li>多路复用流：通过单一的TCP连接，可以无限制处理多个HTTP请求。所有请求的处理都在一条TCP连接上完成，因此TCP的处理效率得到提高。</li>
<li>赋予请求优先级：SPDY不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。</li>
<li>压缩HTTP首部：压缩HTTP请求和响应的首部。</li>
<li>推送功能：支持服务器主动向客户端推送数据的功能。</li>
<li>服务器提示功能：服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。</li>
</ul>
<h3 id="使用浏览器进行全双工通信的-WebSocket"><a href="#使用浏览器进行全双工通信的-WebSocket" class="headerlink" title="使用浏览器进行全双工通信的 WebSocket"></a>使用浏览器进行全双工通信的 WebSocket</h3><p>利用Ajax和Comet技术进行通信可以提升Web的浏览速度。但问题在于通信若使用HTTP协议，就无法彻底解决瓶颈问题。</p>
<p>WebSocket技术主要是为了解决Ajax和Comet里XMLHttpRequst附带的缺陷所引起的问题。</p>
<p>一旦Web服务器与客户端之间建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML或图片等任意格式的数据。</p>
<p>WebSocket的主要特点：</p>
<ul>
<li>推送功能：支持由服务器向客户端推送数据。</li>
<li>减少通信量：和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应较少。</li>
</ul>
<p>为了实现WebSocket通信，在HTTP连接建立之后，需要完成一次“握手”的步骤。</p>
<ul>
<li>握手·请求：为了实现WebSocket通信，需要用到HTTP的Upgrade首部字段，告知服务器通信协议发生改变，以达到握手的目的。</li>
<li>握手·响应：对于之前的请求，返回状态码101 Switching Protocols 的响应。</li>
</ul>
<p>成功握手确立WebSocket连接后，通信时不再使用HTTP的数据帧，而采用WebSocket独立的数据帧。</p>
<p><strong>由于是建立在HTTP基础上的协议，因此连接的发起方仍是客户端</strong>，而一旦确立WebSocket通信连接，不论服务器端还是客户端，任意一方都可直接向对方发送报文。</p>
<h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h2><p><a href="https://github.com/fex-team/http2-spec/blob/master/HTTP2%E4%B8%AD%E8%8B%B1%E5%AF%B9%E7%85%A7%E7%89%88%2806-29%29.md" target="_blank" rel="external">HTTP2中英对照版</a><br><a href="https://www.zhihu.com/question/34074946" target="_blank" rel="external">HTTP/2.0 相比1.0有哪些重大改进？</a></p>
<h2 id="第十一章-Web攻击技术"><a href="#第十一章-Web攻击技术" class="headerlink" title="第十一章 Web攻击技术"></a>第十一章 Web攻击技术</h2><p>简单的HTTP协议本身并不存在安全性问题，因此协议本身几乎不会成为攻击的对象。应用HTTP协议的服务器和客户端，以及运行在服务器上的Web应用等资源才是攻击目标。</p>
<p>HTTP不具备必要的安全功能，就拿远程登录时会用到的SSH协议来说，SSH具备协议级别的认证及会话管理等功能，HTTP协议则没有。另外在架设SSH服务方面，任何人都可以轻易地创建安全等级高的服务。而HTTP即使已假设好服务器，但开发者需要自行设计并开发认证及会话管理功能来满足Web应用的安全。而自行设计就意味着会出现各种形形色色的实现，可仍在运作的Web应用背后就会隐藏着各种容易被攻击者滥用的安全漏洞的Bug。</p>
<h3 id="因输出值转义不完全引发的安全漏洞"><a href="#因输出值转义不完全引发的安全漏洞" class="headerlink" title="因输出值转义不完全引发的安全漏洞"></a>因输出值转义不完全引发的安全漏洞</h3><ul>
<li>跨站脚本攻击（Cross-Site Scripting, XSS）：主要是指在用户浏览器内运行了非法的 HTML 标签或 JavaScript 脚本。比如富文本编辑器，如果不过滤用户输入的数据直接显示用户输入的HTML内容的话，就会有可能运行恶意的 JavaScript 脚本，导致页面结构错乱，Cookies 信息被窃取等问题。</li>
<li>SQL注入攻击（SQL Injection）：是指针对 Web 应用使用的数据库，通过运行非法的SQL而产生的攻击。</li>
<li>OS命令攻击（OS Command Injection）：是指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。 只要在能调用 Shell 函数的地方就有存在被攻击的风险。</li>
<li>HTTP首部注入攻击（HTTP Header Injection）：是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。</li>
<li>HTTP 响应截断攻击：是用在 HTTP 首部注入的一种攻击。攻击顺序相同，但是要将两个 %0D%0A%0D%0A 并排插入字符串后 发送。利用两个连续的换行就可作出 HTTP 首部与主体分隔所需的空行了，这样 就能显示伪造的主体，达到攻击的目的。</li>
<li>邮件首部注入攻击（Mail Header Injection）：是指 Web 应用中的邮件发送功能，攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击。利用存在安全漏洞的Web网站，可对任意邮件地址发送广告邮件或 病毒邮件。</li>
<li>目录遍历攻击（Directory Traversal）：是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。比如，通过 ../ 等相对路径定位到 /etc/passwd 等绝对路径上。</li>
<li>远程文件包含漏洞（Remote File Inclusion）： 是指当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的URL充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。</li>
</ul>
<h3 id="因设置或设计上的缺陷引发的安全漏洞"><a href="#因设置或设计上的缺陷引发的安全漏洞" class="headerlink" title="因设置或设计上的缺陷引发的安全漏洞"></a>因设置或设计上的缺陷引发的安全漏洞</h3><ul>
<li>强制浏览（Forced Browsing）：是指，从安置在Web服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件。比如，没有对那些需要保护的静态资源增加权限控制。</li>
<li>不正确的错误消息处理（Error Handling Vulerability）：指Web应用的错误信息内包含对攻击者有用 的信息。</li>
<li>开放重定向（Open Redirect）：是一种对指定的任意URL作重定向跳转的功能。而于此功能相关联的安全漏洞是指， 假如指定的重定向 URL 到某个具有恶意的 Web 网站，那么用户就会被诱导至那个 Web 网站。</li>
</ul>
<h3 id="因会话管理疏忽引发的安全漏洞"><a href="#因会话管理疏忽引发的安全漏洞" class="headerlink" title="因会话管理疏忽引发的安全漏洞"></a>因会话管理疏忽引发的安全漏洞</h3><ul>
<li>会话劫持（Session Hijiack）：是指攻击者通过某种手段拿到了用户的会话 ID，并非法使用此会话 ID 伪装成用户，达到攻击的目的。</li>
<li>会话固定攻击（Session Fixation）：对以窃取目标会话ID为主动攻击手段的会话劫持而言，会强制用户使用攻击者指定的会话 ID，属于被动攻击。</li>
<li>跨站点请求伪造（Cross-Site Request Forgeries, CSRF）：是指攻击者通过设置好陷阱，强制对已完成认证的用户进行非预期的个人信息或设定等某些状态更新，属于被动攻击。</li>
</ul>
<h3 id="其它安全漏洞"><a href="#其它安全漏洞" class="headerlink" title="其它安全漏洞"></a>其它安全漏洞</h3><ul>
<li>密码破解：①通过网络进行密码试错（穷举法和字典攻击）；②对已加密密码的破解（通过穷举法·字典攻击进行类推、彩虹表、拿到加密时使用的密钥、加密算法的漏洞）</li>
<li>点击劫持：是指利用透明的按钮或链接做成陷阱，覆盖在Web页面之上。然后诱使用户在不知情的情况下， 单击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装（UI Redressing）。</li>
<li>Dos攻击：是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。多台计算机发起的 Dos 攻击称为 DDoS 攻击（Distributed Denial of Service attach） 。</li>
<li>后门程序：是指开发设置的隐藏入口（如开发阶段作为Debug调用的后门程序），可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限的功能。</li>
</ul>
<h2 id="自问自答："><a href="#自问自答：" class="headerlink" title="自问自答："></a>自问自答：</h2><ol>
<li>URI与URL的区别<br>答：URI 用字符串（包括地址）标识某一个互联网资源，而URL表示资源的地点。因此URL是URI的子集。</li>
<li>输入URL后，浏览器发生哪些变化<br>下图需要补充：在从DNS服务器获取IP后，进行3次握手。<br><img src="http://7xq7nb.com1.z0.glb.clouddn.com/graphical-http-15.jpg" alt="P15 + 三次握手"><br>从服务器获取相应资源后，浏览器就会对这些资源进行相应的解析，具体可看<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model" target="_blank" rel="external">Google Developers</a>。</li>
<li>GET与POST的区别<br>可以看看这篇文章 <a href="http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="external">浅谈HTTP中Get与Post的区别</a>。我个人认为主要的一点是：<strong>URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。</strong><br>关于URL和queryString长度限制的相关链接：<ul>
<li><a href="http://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers/417184" target="_blank" rel="external">What is the maximum length of a URL in different browsers?</a></li>
<li><a href="http://stackoverflow.com/questions/812925/what-is-the-maximum-possible-length-of-a-query-string" target="_blank" rel="external">What is the maximum possible length of a query string?</a><br>因此对于GET请求时，URL超出浏览器或者服务器限制的情况，建议改成POST请求。</li>
</ul>
</li>
<li>301与302区别<br>答：301是永久性重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。<br>302是临时性重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</li>
<li>为什么三次握手，二次不可以吗？<br>答：不可以，只有完成3次才能进行后续操作，若在握手过程中某个阶段中断，TCP协议会再次以相同的顺序发送相同的数据包。而且，第三次握手是客户端为了让服务器知道它是否接收到响应，确保连接建立成功。</li>
<li>为什么有时候下载高清大图时，图片会一块一块地加载。<br>答：这就是因为设置了http请求的长度，这样就可以分块的加载资源文件。<br>　　在请求报文中使用Range属性，在响应报文中使用Content-Type属性都可以指定一定字节范围的http请求。</li>
</ol>
<p>“自问自答”仅是我个人的理解，如果你有不同的观点，可以一起讨论。当然，如果你有认为不错的问答，可以联系我，我会不断完善。</p>
<hr>
<p>Github地址：<a href="https://github.com/JChehe/blog/blob/master/posts/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.md" target="_blank" rel="external">《图解HTTP》读书笔记</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h2&gt;&lt;p&gt;HTTP（HyperText Transfer Protocol，超文转移协议，超文本传输协议的译法并不严谨。）&lt;/p&gt;
&lt;h3 i
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://zhangchuanfeng.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="HTTP" scheme="http://zhangchuanfeng.me/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript面向对象精要》读书笔记</title>
    <link href="http://zhangchuanfeng.me/2016/12/02/%E3%80%8AJavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B2%BE%E8%A6%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://zhangchuanfeng.me/2016/12/02/《JavaScript面向对象精要》读书笔记/</id>
    <published>2016-12-02T13:05:16.000Z</published>
    <updated>2016-12-02T13:12:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript面向对象精要》这本书虽然不够100页，但都是精华，不愧是《JavaScript高级程序设计》作者 Nicholas C.Zakas 的最新力作。</p>
<p>下面是我的读书笔记（ES5）：</p>
<h2 id="1-原始类型和引用类型"><a href="#1-原始类型和引用类型" class="headerlink" title="1.原始类型和引用类型"></a>1.原始类型和引用类型</h2><h3 id="1-1-什么是类型"><a href="#1-1-什么是类型" class="headerlink" title="1.1 什么是类型"></a>1.1 什么是类型</h3><p><strong>原始类型</strong> 保存为简单数据值。<br><strong>引用类型</strong> 保存为对象，其本质是指向内存位置的引用。</p>
<p>为了让开发者能够把原始类型和引用类型按相同的方式处理，JavaScript花费了很大的努力来保证语言的一致性。</p>
<p>其他编程语言用栈存原始类型，用对存储引用类型。而JavaScript则完全不同：它使用一个变量对象追踪变量的生存期。原始值被直接保存在变量对象内，而引用值则作为一个指针保存在变量对象内，该指针指向实际对象在内存中的存储位置。<br><a id="more"></a></p>
<h3 id="1-2-原始类型"><a href="#1-2-原始类型" class="headerlink" title="1.2 原始类型"></a>1.2 原始类型</h3><p>原始类型代表照原样保存的一些简单数据。<br>JavaScript共有 <strong>5</strong> 种原始类型：</p>
<ul>
<li>boolean    布尔，值为 <code>true</code> or <code>false</code></li>
<li>number     数字，值为任何整型或浮点数值</li>
<li>string     字符串，值为由单引号或双引号括住的单个字符或连续字符</li>
<li>null       空类型，仅有一个值：null</li>
<li>undefined  未定义，只有一个值：undefined（undefined会被赋给一个还没有初始化的变量）</li>
</ul>
<p>JavaScript和许多其他语言一样，原始类型的变量直接保存原始值（而不是一个指向对象的指针）。</p>
<pre><code>var color1 = &quot;red&quot;;
var color2 = color1;

console.log(color1); // &quot;red&quot;
console.log(color2); // &quot;red&quot;

color1 = &quot;blue&quot;;

console.log(color1); // &quot;blue&quot;
console.log(color2); // &quot;red&quot;
</code></pre><h4 id="鉴别原始类型"><a href="#鉴别原始类型" class="headerlink" title="鉴别原始类型"></a>鉴别原始类型</h4><p>鉴别原始类型的最佳方式是使用 <code>typeof</code> 操作符。</p>
<pre><code>console.log(typeof &quot;Nicholas&quot;); // &quot;string&quot;
console.log(typeof 10);         // &quot;number&quot;
console.log(typeof true);       // &quot;boolean&quot;
console.log(typeof undefined);  // &quot;undefined&quot;
</code></pre><p>至于空类型（null）则有些棘手。</p>
<pre><code>console.log(typeof null); // &quot;object&quot;
</code></pre><p>对于 typeof null，结果是”object”。（其实这已被设计和维护JavaScript的委员会TC39认定是一个错误。在逻辑上，你可以认为 <code>null</code> 是一个空的对象指针，所以结果为”object”，但这还是很令人困惑。）</p>
<p>判断一个值是否为空类型（null）的最佳方式是直接和 <code>null</code> 比较：</p>
<pre><code>console.log(value === null); // true or false
</code></pre><blockquote>
<p><strong>注意：以上这段代码使用了三等号（全等===）</strong>，因为三等号（全等）不会将变量强制转换为另一种类型。</p>
</blockquote>
<pre><code>console.log(&quot;5&quot; == 5); // true
console.log(&quot;5&quot; === 5); // false

console.log(undefined == null); // true
console.log(undefined === null); // false
</code></pre><h4 id="原始方法"><a href="#原始方法" class="headerlink" title="原始方法"></a>原始方法</h4><p>虽然字符串、数字和布尔值是原始类型，但是它们也拥有方法（null和undefined没有方法）。</p>
<pre><code>var name = &quot;Nicholas&quot;;
var lowercaseName = name.toLowerCase(); // 转为小写

var count = 10;
var fixedCount = count.toFixed(2); // 转为10.00

var flag = true;
var stringFlag = flag.toString(); // 转为&quot;true&quot;

console.log(&quot;YIBU&quot;.charAt(0)); // 输出&quot;Y&quot;
</code></pre><blockquote>
<p>尽管原始类型拥有方法，但它们不是对象。JavaScript使它们看上去像对象一样，以此来提高语言上的一致性体验。</p>
</blockquote>
<h3 id="1-3-引用类型"><a href="#1-3-引用类型" class="headerlink" title="1.3 引用类型"></a>1.3 引用类型</h3><p>引用类型是指JavaScript中的对象，同时也是你在该语言中能找到最接近类的东西。<br>引用值是引用类型的实例，也是对象的同义词（后面将用对象指代引用值）。对象是属性的无序列表。属性包含键（始终是字符串）和值。如果一个属性的值是函数，它就被称为方法。除了函数可以运行以外，一个包含数组的属性和一个包含函数的属性没有什么区别。</p>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>有时候，把JavaScript对象想象成哈希表可以帮助你更好地理解对象结构。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/Object_hash.jpg" alt="Object"></p>
<p>JavaScript 有好几种方法可以创建对象，或者说实例化对象。第一种是使用 <code>new</code> 操作符和构造函数。<br>构造函数就是通过 <code>new</code> 操作符来创建对象的函数——任何函数都可以是构造函数。根据命名规范，JavaScript中的构造函数用<strong>首字母大写</strong>来跟非构造函数进行区分。</p>
<pre><code>var object = new Object();
</code></pre><p>因为引用类型不再变量中直接保存对象，所以本例中的 <code>object</code> 变量实际上并<strong>不包含对象的实例，而是一个指向内存中实际对象所在位置的指针（或者说引用）</strong>。这是对象和原始值之间的一个基本差别，原始值是直接保存在变量中。</p>
<p>当你将一个对象赋值给变量时，实际是赋值给这个变量一个指针。这意味着，将一个变量赋值给另外一个变量时，两个变量各获得了一份指针的拷贝，指向内存中的同一个对象。</p>
<pre><code>var obj1 = new Object();
var obj2 = obj1;
</code></pre><p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/copy_obj.jpg" alt="copy_obj"></p>
<h4 id="对象引用解除"><a href="#对象引用解除" class="headerlink" title="对象引用解除"></a>对象引用解除</h4><p>JavaScript语言有垃圾收集的功能，因此当你使用引用类型时无需担心内存分配。<strong>但最好在不使用对象时将其引用解除，让垃圾收集器对那块内存进行释放。解除引用的最佳手段是将对象变量设置为 <code>null</code>。</strong></p>
<pre><code>var obj1 = new Object();
// dosomething
obj1 = null; // dereference
</code></pre><h4 id="添加删除属性"><a href="#添加删除属性" class="headerlink" title="添加删除属性"></a>添加删除属性</h4><p>在JavaScript中，你可以随时添加和删除其属性。</p>
<pre><code>var obj1 = new Object();
var obj2 = obj1;

obj1.myCustomProperty = &quot;Awsome!&quot;;
console.log(obj2.myCustomProperty); // &quot;Awsome!&quot; 因为obj1和obj2指向同一个对象。
</code></pre><h3 id="1-4-内建类型实例化"><a href="#1-4-内建类型实例化" class="headerlink" title="1.4 内建类型实例化"></a>1.4 内建类型实例化</h3><p>内建类型如下：</p>
<ul>
<li>Array       数组类型，以数字为索引的一组值的有序列表</li>
<li>Date        日期和时间类型</li>
<li>Error       运行期错误类型</li>
<li>Function    函数类型</li>
<li>Object      通用对象类型</li>
<li>RegExp      正则表达式类型    </li>
</ul>
<p>可使用 <code>new</code> 来实例化每一个内建引用类型：</p>
<pre><code>var items = new Array();
var new = new Date();
var error = new Error(&quot;Something bad happened.&quot;);
var func = new Function(&quot;console.log(&apos;HI&apos;);&quot;);
var object = new Object();
var re = new RegExp();
</code></pre><h4 id="字面形式"><a href="#字面形式" class="headerlink" title="字面形式"></a>字面形式</h4><p>内建引用类型有字面形式。字面形式允许你在不需要使用 <code>new</code> 操作符和构造函数显示创建对象的情况下生成引用值。属性的<strong>键</strong>可以是标识符或字符串（若含有空格或其他特殊字符）</p>
<pre><code>var book = {
    name: &quot;Book_name&quot;,
    year: 2016
}
</code></pre><p>上面代码与下面这段代码等价：</p>
<pre><code>var book = new Object();
book.name = &quot;Book_name&quot;;
book.year = 2016;
</code></pre><blockquote>
<p>虽然使用字面形式并没有调用 new Object()，但是JavaScript引擎背后做的工作和 new Object()一样，除了没有调用构造函数。其他引用类型的字面形式也是如此。</p>
</blockquote>
<h3 id="1-5-访问属性"><a href="#1-5-访问属性" class="headerlink" title="1.5 访问属性"></a>1.5 访问属性</h3><p>可通过 <code>.</code> 和 <code>中括号</code> 访问对象的属性。<br>中括号<code>[]</code>在需要动态决定访问哪个属性时，特别有用。因为你可以用<strong>变量</strong>而不是字符串字面形式来指定访问的属性。</p>
<h3 id="1-6-鉴别引用类型"><a href="#1-6-鉴别引用类型" class="headerlink" title="1.6 鉴别引用类型"></a>1.6 鉴别引用类型</h3><p>函数是最容易鉴别的引用类型，因为对函数使用 <code>typeof</code> 操作符时，返回”function”。</p>
<pre><code>function reflect(value){
    return value;
}
console.log(typeof reflect); // &quot;function&quot;
</code></pre><p>对其他引用类型的鉴别则较为棘手，因为对于所有非函数的引用类型，<code>typeof</code> 返回 <code>object</code>。为了更方便地鉴别引用类型，可以使用 JavaScript 的 <code>instanceof</code> 操作符。</p>
<pre><code>var items = [];
var obj = {};
function reflect(value){
    return value;
}

console.log(items instanceof Array); // true;
console.log(obj instanceof Object); // true;
console.log(reflect instanceof Function); // true;
</code></pre><p><code>instanceof</code> 操作符可鉴别继承类型。这意味着所有对象都是 <code>Oject</code> 的实例，因为所有引用类型都继承自 <code>Object</code>。</p>
<blockquote>
<p>虽然 instanceof 可以鉴别对象类型（如数组），但是有一个列外。JavaScript 的值可以在同一个网页的不用框架之间传来传去。由于每个网页拥有它自己的全局上下文——Object、Array以及其他内建类型的版本。所以当你把一个对象（如数组）从一个框架传到另外一个框架时，instanceof就无法识别它。</p>
</blockquote>
<h3 id="1-8-原始封装类型"><a href="#1-8-原始封装类型" class="headerlink" title="1.8 原始封装类型"></a>1.8 原始封装类型</h3><p>原始封装类型有 <code>3</code> 种：String、Number 和 Boolean。<br>当读取字符串、数字或布尔值时，原始封装类型将被自动创建。</p>
<pre><code>var name = &quot;Nicholas&quot;;
var firstChar = name.charAt(0); // &quot;N&quot;
</code></pre><p>这在背后发生的事情如下：</p>
<pre><code>var name = &quot;Nichola&quot;;
var temp = new String(name);
var firstChar = temp.charAt(0);
temp = null;
</code></pre><p>由于第二行把字符串当成对象使用，JavaScript引擎创建了一个字符串的实体让 <code>charAt(0)</code> 可以工作。字符串对象的存在仅用于该语句并在随后销毁（一种被称为自动打包的过程）。为了测试这一点，试着给字符串添加一个属性看看它是不是对象。</p>
<pre><code>var name = &quot;Nicholas&quot;;
name.last = &quot;Zakas&quot;;

console.log(name.last); // undefined;
</code></pre><p>下面是在JavaScript引擎中实际发生的事情：</p>
<pre><code>var name = &quot;Nicholas&quot;;
var temp = new String(name);
temp.last = &quot;Zakas&quot;;
temp = null; // temporary object destroyed

var temp = new String(name);
console.log(temp.last);
temp = null;
</code></pre><p>新属性 <code>last</code> 实际上是在一个立刻就被销毁的临时对象上而不是字符串上添加。之后当你试图访问该属性时，另一个不同的临时对象被创建，而新属性并不存在。</p>
<p>虽然原始封装类型会被自动创建，在这些值上进行 <code>instanceof</code> 检查对应类型的返回值却是 <code>false</code>。<br>这是因为<strong>临时对象仅在值被读取时创建</strong>。<code>instanceof</code> 操作符并没有真的读取任何东西，也就没有临时对象的创建。</p>
<p>当然你也可以手动创建原始封装类型。</p>
<pre><code>var str = new String(&quot;me&quot;);
str.age = 18;

console.log(typeof str); // object
console.log(str.age); // 18
</code></pre><p>如你所见，手动创建原始封装类型实际会创建出一个 <code>object</code>。这意味着 <code>typeof</code> 无法鉴别出你实际保存的数据的类型。</p>
<p>另外，手动创建原始封装类型和使用原始值是有一定区别的。所以尽量避免使用。</p>
<pre><code>var found = new Boolean(false);
if(found){
    console.log(&quot;Found&quot;); // 执行到了，尽管对象的值为 false
}
</code></pre><p>这是因为一个对象(如 <code>{}</code> )在条件判断语句中总被认为是 <code>true</code>;</p>
<blockquote>
<p>MDN:Any object whose value is not undefined or null, including a Boolean oject whose value is false, evaluates to true when passed to a conditional statement.</p>
</blockquote>
<h3 id="1-9-总结"><a href="#1-9-总结" class="headerlink" title="1.9 总结"></a>1.9 总结</h3><p>第一章的东西都是我们一些比较熟悉的知识。但是也有一些需要注意的地方：</p>
<ul>
<li>正确区分原始类型和引用类型</li>
<li>对于 <code>5</code> 种原始类型都可以用typeof来鉴别，而空类型必须直接跟 <code>null</code> 进行全等比较。</li>
<li>函数也是对象，可用 <code>typeof</code> 鉴别。其它引用类型，可用 <code>instanceof</code> 和一个构造函数来鉴别。（当然可以用  <code>Object.prototype.toString.call()</code> 鉴别，它会返回[object Array]之类的）。</li>
<li>为了让原始类型看上去更像引用类型，JavaScript提供了 <code>3</code> 种封装类型。JavaScript会在背后创建这些对象使得你能够像使用普通对象那样使用原始值。但这些临时对象在使用它们的语句结束时就立刻被销毁。虽然可手动创建，但不建议。</li>
</ul>
<h2 id="2-函数"><a href="#2-函数" class="headerlink" title="2. 函数"></a>2. 函数</h2><p>函数也是对象，使对象不同于其它对象的决定性特点是函数存在一个被称为 <code>[[Call]]</code> 的内部属性。<br><strong>内部属性无法通过代码访问而是定义了代码执行时的行为</strong>。ECMAScript为JavaScript的对象定义了多种内部属性，这些<strong>内部属性都用双重中括号来标注</strong>。</p>
<p><strong>[[Call]]属性是函数独有的，表明该对象可以被执行。由于仅函数拥有该属性，ECMAScript 定义typeof操作符对任何具有[[Call]]属性的对象返回”function”</strong>。过去因某些浏览器曾在正则表达式中包含 <code>[[Call]]</code> 属性，导致正则表达式被错误鉴别为函数。</p>
<h3 id="2-1-声明还是表达式"><a href="#2-1-声明还是表达式" class="headerlink" title="2.1 声明还是表达式"></a>2.1 声明还是表达式</h3><p>两者的一个重要区别是：函数声明会被提升至上下文（要么是该函数被声明时所在的函数范围，要么是全局范围）的顶部。</p>
<h3 id="2-2-函数就是值"><a href="#2-2-函数就是值" class="headerlink" title="2.2 函数就是值"></a>2.2 函数就是值</h3><p>可以像使用对象一样使用函数（因为函数本来就是对象，Function构造函数更加容易说明）。</p>
<h3 id="2-3-参数"><a href="#2-3-参数" class="headerlink" title="2.3 参数"></a>2.3 参数</h3><p>函数参数保存在类数组对象 <code>argument</code> （<code>Array.isArray(arguments)</code> 返回 <code>false</code>）中。可以接收任意数量的参数。<br>函数的 <code>length</code> 属性表明其期望的参数个数。</p>
<h3 id="2-4-重载"><a href="#2-4-重载" class="headerlink" title="2.4 重载"></a>2.4 重载</h3><p>大多数面向对象语言支持函数重载，它能让一个函数具有多个签名。函数签名由函数的名字、参数的个数及其类型组成。<br>而JavaScript可以接收任意数量的参数且参数类型完全没有限制。这说明JavaScript函数根本就没有签名，因此也不存在重载。</p>
<pre><code>function sayMessage(message){
    console.log(message);
}
function sayMessage(){
    console.log(&quot;Default Message&quot;);
}

sayMessage(&quot;Hello!&quot;); // 输出&quot;Default Message&quot;;
</code></pre><p>在Javscript里，当你试图定义多个同名的函数时，只有最后的定义有效，之前的函数声明被完全删除（函数也是对象，变量只是存指针)。</p>
<pre><code>var sayMessage = new Function(&quot;message&quot;, &quot;console.log(message)&quot;);
var sayMessage = new Function(&quot;console.log(\&quot;Default Message\&quot;);&quot;);

sayMessage(&quot;Hello!&quot;); 
</code></pre><p>当然，你可以根据传入参数的数量来模仿重载。</p>
<h3 id="2-5-对象方法"><a href="#2-5-对象方法" class="headerlink" title="2.5 对象方法"></a>2.5 对象方法</h3><p>对象的值是函数，则该属性被称为方法。</p>
<h4 id="2-5-1-this对象"><a href="#2-5-1-this对象" class="headerlink" title="2.5.1 this对象"></a>2.5.1 this对象</h4><p>JavaScript 所有的函数作用域内都有一个 <code>this</code> 对象代表调用该函数的对象。在全局作用域中，<code>this</code> 代表全局对象（浏览器里的window）。当一个函数作为对象的方法调用时，默认 <code>this</code> 的值等于该对象。<br><strong>this在函数调用时才被设置。</strong></p>
<pre><code>function sayNameForAll(){
    console.log(this.name);
}

var person1 = {
    name: &quot;Nicholas&quot;,
    sayName: sayNameForAll
}

var name = &quot;Jack&quot;;

person1.sayName(); // 输出 &quot;Nicholas&quot;
sayNameforAll(); // 输出 &quot;Jack&quot;
</code></pre><h4 id="2-5-2-改变this"><a href="#2-5-2-改变this" class="headerlink" title="2.5.2 改变this"></a>2.5.2 改变this</h4><p>有 <code>3</code> 种函数方法运行你改变 <code>this</code> 值。</p>
<ol>
<li>fun.call(thisArg[, arg1[, arg2[, …]]]);</li>
<li>fun.apply(thisArg, [argsArray]);</li>
<li>fun.bind(thisArg[, arg1[, arg2[, …]]])</li>
</ol>
<p>使用 <code>call</code> 或 <code>apply</code> 方法，就不需要将函数加入每个对象——你显示地指定了 <code>this</code> 的值而不是让JavaScript引擎自动指定。</p>
<p><code>call</code> 与 <code>apply</code> 的不同地方是，<code>call</code> 需要把所有参数一个个列出来，而 <code>apply</code> 的参数需要一个数组或者类似数组的对象（如 <code>arguments</code> 对象）。</p>
<p><code>bind</code> 是ECMAScript 5 新增的，它会创建一个新函数返回。其参数与 <code>call</code> 类似，而且其所有参数代表需要被<strong>永久</strong>设置在新函数中的命名参数（绑定了的参数（没绑定的参数依然可以传入），就算调用时再传入其它参数，也不会影响这些绑定的参数）。</p>
<pre><code>function sayNameForAll(label){
    console.log(label + &quot;:&quot; + this.name);
}
var person = {
    name: &quot;Nicholas&quot;
}

var sayNameForPerson = sayNameForAll.bind(person);
sayNameForPerson(&quot;Person&quot;); // 输出&quot;Person:Nicholas&quot;

var sayName = sayNameForAll.bind(person, &quot;Jc&quot;);

sayName(&quot;change&quot;); // 输出&quot;Jc:Nicholas&quot; 因为绑定的形参，会忽略调用时再传入参数
</code></pre><h3 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a>2.6 总结</h3><ul>
<li>函数也是对象，所以它可以被访问、复制和覆盖。</li>
<li>函数与其他对象最大的区别在于它们有一个特殊的内部属性 <code>[[Call]]</code>，包含了该函数的执行指令。</li>
<li>函数声明会被提升至上下文的顶部。</li>
<li>函数是对象，所以存在一个 <code>Function</code> 构造函数。但这会使你的代码难以理解和调试，除非函数的真实形式要直到运行时才能确定的时候才会利用它。</li>
</ul>
<h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><p>JavaScript中的对象是动态的，可在代码执行的任意时刻发生改变。基于类的语言会根据类的定义锁定对象。</p>
<h3 id="3-1-定义属性"><a href="#3-1-定义属性" class="headerlink" title="3.1 定义属性"></a>3.1 定义属性</h3><p>当一个属性第一次被添加到对象时，JavaScript会在对象上调用一个名为 <code>[[Put]]</code> 的内部方法。<code>[[Put]]</code> 方法会在对象上创建一个新节点来保存属性。<br>当一个已有的属性被赋予一个新值时，调用的是一个名为 <code>[[Set]]</code> 的方法。</p>
<h3 id="3-2-属性探测"><a href="#3-2-属性探测" class="headerlink" title="3.2 属性探测"></a>3.2 属性探测</h3><p>检查对象是否已有一个属性。JavaScript开发新手错误地使用以下模式检测属性是否存在。</p>
<pre><code>if(person.age){
    // do something with ag
}
</code></pre><p>上面的问题在于JavaScript的类型强制会影响该模式的输出结果。<br>当if判断中的值如下时，会判断为<strong>真</strong>：</p>
<ul>
<li>对象</li>
<li>非空字符串</li>
<li>非零</li>
<li>true</li>
</ul>
<p>当if判断中的值如下时，会判断为<strong>假</strong>：</p>
<ul>
<li>null</li>
<li>undefined</li>
<li>0</li>
<li>false</li>
<li>NaN</li>
<li>空字符串</li>
</ul>
<p>因此判断属性是否存在的方法是使用 <code>in</code> 操作符。<br><code>in</code> 操作符会检查<strong>自有属性和原型属性</strong>。<br>所有的对象都拥有的 <code>hasOwnProperty()</code> 方法（其实是 <code>Object.prototype</code> 原型对象的），该方法在给定的属性存在且为<strong>自有属性</strong>时返回 <code>true</code>。</p>
<pre><code>var person = {
    name: &quot;Nicholas&quot;
}

console.log(&quot;name&quot; in person); // true
console.log(person.hasOwnpropert(&quot;name&quot;)); // true

console.log(&quot;toString&quot; in person); // true
console.log(person.hasOwnproperty(&quot;toString&quot;)); // false
</code></pre><h3 id="3-3-删除属性"><a href="#3-3-删除属性" class="headerlink" title="3.3 删除属性"></a>3.3 删除属性</h3><p>设置一个属性的值为 <code>null</code> 并不能从对象中彻底移除那个属性，这只是调用 <code>[[Set]]</code> 将 <code>null</code> 值替换了该属性原来的值而已。<br><code>delete</code> 操作符针对单个对象属性调用名为 <code>[[Delete]]</code> 的内部方法。删除成功时，返回 <code>true</code>。</p>
<pre><code>var person = {
    name: &quot;Nicholas&quot;
}

person.name = null;
console.log(&quot;name&quot; in person); // true
delete person.name;
console.log(person.name); // undefined 访问一个不存在的属性将返回 undefined
console.log(&quot;name&quot; in person); // false
</code></pre><h3 id="3-4-属性枚举"><a href="#3-4-属性枚举" class="headerlink" title="3.4 属性枚举"></a>3.4 属性枚举</h3><p>所有人为添加的属性默认都是可枚举的。可枚举的内部特征 <code>[[Enumerable]]</code> 都被设置为 <code>true</code>。<br><code>for-in</code> 循环会枚举一个对象所有的可枚举属性。</p>
<blockquote>
<p>我的备注：在Chrome中，对象属性会按ASCII表排序，而不是定义时的顺序。</p>
</blockquote>
<p>ECMAScript 5 的 Object() 方法可以获取可枚举属性的名字的数组。</p>
<pre><code>var person = {
    name: &quot;Ljc&quot;,
    age: 18
}

Object.keys(person); // [&quot;name&quot;, &quot;age&quot;];
</code></pre><p><code>for-in</code> 与 <code>Object.keys()</code> 的一个区别是：前者也会遍历原型属性，而后者返回自有(实例)属性。</p>
<p>实际上，对象的大部分原生方法的 <code>[[Enumerable]]</code> 特征都被设置为 <code>false</code>。可用 <code>propertyIsEnumerable()</code> 方法检查一个属性是否为可枚举的。</p>
<pre><code>var arr = [&quot;abc&quot;, 2];
console.log(arr.propertyIsEnumerable(&quot;length&quot;)); // false
</code></pre><h3 id="3-5-属性类型"><a href="#3-5-属性类型" class="headerlink" title="3.5 属性类型"></a>3.5 属性类型</h3><p>属性有两种类型：<strong>数据属性</strong>和<strong>访问器属性</strong>。<br>数据属性包含一个值。<code>[[Put]]</code> 方法的默认行为是创建<strong>数据属性</strong>。<br>访问器属性不包含值而是定义了一个当属性被读取时调用的函数（称为<code>getter</code>）和一个当属性被写入时调用的函数（称为<code>setter</code>）。访问器属性仅需要 <code>getter</code> 或 <code>setter</code> 两者中的任意一个，当然也可以两者。</p>
<pre><code>// 对象字面形式中定义访问器属性有特殊的语法：
var person = {
    _name: &quot;Nicholas&quot;,

    get name(){
        console.log(&quot;Reading name&quot;);
        return this._name;
    },
    set name(value){
        console.log(&quot;Setting name to %s&quot;, value);
        this._name = value;
    }
};

console.log(person.name); // &quot;Reading name&quot; 然后输出 &quot;Nicholas&quot;

person.name = &quot;Greg&quot;;
console.log(person.name); // &quot;Setting name to Greg&quot; 然后输出 &quot;Greg&quot;
</code></pre><blockquote>
<p>前置下划线_ 是一个约定俗成的命名规范，表示该属性是私有的，实际上它还是公开的。</p>
</blockquote>
<p>访问器就是定义了我们在对象读取或设置属性时，触发的动作（函数），<code>_name</code> 相当于一个内部变量。<br>当你希望赋值（读取）操作会触发一些行为，访问器就会非常有用。</p>
<blockquote>
<p>当只定义getter或setter其一时，该属性就会变成只读或只写。</p>
</blockquote>
<h3 id="3-6-属性特征"><a href="#3-6-属性特征" class="headerlink" title="3.6 属性特征"></a>3.6 属性特征</h3><p>在ECMAScript 5 之前没有办法指定一个属性是否可枚举。实际上根本没有方法访问属性的任何内部特征。为了改变这点，ECMAScript 5引入了多种方法来和属性特征值直接互动。</p>
<h4 id="3-6-1-通用特征"><a href="#3-6-1-通用特征" class="headerlink" title="3.6.1 通用特征"></a>3.6.1 通用特征</h4><p>数据属性和访问器属性均由以下两个属性特制：<br><code>[[Enumerable]]</code> 决定了是否可以遍历该属性；<br><code>[[Configurable]]</code> 决定了该属性是否可配置。</p>
<p>所有人为定义的属性默认都是可枚举、可配置的。</p>
<p>可以用 <code>Object.defineProperty()</code> 方法改变属性特征。<br>其参数有三：拥有该属性的对象、属性名和包含需要设置的特性的属性描述对象。</p>
<pre><code>var person = {
    name: &quot;Nicholas&quot;
}
Object.defineProperty(person, &quot;name&quot;, {
    enumerable: false
})

console.log(&quot;name&quot; in person); // true
console.log(person.propertyIsEnumerable(&quot;name&quot;)); // false

var properties = Object.keys(person);
console.log(properties.length); // 0

Object.defineProperty(person, &quot;name&quot;,{
    configurable: false
})

delete person.name; // false
console.log(&quot;name&quot; in person); // true

Object.defineProperty(person, &quot;name&quot;,{ // error! 
// 在 chrome：Uncaught TypeError: Cannot redefine property: name
    configurable: true
})
</code></pre><blockquote>
<p>无法将一个不可配置的属性变为可配置，相反则可以。</p>
</blockquote>
<h4 id="3-6-2-数据属性特征"><a href="#3-6-2-数据属性特征" class="headerlink" title="3.6.2 数据属性特征"></a>3.6.2 数据属性特征</h4><p>数据属性额外拥有两个访问器属性不具备的特征。<br><code>[[Value]]</code> 包含属性的值(哪怕是函数)。<br><code>[[Writable]]</code> 布尔值，指示该属性是否可写入。所有属性默认都是可写的。</p>
<pre><code>var person = {};

Object.defineProperty(person, &quot;name&quot;, {
    value: &quot;Nicholas&quot;,
    enumerable: true,
    configurable: true,
    writable: true
})
</code></pre><p>在 <code>Object.defineProperty()</code> 被调用时，如果属性本来就有，则会按照新定义属性特征值去覆盖默认属性特征（<code>enumberable</code>、<code>configurable</code> 和 <code>writable</code> 均为 <code>true</code>）。但如果用该方法定义新的属性时，没有为所有的特征值指定一个值，则所有布尔值的特征值会被默认设置为 <code>false</code>。即不可枚举、不可配置、不可写的。<br>当你用 <code>Object.defineProperty()</code> 改变一个已有的属性时，只有你指定的特征会被改变。</p>
<h4 id="3-6-3-访问器属性特征"><a href="#3-6-3-访问器属性特征" class="headerlink" title="3.6.3 访问器属性特征"></a>3.6.3 访问器属性特征</h4><p>访问器属性额外拥有两个特征。<code>[[Get]]</code> 和 <code>[[Set]]</code>，内含 <code>getter</code> 和 <code>setter</code> 函数。<br>使用访问其属性特征比使用对象字面形式定义访问器属性的优势在于：可以为已有的对象定义这些属性。而后者只能在创建时定义访问器属性。</p>
<pre><code>var person = {
    _name: &quot;Nicholas&quot;
};

Object.defineProperty(person, &quot;name&quot;, {
    get: function(){
        return this._name;
    },
    set: function(value){
        this._name = value;
    },
    enumerable: true,
    configurable: true
})

for(var x in person){
    console.log(x); // _name \n(换行) name（访问器属性）
}
</code></pre><p>设置一个不可配置、不可枚举、不可以写的属性：</p>
<pre><code>Object.defineProperty(person, &quot;name&quot;,{
    get: function(){
        return this._name;
    }
})
</code></pre><p>对于一个新的访问器属性，没有显示设置值为布尔值的属性，默认为 <code>false</code>。</p>
<h4 id="3-6-4-定义多重属性"><a href="#3-6-4-定义多重属性" class="headerlink" title="3.6.4 定义多重属性"></a>3.6.4 定义多重属性</h4><p><code>Object.defineProperties()</code> 方法可以定义任意数量的属性，甚至可以同时改变已有的属性并创建新属性。</p>
<pre><code>var person = {};

Object.defineProperties(person, {

    // data property to store data
    _name: {
        value: &quot;Nicholas&quot;,
        enumerable: true,
        configurable: true,
        writable: true
    },

    // accessor property
    name: {
        get: function(){
            return this._name;
        },
        set: function(value){
            this._name = value;
        }
    }
})
</code></pre><h4 id="3-6-5-获取属性特征"><a href="#3-6-5-获取属性特征" class="headerlink" title="3.6.5 获取属性特征"></a>3.6.5 获取属性特征</h4><p><code>Object.getOwnPropertyDescriptor()</code> 方法。该方法接受两个参数：对象和属性名。如果属性存在，它会返回一个属性描述对象，内涵<code>4</code>个属性：<code>configurable</code> 和 <code>enumerable</code>，另外两个属性则根据属性类型决定。</p>
<pre><code>var person = {
    name: &quot;Nicholas&quot;
}

var descriptor = Object.getOwnPropertyDescriptor(person, &quot;name&quot;);

console.log(descriptor.enumerable); // true
console.log(descriptor.configuable); // true
console.log(descriptor.value); // &quot;Nicholas&quot;
console.log(descriptor.wirtable); // true
</code></pre><h3 id="3-7-禁止修改对象"><a href="#3-7-禁止修改对象" class="headerlink" title="3.7 禁止修改对象"></a>3.7 禁止修改对象</h3><p>对象和属性一样具有指导其行为的内部特性。其中， <code>[[Extensible]]</code> 是布尔值，指明该对象本身是否可以被修改。默认是 <code>true</code>。当值为 <code>false</code> 时，就能禁止新属性的添加。</p>
<blockquote>
<p>建议在 “use strict”; 严格模式下进行。</p>
</blockquote>
<h4 id="3-7-1-禁止扩展"><a href="#3-7-1-禁止扩展" class="headerlink" title="3.7.1 禁止扩展"></a>3.7.1 禁止扩展</h4><p><code>Object.preventExtensions()</code> 创建一个不可扩展的对象（即<strong>不能添加新属性</strong>）。<br><code>Object.isExtensible()</code> 检查 <code>[[Extensible]]</code> 的值。</p>
<pre><code>var person = {
    name: &quot;Nocholas&quot;
}

Object.preventExtensions(person);

person.sayName = function(){
    console.log(this.name)
}

console.log(&quot;sayName&quot; in person); // false
</code></pre><h4 id="3-7-2-对象封印"><a href="#3-7-2-对象封印" class="headerlink" title="3.7.2 对象封印"></a>3.7.2 对象封印</h4><p>一个被封印的对象是不可扩展的且其所有属性都是不可配置的（即不能添加、删除属性或修改其属性类型（从数据属性变成访问器属性或相反））。<strong>只能读写它的属性</strong>。<br>Object.seal()。调用此方法后，该对象的 <code>[[Extensible]]</code> 特征被设置为 <code>false</code>，其所有属性的 <code>[[configurable]]</code> 特征被设置为 <code>false</code>。<br><code>Object.isSealed()</code> 判断一个对象是否被封印。</p>
<h4 id="3-7-3-对象冻结"><a href="#3-7-3-对象冻结" class="headerlink" title="3.7.3 对象冻结"></a>3.7.3 对象冻结</h4><p>被冻结的对象不能添加或删除属性，不能修改属性类型，也不能写入任何数据属性。简言而之，被冻结对象是一个<strong>数据属性都为只读</strong>的被封印对象。<br><code>Object.freeze()</code> 冻结对象。<br><code>Object.isFrozen()</code> 判断对象是否被冻结。</p>
<h3 id="3-8-总结"><a href="#3-8-总结" class="headerlink" title="3.8 总结"></a>3.8 总结</h3><ul>
<li><code>in</code> 操作符检测自有属性和原型属性，而 <code>hasOwnProperty()</code> 只检查自有属性。</li>
<li>用 <code>delete</code> 操作符删除对象属性。</li>
<li>属性有两种类型：数据属性和访问器属性。</li>
<li>所有属性都有一些相关特征。<code>[[Enumerable]]</code> 和 <code>[[Configurable]]</code> 的两种属性都有的，而数据属性还有 <code>[[Value]]</code> 和 <code>[[Writable]]</code>，访问器属性还有 <code>[[Get]]</code> 和 <code>[[Set]]</code>。可通过 <code>Object.defineProperty()</code> 和 <code>Object.defineProperties()</code> 改变这些特征。用 <code>Object.getOwnPropertyDescriptor()</code> 获取它们。</li>
<li>有 <code>3</code> 种可以锁定对象属性的方式。</li>
</ul>
<h2 id="4-构造函数和原型对象"><a href="#4-构造函数和原型对象" class="headerlink" title="4. 构造函数和原型对象"></a>4. 构造函数和原型对象</h2><p>由于JavaScript(ES5)缺乏类，但可用构造函数和原型对象给对象带来与类相似的功能。</p>
<h3 id="4-1-构造函数"><a href="#4-1-构造函数" class="headerlink" title="4.1 构造函数"></a>4.1 构造函数</h3><p>构造函数的函数名首字母应大写，以此区分其他函数。<br>当没有需要给构造函数传递参数，可忽略小括号：</p>
<pre><code>var Person = {
    // 故意留空
}
var person = new Person;
</code></pre><p>尽管 Person 构造函数没有显式返回任何东西，但 new 操作符会自动创建给定类型的对象并返回它们。</p>
<p>每个对象在创建时都自动拥有一个构造函数属性（constructor，其实是它们的原型对象上的属性），其中包含了一个指向其构造函数的引用。<br>通过对象字面量形式（{}）或Object构造函数创建出来的泛用对象，其构造函数属性（constructor）指向 Object；而那些通过自定义构造函数创建出来的对象，其构造函数属性指向创建它的构造函数。</p>
<pre><code>console.log(person.constructor === Person); // true
console.log(({}).constructor === Object); // true
console.log(([1,2,3]).constructor === Object); // true

// 证明 constructor是在原型对象上
console.log(person.hasOwnPrototype(&quot;constructor&quot;)); // false
console.log(person.constructor.prototype.hasOwnPrototype(&quot;constructor&quot;)); // true
</code></pre><p>尽管对象实例及其构造函数之间存在这样的关系，但还是建议使用 <code>instanceof</code> 来检查对象类型。这是因为构造函数属性可以被覆盖。（person.constructor = “”）。</p>
<p>当你调用构造函数时，new 会自动创建 this 对象，且其类型就是构造函数的类型（构造函数就好像类，相当于一种数据类型）。</p>
<blockquote>
<p>你也可以在构造函数中显式调用 return。如果返回值是一个对象，它会代替新创建的对象实例而返回，如果返回值是一个原始类型，它会被忽略，新创建的对象实例会被返回。</p>
</blockquote>
<p>始终确保要用 new 调用构造函数；否则，你就是在冒着改变全局对象的风险，而不是创建一个新的对象。</p>
<pre><code>var person = Person(&quot;Nicholas&quot;); // 缺少 new

console.log(person instanceof Person); // false
console.log(person); // undefined，因为没用 new，就相当于一个普通函数，默认返回 undefined
console.log(name); // &quot;Nicholas&quot;
</code></pre><p>当Person不是被 new 调用时，构造函数中的 this 对象等于全局 this 对象。</p>
<blockquote>
<p>在严格模式下，会报错。因为严格模式下，并没有为全局对象设置 this，this 保持为 undefined。</p>
</blockquote>
<p>以下代码，通过 new 实例化 100 个对象，则会有 100 个函数做相同的事。因此可用 <code>prototype</code> 共享同一个方法会更高效。</p>
<pre><code>var person = {
    name: &quot;Nicholas&quot;,
    sayName: function(){
        console.log(this.name);
    }
}
</code></pre><h3 id="4-2-原型对象"><a href="#4-2-原型对象" class="headerlink" title="4.2 原型对象"></a>4.2 原型对象</h3><p>可以把原型对象看作是对象的基类。几乎所有的函数（除了一些内建函数）都有一个名为 prototype 的属性，该属性是一个原型对象用来创建新的对象实例。所有创建的对象实例（同一构造函数，当然，可能访问上层的原型对象）<strong>共享</strong>该原型对象，且这些对象实例可以访问原型对象的属性。例如，hasOwnProperty()定义在 Object 的原型对象中，但却可被任何对象当作自己的属性访问。</p>
<pre><code>var book = {
    title : &quot;book_name&quot;
}

&quot;hasOwnProperty&quot; in book; // true
book.hasOwnProperty(&quot;hasOwnProperty&quot;); // false
Object.property.hasOwnProperty(&quot;hasOwnProperty&quot;); // true
</code></pre><p><strong>鉴别一个原型属性</strong></p>
<pre><code>function hasPrototypeProperty(object, name){
    return name in object &amp;&amp; !object.hasOwnProperty(name);
}
</code></pre><h4 id="4-2-1-Prototype-属性"><a href="#4-2-1-Prototype-属性" class="headerlink" title="4.2.1 [[Prototype]] 属性"></a>4.2.1 [[Prototype]] 属性</h4><p>一个对象实例通过内部属性 [[Prototype]] 跟踪其原型对象。该属性是一个指向该实例使用的原型对象的指针。当你用 new 创建一个新的对象时，构造函数的原型对象就会被赋给该对象的 [[Prototype]] 属性。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/prototype.jpg" alt="prototype"></p>
<p>由上图可以看出，[[Prototype]] 属性是如何让多个对象实例引用同一个原型对象来减少重复代码。</p>
<p>Object.getPrototypeOf() 方法可读取 [[Prototype]] 属性的值。</p>
<pre><code>var obj = {};
var prototype = Object.getPrototypeOf(Object);

console.log(prototype === Object.prototype); // true
</code></pre><blockquote>
<p>大部分JavaScript引擎在所有对象上都支持一个名为 <code>__proto__</code> 的属性。该属性使你可以直接读写 [[Prototype]] 属性。</p>
</blockquote>
<p>isPrototypeOf() 方法会检查某个对象是否是另一个对象的原型对象，该方法包含在所有对象中。</p>
<pre><code>var obj = {}
console.log(Object.prototype.isPrototypeOf(obj)); // true
</code></pre><p>当读取一个对象的属性时，JavaScript 引擎首先在该对象的自有属性查找属性名。如果找到则返回。否则会搜索 [[Prototype]] 中的对象，找到则返回，找不到则返回 undefined。</p>
<pre><code>var obj = new Object();
console.log(obj.toString()); // &quot;[object Object]&quot;

obj.toString = function(){
    return &quot;[object Custom]&quot;;
}
console.log(obj.toString()); // &quot;[object Custom]&quot;

delete obj.toString; // true
console.log(obj.toString()); // &quot;[object Object]&quot;

delete obj.toString; // 无效，delete不能删除一个对象从原型继承而来的属性
cconsole.log(obj.toString()); // // &quot;[object Object]&quot;
</code></pre><blockquote>
<p>MDN：delete 操作符不能删除的属性有：①显式声明的全局变量不能被删除,该属性不可配置（not configurable）； ②内置对象的内置属性不能被删除； ③不能删除一个对象从原型继承而来的属性(不过你可以从原型上直接删掉它)。</p>
</blockquote>
<p>一个重要概念：无法给一个对象的原型属性赋值。但我们可以通过 <code>obj.constructor.prototype.sayHi = function(){console.log(&quot;Hi!&quot;)}</code> 向原型对象添加属性。</p>
<p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/%E6%97%A0%E6%A0%87%E9%A2%98.jpg" alt="此处输入图片的描述"><br>（图片中间可以看出，为对象obj添加的toString属性代替了原型属性）</p>
<h4 id="4-2-2-在构造函数中使用原型对象"><a href="#4-2-2-在构造函数中使用原型对象" class="headerlink" title="4.2.2 在构造函数中使用原型对象"></a>4.2.2 在构造函数中使用原型对象</h4><p>构造函数模式的缺点：无法共享方法<br>原型模式的缺点：当原型对象的属性为引用类型时，对其进行修改会反映到所有实例中。  </p>
<p>因此我们将两者结合，<strong>对象的属性使用构造函数模式创建，方法则使用原型模式创建</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    Person.prototype=&#123;</div><div class="line">        <span class="attr">constructor</span>:Person,</div><div class="line">        <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            alert(<span class="keyword">this</span>.name);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'mncu'</span>,<span class="number">120</span>);</div><div class="line">    p1.name;  <span class="comment">// 'mncu'</span></div></pre></td></tr></table></figure>
<h5 id="在原型对象上定义公用方法"><a href="#在原型对象上定义公用方法" class="headerlink" title="在原型对象上定义公用方法"></a>在原型对象上定义公用方法</h5><h5 id="在原型对象上定义数据类型"><a href="#在原型对象上定义数据类型" class="headerlink" title="在原型对象上定义数据类型"></a>在原型对象上定义数据类型</h5><p>开发中需要注意原型对象的数据是否共享。</p>
<pre><code>function Person(name){
    this.name = name
}

Person.prototype.sayName = function(){
    console.log(this.name);
}

Person.prototype.position = &quot;school&quot;;
Person.prototype.arr = [];

var person1 = new Person(&quot;xiaoming&quot;);
var person2 = new Person(&quot;Jc&quot;);

console.log(&quot;原始类型&quot;)
console.log(person1.position); // &quot;school&quot;
console.log(person2.position); // &quot;school&quot;

person1.position = 2; // 这是在当前属性设置position，引用类型同理
console.log(person1.hasOwnProperty(&quot;position&quot;)); // true
console.log(person2.hasOwnProperty(&quot;position&quot;)); // false

console.log(&quot;引用类型&quot;);
person1.arr.push(&quot;pizza&quot;); // 这是在原型对象上设置，而不是直接在对象上
person2.arr.push(&quot;quinoa&quot;); // 这是在原型对象上设置
console.log(person1.hasOwnProperty(&quot;arr&quot;)); // false
console.log(person2.hasOwnProperty(&quot;arr&quot;)); // false
console.log(person1.arr); // [&quot;pizza&quot;, &quot;quinoa&quot;]
console.log(person2.arr); // [&quot;pizza&quot;, &quot;quinoa&quot;]
</code></pre><p>上面是在原型对象上一一添加属性，下面一种更简洁的方式：以一个对象字面形式替换原型对象</p>
<pre><code>function Person(name){
    this.name
}

Person.prototype = {
    sayName: function(){
        console.log(this.name);
    },
    toString: function(){
        return &quot;[Person ]&quot; + this.name + &quot;]&quot;;
    }
}
</code></pre><p>这种方式有一种副作用：因为原型对象上具有一个 <code>constructor</code> 属性，这是其他对象实例所没有的。当一个函数被创建时，它的  <code>prototype</code> 属性也会被创建，且该原型对象的 <code>constructor</code> 属性指向该函数。当使用字面量时，因没显式设置原型对象的 <code>constructor</code> 属性，因此其 <code>constructor</code> 属性是指向 <code>Object</code> 的。<br>因此，当通过此方式设置原型对象时，可手动设置 <code>constructor</code> 属性。</p>
<pre><code>function Person(name){
    this.name
}

// 建议第一个属性就是设置其 constructor 属性。
Person.prototype = {
    constructor: Person,

    sayName: function(){
        console.log(this.name);
    },
    toString: function(){
        return &quot;[Person ]&quot; + this.name + &quot;]&quot;;
    }
}
</code></pre><p>构造函数、原型对象和对象实例之间的关系最有趣的一方面也许是：<br>对象实例和构造函数直接没有直接联系。（对象实例只有 <code>[[Prototype]]</code> 属性指向其相应的原型对象，而原型对象的 <code>constructor</code> 属性指向构造函数，而构造函数的 <code>prototype</code> 指向原型对象）<br><img src="http://7xq7nb.com1.z0.glb.clouddn.com/obj_constructor_prototype.jpg" alt="obj_constructor_prototype"></p>
<h4 id="4-2-3-改变原型对象"><a href="#4-2-3-改变原型对象" class="headerlink" title="4.2.3 改变原型对象"></a>4.2.3 改变原型对象</h4><p>因为每个对象的 <code>[[Prototype]]</code> 只是一个指向原型对象的指针，所以原型对象的改动会立刻反映到所有引用它的对象。<br>当对一个对象使用封印 <code>Object.seal()</code> 或冻结 <code>Object.freeze()</code> 时，完全是在操作对象的自有属性，但任然可以通过在原型对象上添加属性来扩展这些对象实例。</p>
<h4 id="4-2-4-内建对象（如Array、String）的原型对象"><a href="#4-2-4-内建对象（如Array、String）的原型对象" class="headerlink" title="4.2.4 内建对象（如Array、String）的原型对象"></a>4.2.4 内建对象（如Array、String）的原型对象</h4><pre><code>String.prototype.capitalize = function(){
    return this.charAt(0).toUpperCase() + this.substring(1);
}
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>构造函数就是用 <code>new</code> 操作符调用的普通函数。可用过 <code>instanceof</code> 操作符或直接访问 <code>constructor</code>(实际上是原型对象的属性) 来鉴别对象是被哪个构造函数所创建的。</li>
<li>每个函数都有一个 <code>prototype</code> 对象，它定义了该构造函数创建的所有对象共享的属性。而 <code>constructor</code> 属性实际上是定义在原型对象里，供所有对象实例共享。</li>
<li>每个对象实例都有 <code>[[Prototype]]</code> 属性，它是指向原型对象的指针。当访问对象的某个属性时，先从对象自身查找，找不到的话就到原型对象上找。</li>
<li>内建对象的原型对象也可被修改</li>
</ul>
<h2 id="5-继承"><a href="#5-继承" class="headerlink" title="5. 继承"></a>5. 继承</h2><h3 id="5-1-原型对象链和-Object-prototype"><a href="#5-1-原型对象链和-Object-prototype" class="headerlink" title="5.1 原型对象链和 Object.prototype"></a>5.1 原型对象链和 Object.prototype</h3><p>JavaScript内建的继承方法被称为 原型对象链（又叫原型对象继承）。<br>原型对象的属性可经由对象实例访问，这就是继承的一种形式。对象实例继承了原型对象的属性，而原型对象也是一个对象，它也有自己的原型对象并继承其属性，以此类推。这就是原型对象链。</p>
<p>所有对象（包括自义定的）都自动继承自 <code>Object</code>，除非你另有指定。更确切地说，所有对象都继承自 <code>Object.prototype</code>。任何以对象字面量形式定义的对象，其 <code>[[Prototype]]</code> 的值都被设为 <code>Object.prototype</code>，这意味着它继承 <code>Object.prototype</code> 的属性。</p>
<h4 id="5-1-1-继承自-Object-prototype-的方法"><a href="#5-1-1-继承自-Object-prototype-的方法" class="headerlink" title="5.1.1 继承自 Object.prototype 的方法"></a>5.1.1 继承自 Object.prototype 的方法</h4><p>Object.prototype 一般有以下几个方法</p>
<ul>
<li>hasOwnProperty()             检测是否存在一个给定名字的自有属性</li>
<li>propertyIsemumerable()       检查一个自有属性是否可枚举</li>
<li>isPrototypeOf                检查一个对象是否是另一个对象的原型对象</li>
<li>valueOf()                    返回一个对象的值表达</li>
<li>toString()                   返回一个对象的字符串表达</li>
</ul>
<p>这 5 种方法经由继承出现在所有对象中。<br>因为所有对象都默认继承自 <code>Object.prototype</code>，所以改变它就会影响所有的对象。所以不建议。</p>
<h3 id="5-2-继承"><a href="#5-2-继承" class="headerlink" title="5.2 继承"></a>5.2 继承</h3><p>对象继承是最简单的继承类型。你唯需要做的是指定哪个对象是新对象的 <code>[[Prototype]]</code>。对象字面量形式会隐式指定 <code>Object.prototype</code> 为其 <code>[[Protoype]]</code>。当然我们可以用 ES5 的 <code>Object.create()</code> 方法显式指定。该方法接受两个参数，第一个是新对象的的 <code>[[Prototype]]</code> 所指向的对象。第二个参数是可选的一个属性描述对象，其格式与 <code>Object.definePrototies()</code>一样。</p>
<pre><code>var obj = {
    name: &quot;Ljc&quot;
};

// 等同于
var obj = Object.create(Object.prototype, {
    name: {
        value: &quot;Ljc&quot;,
        configurable: true,
        enumberable: true,
        writable: true
    }
});
</code></pre><p>下面是继承其它对象：</p>
<pre><code>var person = {
    name: &quot;Jack&quot;,
    sayName: function(){
        console.log(this.name);
    }
}

var student = Object.create(person, {
    name:{
        value: &quot;Ljc&quot;
    },
    grade: {
        value: &quot;fourth year of university&quot;,
        enumerable: true,
        configurable: true,
        writable: true
    }
});

person.sayName(); // &quot;Jack&quot;
student.sayName(); // &quot;Ljc&quot;

console.log(person.hasOwnProperty(&quot;sayName&quot;)); // true
console.log(person.isPrototypeOf(student)); // true
console.log(student.hasOwnProperty(&quot;sayName&quot;)); // false
console.log(&quot;sayName&quot; in student); // true
</code></pre><p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF.jpg" alt="对象继承"></p>
<p>当访问一个对象属性时，JavaScript引擎会执行一个搜索过程。如果在对象实例存在该自有属性，则返回，否则，根据其私有属性 <code>[[Protoype]]</code> 所指向的原型对象进行搜索，找到返回，否则继承上述操作，知道继承链末端。末端通常是 <code>Object.prototype</code>，其 <code>[[Prototype]]</code> 是 <code>null</code>。</p>
<p>当然，也可以用 <code>Object.create()</code> 常见一个 <code>[[Prototype]]</code> 为 <code>null</code> 的对象。</p>
<pre><code>var obj = Object.create(null);

console.log(&quot;toString&quot; in obj); // false
</code></pre><p>该对象是一个没有原型对象链的对象，即是一个没有预定义属性的白板。</p>
<h3 id="5-3-构造函数继承"><a href="#5-3-构造函数继承" class="headerlink" title="5.3 构造函数继承"></a>5.3 构造函数继承</h3><p>JavaScript 中的对象继承也是构造函数继承的基础。<br>第四章提到，几乎所有函数都有 <code>prototype</code> 属性，它可被修改或替换。该 <code>prototype</code> 属性被自动设置为一个新的继承自 <code>Object.prototype</code> 的泛用对象，该对象(原型对象)有一个自有属性 <code>constructor</code>。实际上，JavaScript 引擎为你做了下面的事情。</p>
<pre><code>// 你写成这样
function YourConstructor(){
    // initialization
}

// JavaScript引擎在背后为你做了这些处理
YourConstructor.prototype = Object.create(Object.prototype, {
    constructor: {
        configurable: true,
        enumerable: true,
        value: YourConstructor,
        writable: true
    }
})
</code></pre><p>你不需要做额外的工作，这段代码帮你把构造函数的 <code>prototype</code> 属性设置为一个继承自 <code>Object.prototype</code> 的对象。这意味着 <code>YourConstructor</code> 创建出来的任何对象都继承自 <code>Object.prototype</code>。</p>
<p>由于 prototype 可写，你可以通过改变它来改变原型对象链。</p>
<blockquote>
<p>MDN:instanceof 运算符可以用来判断某个构造函数的 prototype 属性是否存在另外一个要检测对象的原型链上。</p>
</blockquote>
<pre><code>function Rectangle(length, width){
    this.length = length;
    this.width = width
}

Rectangle.prototype.getArea = function(){
    return this.length * this.width
}

Rectangle.prototype.toString = function(){
    return &quot;[Rectangle &quot; + this.length + &quot;x&quot; + this.width + &quot;]&quot;;
}


// inherits from Rectangle
function Square(size){
    this.length = size;
    this.width = size;
}

Square.prototype = new Rectangle(); // 尽管是 Square.prototype 是指向了 Rectangle 的对象实例，即Square的实例对象也能访问该实例的属性（如果你提前声明了该对象，且给该对象新增属性）。
// Square.prototype = Rectangle.prototype; // 这种实现没有上面这种好，因为Square.prototype 指向了 Rectangle.prototype，导致修改Square.prototype时，实际就是修改Rectangle.prototype。
console.log(Square.prototype.constructor); // 输出 Rectangle 构造函数

Square.prototype.constructor = Square; // 重置回 Square 构造函数
console.log(Square.prototype.constructor); // 输出 Square 构造函数

Square.prototype.toString = function(){
    return &quot;[Square &quot; + this.length + &quot;x&quot; + this.width + &quot;]&quot;;
}

var rect = new Rectangle(5, 10);
var square = new Square(6);

console.log(rect.getArea()); // 50
console.log(square.getArea()); // 36

console.log(rect.toString()); // &quot;[Rectangle 5 * 10]&quot;, 但如果是Square.prototype = Rectangle.prototype，则这里会&quot;[Square 5 * 10]&quot;
console.log(square.toString()); // &quot;[Square 6 * 6]&quot;

console.log(square instanceof Square); // true
console.log(square instanceof Rectangle); // true
console.log(square instanceof Object); // true
</code></pre><p><img src="http://7xq7nb.com1.z0.glb.clouddn.com/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF.jpg" alt="构造函数继承"></p>
<p><code>Square.prototype</code> 并不真的需要被改成为一个 <code>Rectangle</code> 对象。事实上，是 <code>Square.prototype</code> 需要指向 <code>Rectangle.prototype</code> 使得继承得以实现。这意味着可以用 <code>Object.create()</code> 简化例子。</p>
<pre><code>// inherits from Rectangle
function Square(size){
    this.length = size;
    this.width = size;
}

Square.prototype= Object.create(Rectangle.prototype, {
    constructor: {
        configurable: true,
        enumerable: true,
        value: Square,
        writable: true
    }
})
</code></pre><blockquote>
<p>在对原型对象添加属性前要确保你已经改成了原型对象，否则在改写时会丢失之前添加的方法（因为继承是将被继承对象赋值给需要继承的原型对象，相当于重写了需要继承的原型对象）。</p>
</blockquote>
<h3 id="5-4-构造函数窃取"><a href="#5-4-构造函数窃取" class="headerlink" title="5.4 构造函数窃取"></a>5.4 构造函数窃取</h3><p>由于JavaScript中的继承是通过原型对象链来实现的，因此不需要调用对象的父类的构造函数。如果确实需要在子类构造函数中调用父类构造函数，那就可以在子类的构造函数中利用 <code>call</code>、<code>apply</code>方法调用父类的构造函数。</p>
<pre><code>// 在上面的代码基础上作出修改
// inherits from Rectangle
function Square(size){
    Rectangle.call(this, size, size);

    // optional: add new properties or override existing ones here
}
</code></pre><p>一般来说，需要修改 <code>prototype</code> 来继承方法并用构造函数窃取来设置属性，由于这种做法模仿了那些基于类的语言的类继承，所以这通常被称为伪类继承。</p>
<h3 id="5-5-访问父类方法"><a href="#5-5-访问父类方法" class="headerlink" title="5.5 访问父类方法"></a>5.5 访问父类方法</h3><p>其实也是通过指定 <code>call</code> 或 <code>apply</code> 的子对象调用父类方法。</p>
<h2 id="6-对象模式"><a href="#6-对象模式" class="headerlink" title="6 对象模式"></a>6 对象模式</h2><h3 id="6-1-私有成员和特权成员"><a href="#6-1-私有成员和特权成员" class="headerlink" title="6.1 私有成员和特权成员"></a>6.1 私有成员和特权成员</h3><p>JavaScipt 对象的所有属性都是公有的，没有显式的方法指定某个属性不能被外界访问。</p>
<h4 id="6-1-1-模块模式"><a href="#6-1-1-模块模式" class="headerlink" title="6.1.1 模块模式"></a>6.1.1 模块模式</h4><p>模块模式是一种用于创建<strong>拥有私有数据的单件对象</strong>的模式。<br>基本做法是使用立即调用函数表达式（IIFE）来返回一个对象。原理是利用闭包。</p>
<pre><code>var yourObj = (function(){
    // private data variables

    return {
        // public methods and properties
    }
}());
</code></pre><p>模块模式还有一个变种叫暴露模块模式，它将所有的变量和方法都放在 <code>IIFE</code> 的头部，然后将它们设置到需要被返回的对象上。</p>
<pre><code>//  一般写法
var yourObj = (function(){
    var age = 25;

    return {
        name: &quot;Ljc&quot;,

        getAge: function(){
            return agel
        }
    }
}());

// 暴露模块模式
var yourObj = (function(){
    var age = 25;
    function getAge(){
        return agel
    };
    return {
        name: &quot;Ljc&quot;,
        getAge: getAge
    }
}());
</code></pre><h4 id="6-1-2-构造函数的私有成员（不能通过对象直接访问）"><a href="#6-1-2-构造函数的私有成员（不能通过对象直接访问）" class="headerlink" title="6.1.2 构造函数的私有成员（不能通过对象直接访问）"></a>6.1.2 构造函数的私有成员（不能通过对象直接访问）</h4><p>模块模式在定义单个对象的私有属性十分有效，但对于那些同样需要私有属性的自定义类型呢？你可以在构造函数中使用类似的模式来创建每个实例的私有数据。</p>
<pre><code>function Person(name){
    // define a variable only accessible inside of the Person constructor
    var age = 22;

    this.name = name;
    this.getAge = function(){
        return age;
    };
    this.growOlder = function(){
        age++;
    }
}

var person = new Person(&quot;Ljc&quot;);

console.log(person.age); // undefined
person.age = 100;
console.log(person.getAge()); // 22

person.growOlder();
console.log(person.getAge()); // 23
</code></pre><p>这里有个问题：如果你需要<strong>对象实例</strong>拥有私有数据，就不能将相应方法放在 <code>prototype</code> 上。</p>
<p>如果你需要所有实例共享私有数据。则可结合模块模式和构造函数，如下：</p>
<pre><code>var Person = (function(){
    var age = 22;

    function InnerPerson(name){
        this.name = name;
    }

    InnerPerson.prototype.getAge = function(){
        return age;
    }
    InnerPerson.prototype.growOlder = function(){
        age++;
    };

    return InnerPerson;
}());

var person1 = new Person(&quot;Nicholash&quot;);
var person2 = new Person(&quot;Greg&quot;);

console.log(person1.name); // &quot;Nicholash&quot;
console.log(person1.getAge()); // 22

console.log(person2.name); // &quot;Greg&quot;
console.log(person2.getAge()); // 22

person1.growOlder();
console.log(person1.getAge()); // 23
console.log(person2.getAge()); // 23
</code></pre><h3 id="6-2-混入"><a href="#6-2-混入" class="headerlink" title="6.2 混入"></a>6.2 混入</h3><p>这是一种伪继承。一个对象在不改变原型对象链的情况下得到了另外一个对象的属性被称为“混入”。因此，和继承不同，混入让你在创建对象后无法检查属性来源。<br>纯函数实现：</p>
<pre><code>function mixin(receiver, supplier){
    for(var property in supplier){
        if(supplier.hasOwnProperty(property)){
            receiver[property] = supplier[property];
        }
    }
}
</code></pre><p>这是浅拷贝，如果属性的值是一个引用，那么两者将指向同一个对象。</p>
<h3 id="6-3-作用域安全的构造函数"><a href="#6-3-作用域安全的构造函数" class="headerlink" title="6.3 作用域安全的构造函数"></a>6.3 作用域安全的构造函数</h3><p>构造函数也是函数，所以不用 new 也能调用它们来改变 <code>this</code> 的值。在非严格模式下， <code>this</code> 被强制指向全局对象。而在严格模式下，构造函数会抛出一个错误（因为严格模式下没有为全局对象设置 <code>this</code>，<code>this</code> 保持为 <code>undefined</code>）。<br>而很多内建构造函数，例如 <code>Array</code>、<code>RegExp</code> 不需要 <code>new</code> 也能正常工作，这是因为它们被设计为作用域安全的构造函数。<br>当用 <code>new</code> 调用一个函数时，<code>this</code> 指向的新创建的对象是属于该构造函数所代表的自定义类型。因此，可在函数内用 <code>instanceof</code> 检查自己是否被 <code>new</code> 调用。</p>
<pre><code>function Person(name){
    if(this instanceof Person){
        // called with &quot;new&quot;
    }else{
        // called without &quot;new&quot;
    }
}
</code></pre><p>具体案例：</p>
<pre><code>function Person(name){
    if(this instanceof Person){
        this.name = name;
    }else{
        return new Person(name);
    }
}
</code></pre><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>看了两天的书，做了两天的笔记。当然这只是ES5的。过几天 ES6 新书又来了。最后感谢 <a href="http://www.epubit.com.cn/" target="_blank" rel="external">异步社区</a> 送我这本好书 <a href="http://www.epubit.com.cn/book/details/1798" target="_blank" rel="external">《JavaScript面向对象精要》</a>，让我的前端根基更加稳固，希望自己的前端之路越走越顺。</p>
<hr>
<p>本文转载自 <a href="http://jcidea.cc/2016/01/20/2016-1-19-object-oriented-programming-notes/" target="_blank" rel="external">刘健超(Jc)’s Blog</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript面向对象精要》这本书虽然不够100页，但都是精华，不愧是《JavaScript高级程序设计》作者 Nicholas C.Zakas 的最新力作。&lt;/p&gt;
&lt;p&gt;下面是我的读书笔记（ES5）：&lt;/p&gt;
&lt;h2 id=&quot;1-原始类型和引用类型&quot;&gt;&lt;a href=&quot;#1-原始类型和引用类型&quot; class=&quot;headerlink&quot; title=&quot;1.原始类型和引用类型&quot;&gt;&lt;/a&gt;1.原始类型和引用类型&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是类型&quot;&gt;&lt;a href=&quot;#1-1-什么是类型&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是类型&quot;&gt;&lt;/a&gt;1.1 什么是类型&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;原始类型&lt;/strong&gt; 保存为简单数据值。&lt;br&gt;&lt;strong&gt;引用类型&lt;/strong&gt; 保存为对象，其本质是指向内存位置的引用。&lt;/p&gt;
&lt;p&gt;为了让开发者能够把原始类型和引用类型按相同的方式处理，JavaScript花费了很大的努力来保证语言的一致性。&lt;/p&gt;
&lt;p&gt;其他编程语言用栈存原始类型，用对存储引用类型。而JavaScript则完全不同：它使用一个变量对象追踪变量的生存期。原始值被直接保存在变量对象内，而引用值则作为一个指针保存在变量对象内，该指针指向实际对象在内存中的存储位置。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript面向对象" scheme="http://zhangchuanfeng.me/tags/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="读书笔记" scheme="http://zhangchuanfeng.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript面向对象核心知识归纳</title>
    <link href="http://zhangchuanfeng.me/2016/12/02/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/"/>
    <id>http://zhangchuanfeng.me/2016/12/02/JavaScript面向对象核心知识归纳/</id>
    <published>2016-12-02T01:12:54.000Z</published>
    <updated>2016-12-02T03:06:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol>
<li>面向对象就是使用对象。面向对象开发就是使用对象开发。</li>
<li>面向过程就是用过程的方式进行开发。面向对象是对面向过程的封装。</li>
</ol>
<h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="抽象性"><a href="#抽象性" class="headerlink" title="抽象性"></a>抽象性</h3><p>所谓的抽象性就是：如果需要一个对象描述数据，需要抽取这个对象的核心数据</p>
<ol>
<li>提出需要的核心属性和方法</li>
<li>不在特定的环境下无法明确对象的具体意义</li>
</ol>
<h3 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h3><p>对象是将数据与共组合到一起，即封装<br><a id="more"></a></p>
<ol>
<li>JS 对象就是键值对的集合，键值如果是数据（基本数据、符合数据、空数据）就称为属性，如果键值是函数那么就称为方法</li>
<li>对象就是将属性与方法封装起来</li>
<li>方法是将过程封装起来</li>
</ol>
<h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>所谓继承性就是自己没有但别人有，拿过来成为自己的，就是继承。继承是实现复用的一种手段</p>
<ul>
<li>在 Java 等语言中继承满足一个 class 的规则，类是一个 class，它规定了一个对象有什么属性和方法</li>
<li>在这些语言中继承是 class 之间的继承，一个 class 继承另一个 class 创建出来的对象就同时具有两个 class 的成员</li>
</ul>
<p>在 JS 中没有明确的继承语法（ES6提供了 class extend 语法），一般都是按照继承的理念实现对象的成员扩充实现继承，因此 JS 中实现继承的方法非常多。</p>
<p>传统继承基于类，JS 继承基于对象</p>
<p>一个简单的继承模式：混入（mix）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span> (<span class="params">o1,o2</span>)</span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> o2)&#123;</div><div class="line">		o1[k] = o2[k];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="关于面向对象的其他概念"><a href="#关于面向对象的其他概念" class="headerlink" title="关于面向对象的其他概念"></a>关于面向对象的其他概念</h2><h3 id="类-class：在-JS-中就是构造函数"><a href="#类-class：在-JS-中就是构造函数" class="headerlink" title="类 class：在 JS 中就是构造函数"></a>类 class：在 JS 中就是构造函数</h3><ul>
<li>在传统的面向对象语言中，使用一个叫类的东西定义模板，然后使用模板创建对象</li>
<li>在构造方法中也有类似的功能，因此也称其为类</li>
</ul>
<h3 id="实例（instance）与对象（object）"><a href="#实例（instance）与对象（object）" class="headerlink" title="实例（instance）与对象（object）"></a>实例（instance）与对象（object）</h3><ul>
<li>实例一般是指某一个构造函数创建出来的对象，我们称为 XXXX 构造函数的实例</li>
<li>实例就是对象。对象是一个泛称</li>
<li>实例与对象是一个近义词</li>
</ul>
<h3 id="键值对与属性和方法"><a href="#键值对与属性和方法" class="headerlink" title="键值对与属性和方法"></a>键值对与属性和方法</h3><ul>
<li>在 JS 中键值对的集合称为对象</li>
<li>如果值为数据（非函数），就称该键值对为属性</li>
<li>如果值为函数（方法），就称该键值对为方法 method</li>
</ul>
<h3 id="父类与子类（基类和派生类）"><a href="#父类与子类（基类和派生类）" class="headerlink" title="父类与子类（基类和派生类）"></a>父类与子类（基类和派生类）</h3><ul>
<li>传统的面向对象语言中使用类来实现继承那么就有父类、子类的概念</li>
<li>父类又称为基类，子类又称为派生类</li>
<li>在 JS 中没有类的概念，在 JS 中常常称为父对象、子对象，基对象、派生对象</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="构造函数是干什么用的"><a href="#构造函数是干什么用的" class="headerlink" title="构造函数是干什么用的"></a>构造函数是干什么用的</h3><ul>
<li>初始化数据的</li>
<li>在 JS 中给对象添加属性用的，初始化属性值用的</li>
</ul>
<h3 id="面向对象的过程"><a href="#面向对象的过程" class="headerlink" title="面向对象的过程"></a>面向对象的过程</h3><ol>
<li>代码： var p = new Person();</li>
<li>首先运算符 new 创建了一个对象，类似于{}，是一个没有任何（自定义）成员的对象<ul>
<li>使用 new 创建对象，那么对象的类型就是创建他的构造函数名</li>
<li>使用{}无论如何都是 Object 类型，相当于 new Object</li>
</ul>
</li>
<li>然后调用构造函数，为其初始化成员<ul>
<li>构造函数在调用的一开始，有一个赋值操作，即 this = 刚刚创立出来的对象</li>
<li>因此在构造函数中 this 表示刚刚创建出来的对象</li>
</ul>
</li>
<li>在构造函数中利用对象的动态特性为其对象添加成员</li>
</ol>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h3><p>域表示的就是范围，即作用域，就是一个名字在什么地方可以使用，什么地方不能使用</p>
<h3 id="JS-中词法作用域的规则"><a href="#JS-中词法作用域的规则" class="headerlink" title="JS 中词法作用域的规则"></a>JS 中词法作用域的规则</h3><ul>
<li>函数允许访问函数外部的数据</li>
<li>整个代码结构中只有函数可以限定作用域</li>
<li>作用规则首先使用提升规则分析</li>
<li>如果当前作用域中有了名字了，就不考虑外面的名字</li>
</ul>
<h3 id="属性搜索原则"><a href="#属性搜索原则" class="headerlink" title="属性搜索原则"></a>属性搜索原则</h3><ul>
<li>所谓的属性搜索原则，就是对象在访问属性或方法的时候，首先在当前对象中查找</li>
<li>如果当前对象中存储着属性或方法，停止查找，直接使用该属性或方法</li>
<li>如果当前对象没有该成员，那么再在其原型对象中查找</li>
<li>如果原型对象中含有该成员，那么停止查找，直接使用</li>
<li>如果原型中还没有，就到原型的原型中查找</li>
<li>如此往复，直到Object.protitype还没有，那么就返回undefined</li>
<li>如果是调用方法就报错，该xxx不是一个函数</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><p>闭包的含义就是闭合，包起来，简单的来说，就是一个具有封闭功能与包裹功能的结构。所谓的闭包就是一个具有封闭的对外不公开的，包裹结构，或空间。</p>
<h3 id="为什么函数可以构成闭包？"><a href="#为什么函数可以构成闭包？" class="headerlink" title="为什么函数可以构成闭包？"></a>为什么函数可以构成闭包？</h3><p>闭包就是一个具有封闭与包裹功能的结构，是为了实现具有私有访问空间的函数的。函数可以构成闭包。函数内部定义的数据函数外部无法访问，即函数具有封闭性；函数可以封装代码即具有包裹性，所以函数可以构成闭包。</p>
<h3 id="闭包有什么用"><a href="#闭包有什么用" class="headerlink" title="闭包有什么用"></a>闭包有什么用</h3><p>闭包不允许外部访问，要解决的问题就是让外部间接访问函数内部的数据。事实上，通过使用闭包，我们可以做很多事情。比如模拟面向对象的代码风格；更优雅，更简洁的表达出代码；在某些方面提升代码的执行效率。利用闭包可以实现如下需求：</p>
<ul>
<li>匿名自执行函数一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。</li>
<li>缓存闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</li>
<li>实现封装</li>
<li>模拟面向对象的代码风格</li>
</ul>
<h3 id="闭包的基本模型"><a href="#闭包的基本模型" class="headerlink" title="闭包的基本模型"></a>闭包的基本模型</h3><ul>
<li><strong>对象模式：</strong>函数内部定义个一个对象，对象中绑定多个函数（方法），返回对象，利用对象的方法访问函数内的数据</li>
<li><strong>函数模式：</strong>函数内部定义一个新函数，返回新函数，用新函数获得函数内的数据</li>
<li><strong>沙箱模式：</strong>沙箱模式就是一个自调用函数，代码写到函数中一样会执行，但是不会与外界有任何的影响</li>
</ul>
<h3 id="闭包的作用举例"><a href="#闭包的作用举例" class="headerlink" title="闭包的作用举例"></a>闭包的作用举例</h3><ul>
<li>获得超过一个数据，返回一个对象</li>
<li>完成读取一个数据和修改这个数据，对象里面的 get、set 方法</li>
</ul>
<h3 id="闭包的性能问题"><a href="#闭包的性能问题" class="headerlink" title="闭包的性能问题"></a>闭包的性能问题</h3><p>函数执行需要内存，那么函数中定义的变量，会在函数执行结束后自动回收，凡是因为闭包结构的，被引出的数据，如果还有变量引用这些数据的话，那么这些数据就不会被回收。<strong>因此在使用闭包的时候如果不使用某些数据了，一定要赋值一个null</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> num = <span class="number">123</span>;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> num;</div><div class="line">	&#125;;</div><div class="line">&#125;)();</div><div class="line"><span class="comment">// f 引用着函数，函数引用着变量num</span></div><div class="line"><span class="comment">// 因此在不使用该数据的时候，最好写上</span></div><div class="line">f = <span class="literal">null</span>;</div></pre></td></tr></table></figure>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h3><p>一句话说明什么是原型：原型能存储我们的方法，构造函数创建出来的实例对象能够引用原型中的方法。</p>
<p>JS中一切皆对象，而每个对象都有一个原型（Object除外），这个原型，大概就像Java中的父类，所以，基本上你可以认为原型就是这个对象的父对象，即每一个对象（Object除外）内部都保存了它自己的父对象，这个父对象就是原型。一般创建的对象如果没有特别指定原型，那么它的原型就是Object(这就很类似Java中所有的类默认继承自Object类)。</p>
<p>ES6通过引入class ,extends等关键字，以一种语法糖的形式把构造函数包装成类的概念，更便于大家理解。是希望开发者不再花精力去关注原型以及原型链，也充分说明原型的设计意图和类是一样的。</p>
<h3 id="查看对象的原型"><a href="#查看对象的原型" class="headerlink" title="查看对象的原型"></a>查看对象的原型</h3><p>当对象被创建之后，查看它们的原型的方法不止一种，以前一般使用对象的<code>_proto__</code>属性，ES6推出后，推荐用 Object.getPrototypeOf()方法来获取对象的原型.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = <span class="string">'lala'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</div><div class="line"><span class="built_in">console</span>.log(a.__proto__)</div><div class="line"><span class="comment">//输出：Object &#123;&#125;</span></div><div class="line">  </div><div class="line"><span class="comment">//推荐使用这种方式获取对象的原型</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(a))</div><div class="line"><span class="comment">//输出：Object &#123;&#125;</span></div></pre></td></tr></table></figure>
<p>无论对象是如何创建的，默认原型都是Object，在这里需要提及的比较特殊的一点就是，通过构造函数来创建对象，函数A本身也是一个对象，而A有两个指向表示原型的属性，分别是proto和prototype，而且两个属性并不相同</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name=<span class="string">'lala'</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> A();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(A.prototype) </div><div class="line"><span class="comment">//输出：Object &#123;&#125;</span></div><div class="line">  </div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(A.__proto__) </div><div class="line"><span class="comment">//输出：function () &#123;&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(A))</div><div class="line"><span class="comment">//输出：function () &#123;&#125;</span></div></pre></td></tr></table></figure>
<p>函数的 prototype 属性只有在当作构造函数创建的时候，把自身的 prototype 属性值赋给对象的原型。而实际上，作为函数本身，它的原型应该是function对象，然后function对象的原型才是Object。</p>
<p><strong>总之，建议使用ES6推荐的查看原型和设置原型的方法。</strong></p>
<h3 id="原型的用法"><a href="#原型的用法" class="headerlink" title="原型的用法"></a>原型的用法</h3><p>其实原型和类的继承的用法是一致的：当你想用某个对象的属性时，将当前对象的原型指向该对象，你就拥有了该对象的使用权了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name=<span class="string">'world '</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.bb=<span class="string">"hello"</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> A();</div><div class="line"></div><div class="line"><span class="keyword">var</span> b=<span class="keyword">new</span> B();</div><div class="line"><span class="comment">//将b设置为a的原型,此处有一个问题，即a的constructor也指向了B构造函数，可能需要纠正 </span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(a,b);</div><div class="line"></div><div class="line">a.constructor=A;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a.bb); <span class="comment">//hello</span></div></pre></td></tr></table></figure>
<p>如果使用ES6来做的话则简单许多，甚至不涉及到prototype这个属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</div><div class="line"></div><div class="line">     <span class="keyword">constructor</span>()&#123;</div><div class="line"></div><div class="line">         <span class="keyword">this</span>.bb=<span class="string">'hello'</span></div><div class="line"></div><div class="line">     &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</div><div class="line"></div><div class="line">     <span class="keyword">constructor</span>()&#123;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>();</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.name=<span class="string">'world'</span>;</div><div class="line"></div><div class="line">     &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">  </div><div class="line"></div><div class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> A();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a.bb+<span class="string">" "</span>+a.name); <span class="comment">//hello world   </span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(A))  <span class="comment">//"function"</span></div></pre></td></tr></table></figure>
<p>怎么样？是不是已经完全看不到原型的影子了？活脱脱就是类继承，但是你也看得到实际上类A 的类型是 function，所以说，本质上 class 在 JS 中是一种语法糖，JS 继承的本质依然是原型，不过，ES6 引入 class，extends 来掩盖原型的概念也是一个很友好的举动，对于长期学习那些类继承为基础的面对对象编程语言的程序员而言。</p>
<p><strong>尽可能理解原型，尽可能用class这种语法糖。</strong></p>
<p>好了，问自己两个问题：</p>
<ol>
<li>为什么要使用原型？ –提高函数的复用性</li>
<li>为什么属性不放在原型上而方法要放在原型上？<ul>
<li>利用对象的动态特性：构造函数.prototype.xxx = vvv</li>
<li>利用直接替换</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> Student.prototype = &#123;</div><div class="line"></div><div class="line">    <span class="attr">sayHello</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</div><div class="line"></div><div class="line">    <span class="attr">study</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h3><p>凡是对象就有原型，那么原型又是对象，因此凡是给定一个对象，那么就可以找到他的原型，原型还有原型，那么如此下去，就构成一个对象的序列，称该结构为原型链。</p>
<p>这个概念其实也变得比较简单，可以类比类的继承链条，即每个对象的原型往上追溯，一直到Object为止，这组成了一个链条，将其中的对象串联起来，当查找当前对象的属性时，如果没找到，就会沿着这个链条去查找，一直到Object，如果还没发现，就会报undefined。</p>
<h3 id="原型链的结构"><a href="#原型链的结构" class="headerlink" title="原型链的结构"></a>原型链的结构</h3><p>凡是使用构造函数，创建出对象，并且没有利用赋值的方式修改原型，就说该对象保留默认的原型链。</p>
<p>默认原型链结构是什么样子呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"><span class="comment">//p 具有默认的原型链</span></div></pre></td></tr></table></figure>
<p>默认的原型链结构就是：<em>当前对象 -&gt; 构造函数.prototype -&gt; Object.prototype -&gt; null</em></p>
<p>在实现继承的时候，有时候会利用替换原型链结构的方式实现原型继承，那么原型链结构就会发生改变</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">DunizbCollection</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">DunizbCollection.prototype = [];</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> DunizbCollection();</div></pre></td></tr></table></figure>
<p>此时arr对象的原型链结构被指向了数组对象的原型链结构了：<em>arr -&gt; [] -&gt; Array.prototype -&gt; Object.prototype -&gt; null</em></p>
<h3 id="用图形表示对象的原型链结构"><a href="#用图形表示对象的原型链结构" class="headerlink" title="用图形表示对象的原型链结构"></a>用图形表示对象的原型链结构</h3><p>以如下代码为例绘制原型链结构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<p>原型链结构图为：<br><img src="http://ww3.sinaimg.cn/large/006y8mN6jw1fac8coydvnj30hb0bo0tk.jpg" alt=""></p>
<p>使用原型需要注意两点：</p>
<ol>
<li>原型继承链条不要太长，否则会出现效率问题</li>
<li>指定原型时，注意 constructor 也会改变</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>实现继承有两种常见方式：</p>
<h4 id="混合式继承："><a href="#混合式继承：" class="headerlink" title="混合式继承："></a>混合式继承：</h4><p>最简单的继承就是将别的对象的属性强加到我身上，那么我就有这个成员了。<br>混合式继承的简单描述：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">Person.prototype.extend = <span class="function"><span class="keyword">function</span> (<span class="params"> o </span>) </span>&#123;</div><div class="line">     <span class="keyword">for</span> ( <span class="keyword">var</span> k <span class="keyword">in</span> o ) &#123;</div><div class="line">          <span class="keyword">this</span>[ k ] = o[ k ];</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line">Person.prototype.extend(&#123;</div><div class="line">      <span class="attr">run</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">'我能跑了'</span> ); &#125;,</div><div class="line">      <span class="attr">eat</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">'我可以吃了'</span> ); &#125;,</div><div class="line">      <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">'我吃饱了'</span> ); &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><p>利用原型也可以实现继承，不需要在我身上添加任何成员，只要原型有了我就有了。</p>
<h4 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h4><p>这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数，而函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在（将来）新创建的对象上执行构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"> name, age, gender </span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">        <span class="keyword">this</span>.gender = gender;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 需要提供一个 Student 的构造函数创建学生对象</span></div><div class="line"><span class="comment">// 学生也应该有 name, age, gender, 同时还需要有 course 课程</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params"> name, age, gender, course </span>) </span>&#123;</div><div class="line">        Person.call( <span class="keyword">this</span>, name, age, gender )；</div><div class="line">        <span class="keyword">this</span>.course = course;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在《JavaScript高级程序设计（第三版）》中详细介绍了继承的6种方式</p>
<h2 id="函数的四种调用模式"><a href="#函数的四种调用模式" class="headerlink" title="函数的四种调用模式"></a>函数的四种调用模式</h2><h3 id="函数模式"><a href="#函数模式" class="headerlink" title="函数模式"></a>函数模式</h3><p>就是一个简单的函数调用。函数名的前面没有任何引导内容。</p>
<h3 id="方法模式"><a href="#方法模式" class="headerlink" title="方法模式"></a>方法模式</h3><p>方法一定式依附于一个对象，将函数赋值给对象的一个属性，那么就成了方法。</p>
<h3 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h3><p>创建对象的时候构造函数做了什么？由于构造函数只是给 this 添加成员，没有做其他事情。而方法也可以完成这个操作，就是 this 而言，构造函数与方法没有本质的区别。</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ol>
<li>使用 new 关键字，来引导函数</li>
<li>构造函数中的 this 与方法中的一样，表示对象，但是构造函数中的对象是刚刚创建出来的对象</li>
<li>构造函数中不需要 return，就会默认的 return this<ul>
<li>如果手动添加return ，就相当于 return this</li>
<li>如果手动的添加 return 基本类型，无效，还是保留原来 返回 this</li>
<li>如果手动添加的 return null，或 return undefined ，无效</li>
<li>如果手动添加 return 对象类型，那么原来创建的 this 就会被丢掉，返回的是 return 后面的对象</li>
</ul>
</li>
</ol>
<h3 id="创建对象的模式"><a href="#创建对象的模式" class="headerlink" title="创建对象的模式"></a>创建对象的模式</h3><ol>
<li>工厂方法。工厂就是用来生产的，因此如果函数创建对象并返回，就称该函数为工厂函数</li>
<li>构造方法</li>
<li>寄生式创建</li>
<li>混合式创建</li>
</ol>
<h3 id="上下文调用模式"><a href="#上下文调用模式" class="headerlink" title="上下文调用模式"></a>上下文调用模式</h3><p>上下文就是环境。就是自定义设置 this 的含义</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul>
<li>函数名.apply(对象,[参数]);</li>
<li>函数名.call(对象，参数);</li>
</ul>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><ol>
<li>函数名就是表示函数本身，使用函数进行调用的时候默认 this 是全局变量</li>
<li>函数名也可以是方法提供，使用方法调用的时候，this 是指向当前对象</li>
<li>使用 apply 进行调用后，无论是函数还是方法都无效了，我们的 this ，由 apply 的第一个参数决定</li>
</ol>
<h4 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h4><p>无论是 call 还是 apply 在没有后面的参数的情况下（函数无参数，方法无参数）是完全一致的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span> );</div><div class="line">&#125;</div><div class="line">foo.apply( obj );</div><div class="line">foo.call( obj );</div></pre></td></tr></table></figure>
<p>第一个参数的使用也是有规则的:</p>
<p>1.如果传入的是一个对象，那么就相当于设置该函数中的 this 为参数</p>
<p>2.如果不传入参数，或传入 null 、undefined 等，那么相当于 this 默认为 window</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">foo();</div><div class="line">foo.apply();</div><div class="line">foo.apply( <span class="literal">null</span> );</div><div class="line">foo.call( <span class="literal">undefined</span> );</div></pre></td></tr></table></figure>
<p>3.如果传入的是基本类型，那么 this 就是基本类型对应的包装类型的引用<br>在使用上下文调用的时候，原函数（方法）可能会带有参数，那么这个参数再上下文调用中使用 第二个（第 n 个）参数来表示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"> num </span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( num );</div><div class="line">&#125;</div><div class="line">foo.apply( <span class="literal">null</span>, [ <span class="number">123</span> ] );</div><div class="line"><span class="comment">// 等价于</span></div><div class="line">foo( <span class="number">123</span> );</div></pre></td></tr></table></figure>
<hr>
<p><strong>参考资料</strong></p>
<ul>
<li>本文原型部分部分引用自<a href="http://www.admin10000.com/document/9336.html" target="_blank" rel="external">《JavaScript原型详解》</a>，版权归原作者所有</li>
<li><a href="http://blog.csdn.net/sunlylorn/article/details/6534610" target="_blank" rel="external">js闭包的用途</a></li>
</ul>
<hr>
<p>本文首发于 <a href="http://www.imooc.com/u/173711/articles" target="_blank" rel="external">慕课网</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;面向对象就是使用对象。面向对象开发就是使用对象开发。&lt;/li&gt;
&lt;li&gt;面向过程就是用过程的方式进行开发。面向对象是对面向过程的封装。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;三大特性&quot;&gt;&lt;a href=&quot;#三大特性&quot; class=&quot;headerlink&quot; title=&quot;三大特性&quot;&gt;&lt;/a&gt;三大特性&lt;/h2&gt;&lt;h3 id=&quot;抽象性&quot;&gt;&lt;a href=&quot;#抽象性&quot; class=&quot;headerlink&quot; title=&quot;抽象性&quot;&gt;&lt;/a&gt;抽象性&lt;/h3&gt;&lt;p&gt;所谓的抽象性就是：如果需要一个对象描述数据，需要抽取这个对象的核心数据&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提出需要的核心属性和方法&lt;/li&gt;
&lt;li&gt;不在特定的环境下无法明确对象的具体意义&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;封装性&quot;&gt;&lt;a href=&quot;#封装性&quot; class=&quot;headerlink&quot; title=&quot;封装性&quot;&gt;&lt;/a&gt;封装性&lt;/h3&gt;&lt;p&gt;对象是将数据与共组合到一起，即封装&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript面向对象" scheme="http://zhangchuanfeng.me/tags/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>跨域-知识</title>
    <link href="http://zhangchuanfeng.me/2016/11/24/%E8%B7%A8%E5%9F%9F-%E7%9F%A5%E8%AF%86/"/>
    <id>http://zhangchuanfeng.me/2016/11/24/跨域-知识/</id>
    <published>2016-11-24T12:18:56.000Z</published>
    <updated>2016-11-25T01:28:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章目录：</p>
<ul>
<li><a href="http://www.cnblogs.com/scottckt/archive/2011/11/12/2246557.html" target="_blank" rel="external">跨域-知识</a>  </li>
<li><a href="http://www.cnblogs.com/scottckt/archive/2011/11/12/2246557.html" target="_blank" rel="external">跨域-使用 JSONP</a>  </li>
<li><a href="http://www.cnblogs.com/scottckt/archive/2011/11/12/2246749.html" target="_blank" rel="external">跨域-使用 js 文件</a></li>
<li><a href="http://www.cnblogs.com/scottckt/archive/2011/11/12/2246787.html" target="_blank" rel="external">跨域-使用 window.name</a></li>
<li><a href="http://www.cnblogs.com/scottckt/archive/2011/11/12/2246793.html" target="_blank" rel="external">跨域-使用 Proxy page 或 Cross Frame</a></li>
</ul>
<hr>
<h2 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h2><p>  跨域可简单理解为 JavaScript 同源策略的限制。</p>
<h2 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h2><p>在客户端编程语言中，如JavaScript和ActionScript，同源策略是一个很重要的安全理念，它在保证数据的安全性方面有着重要的意义。同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。那么什么叫相同域，什么叫不同的域呢？当两个域具有相同的协议(如http), 相同的端口(如80)，相同的host（如www.example.org)，那么我们就可以认为它们是相同的域。<br><a id="more"></a><br>比如 <a href="http://www.example.org/index.html和http://www.example.org/sub/index.html是同域，而http://www.example.org" target="_blank" rel="external">http://www.example.org/index.html和http://www.example.org/sub/index.html是同域，而http://www.example.org</a>, <a href="https://www.example.org" target="_blank" rel="external">https://www.example.org</a>, <a href="http://www.example.org:8080" target="_blank" rel="external">http://www.example.org:8080</a>, <a href="http://sub.example.org中的任何两个都将构成跨域。同源策略还应该对一些特殊情况做处理，比如限制file协议下脚本的访问权限。本地的HTML文件在浏览器中是通过file协议打开的，如果脚本能通过file协议访问到硬盘上其它任意文件，就会出现安全隐患，目前IE8还有这样的隐患。" target="_blank" rel="external">http://sub.example.org中的任何两个都将构成跨域。同源策略还应该对一些特殊情况做处理，比如限制file协议下脚本的访问权限。本地的HTML文件在浏览器中是通过file协议打开的，如果脚本能通过file协议访问到硬盘上其它任意文件，就会出现安全隐患，目前IE8还有这样的隐患。</a><br>受到同源策略的影响，跨域资源共享就会受到制约。但是随着人们的实践和浏览器的进步，目前在跨域请求的技巧上，有很多宝贵经验的沉淀和积累。这里我把跨域资源共享分成两种，一种是单向的数据请求，还有一种是双向的消息通信。</p>
<p> 详细情况请看下表：<br> <img src="http://ww3.sinaimg.cn/large/65e4f1e6jw1fa3gxszn3mj20he0fnmzb.jpg" alt=""></p>
<h2 id="单向跨域"><a href="#单向跨域" class="headerlink" title="单向跨域"></a>单向跨域</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP (JSON with Padding)是一个简单高效的跨域方式，HTML中的script标签可以加载并执行其他域的JavaScript，于是我们可以通过script标记来动态加载其他域的资源。例如我要从域A的页面pageA加载域B的数据，那么在域B的页面pageB中我以JavaScript的形式声明pageA 需要的数据，然后在pageA中用script标签把pageB加载进来，那么pageB中的脚本就会得以执行。JSONP在此基础上加入了回调函数，pageB加载完之后会执行pageA中定义的函数，所需要的数据会以参数的形式传递给该函数。JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。但是在受信任的双方传递数据，JSONP是非常合适的选择。</p>
<h3 id="Flash-URLLoader"><a href="#Flash-URLLoader" class="headerlink" title="Flash URLLoader"></a>Flash URLLoader</h3><p>Flash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。当跨域访问资源时，例如从域www.a.com请求域www.b.com上的数据，我们可以借助Flash来发送 HTTP请求。首先，修改域www.b.com上的crossdomain.xml(一般存放在根目录，如果没有需要手动创建) ，把www.a.com加入到白名单。其次，通过Flash URLLoader发送HTTP请求，最后，通过Flash API把响应结果传递给JavaScript。Flash URLLoader是一种很普遍的跨域解决方案，不过需要支持iOS的话，这个方案就无能为力了。</p>
<h3 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h3><p>Access Control是比较超越的跨域方式，目前只在很少的浏览器中得以支持，这些浏览器可以发送一个跨域的HTTP请求（Firefox, Google Chrome等通过XMLHTTPRequest实现，IE8下通过XDomainRequest实现），请求的响应必须包含一个Access- Control-Allow-Origin的HTTP响应头，该响应头声明了请求域的可访问权限。例如www.a.com对www.b.com下的 asset.php发送了一个跨域的HTTP请求，那么asset.php必须加入如下的响应头：header(“Access-Control-Allow-Origin: <a href="http://www.a.com%22);%7f/" target="_blank" rel="external">http://www.a.com%22);%7f/</a></p>
<h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><p>window对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。那么我们可以在页面A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给 window.name，iframe加载完成之后，页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出window.name的值了。这个方式非常适合单向的数据请求，而且协议简单、安全。不会像JSONP那样不做限制地执行外部脚本。</p>
<h3 id="server-proxy"><a href="#server-proxy" class="headerlink" title="server proxy"></a>server proxy</h3><p>在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。例如当www.a.com域下的页面需要请求www.b.com下的资源文件asset.txt时，直接发送一个指向 www.b.com/asset.txt的ajax请求肯定是会被浏览器阻止。这时，我们在www.a.com下配一个代理，然后把ajax请求绑定到这个代理路径下，例如www.a.com/proxy/, 然后这个代理发送HTTP请求访问<a href="http://www.b.com/下的asset.txt，跨域的HTTP请求是在服务器端进行的，客户端并没有产生跨域的ajax请求。这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。" target="_blank" rel="external">http://www.b.com/下的asset.txt，跨域的HTTP请求是在服务器端进行的，客户端并没有产生跨域的ajax请求。这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。</a></p>
<h2 id="双向跨域"><a href="#双向跨域" class="headerlink" title="双向跨域"></a>双向跨域</h2><h3 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h3><p>通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。同域策略认为域和子域隶属于不同的域，比如 www.a.com和sub.a.com是不同的域，这时，我们无法在www.a.com下的页面中调用sub.a.com中定义的JavaScript 方法。但是当我们把它们document的domain属性都修改为a.com，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的 method来通信了。</p>
<h3 id="FIM-–-Fragment-Identitier-Messaging"><a href="#FIM-–-Fragment-Identitier-Messaging" class="headerlink" title="FIM – Fragment Identitier Messaging"></a>FIM – Fragment Identitier Messaging</h3><p>不同的域之间，JavaScript只能做很有限的访问和操作，其实我们利用这些有限的访问权限就可以达到跨域通信的目的了。FIM (Fragment Identitier Messaging)就是在这个大前提下被发明的。父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为frag，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带frag，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。FIM的原理就是改变URL的frag部分来进行双向通信。每个window通过改变其他 window的location来发送消息，并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，URL在浏览器下有长度限制，这个制约了每次传送的数据量。</p>
<h3 id="Flash-LocalConnection"><a href="#Flash-LocalConnection" class="headerlink" title="Flash LocalConnection"></a>Flash LocalConnection</h3><p>页面上的双向通信也可以通过Flash来解决，Flash API中有LocalConnection这个类，该类允许两个SWF之间通过进程通信，这时SWF可以播放在独立的Flash Player或者AIR中，也可以嵌在HTML页面或者是PDF中。遵循这个通信原则，我们可以在不同域的HTML页面各自嵌套一个SWF来达到相互传递数据的目的了。SWF通过LocalConnection交换数据是很快的，但是每次的数据量有40kb的大小限制。用这种方式来跨域通信过于复杂，而且需要了2个SWF文件，实用性不强。</p>
<h3 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h3><p>window.postMessage是HTML5定义的一个很新的方法，这个方法可以很方便地跨window通信。由于它是一个很新的方法，所以在很旧和比较旧的浏览器中都无法使用。</p>
<h3 id="Cross-Frame"><a href="#Cross-Frame" class="headerlink" title="Cross Frame"></a>Cross Frame</h3><p>Cross Frame是FIM的一个变种，它借助了一个空白的iframe，不会产生多余的浏览器历史记录，也不需要轮询URL的改变，在可用性和性能上都做了很大的改观。它的基本原理大致是这样的，假设在域www.a.com上有页面A.html和一个空白代理页面proxyA.html, 另一个域www.b.com上有个页面B.html和一个空白代理页面proxyB.html，A.html需要向B.html中发送消息时，页面会创建一个隐藏的iframe, iframe的src指向proxyB.html并把message作为URL frag，由于B.html和proxyB.html是同域，所以在iframe加载完成之后，B.html可以获得iframe的URL，然后解析出 message，并移除该iframe。当B.html需要向A.html发送消息时，原理一样。Cross Frame是很好的双向通信方式，而且安全高效，但是它在Opera中无法使用，不过在Opera下面我们可以使用更简单的 window.postMessage来代替。</p>
<p>本文参考文章：<br><a href="">http://www.cnblogs.com/scottckt/archive/2011/11/12/2246531.html</a></p>
<p><a href="">http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html</a></p>
<p><a href="">http://www.cnblogs.com/cat3/archive/2011/06/15/2081559.html</a></p>
<hr>
<p>相关文章：</p>
<p><a href="https://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html" target="_blank" rel="external">JavaScript跨域总结与解决办法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/scottckt/archive/2011/11/12/2246557.html&quot;&gt;跨域-知识&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/scottckt/archive/2011/11/12/2246557.html&quot;&gt;跨域-使用 JSONP&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/scottckt/archive/2011/11/12/2246749.html&quot;&gt;跨域-使用 js 文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/scottckt/archive/2011/11/12/2246787.html&quot;&gt;跨域-使用 window.name&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/scottckt/archive/2011/11/12/2246793.html&quot;&gt;跨域-使用 Proxy page 或 Cross Frame&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;什么是跨域？&quot;&gt;&lt;a href=&quot;#什么是跨域？&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域？&quot;&gt;&lt;/a&gt;什么是跨域？&lt;/h2&gt;&lt;p&gt;  跨域可简单理解为 JavaScript 同源策略的限制。&lt;/p&gt;
&lt;h2 id=&quot;什么是同源策略&quot;&gt;&lt;a href=&quot;#什么是同源策略&quot; class=&quot;headerlink&quot; title=&quot;什么是同源策略&quot;&gt;&lt;/a&gt;什么是同源策略&lt;/h2&gt;&lt;p&gt;在客户端编程语言中，如JavaScript和ActionScript，同源策略是一个很重要的安全理念，它在保证数据的安全性方面有着重要的意义。同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。那么什么叫相同域，什么叫不同的域呢？当两个域具有相同的协议(如http), 相同的端口(如80)，相同的host（如www.example.org)，那么我们就可以认为它们是相同的域。&lt;br&gt;
    
    </summary>
    
    
      <category term="跨域" scheme="http://zhangchuanfeng.me/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSS 布局</title>
    <link href="http://zhangchuanfeng.me/2016/11/23/CSS%E5%B8%83%E5%B1%80/"/>
    <id>http://zhangchuanfeng.me/2016/11/23/CSS布局/</id>
    <published>2016-11-23T12:40:31.000Z</published>
    <updated>2016-11-24T12:47:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天偶然发现 <a href="http://zh.learnlayout.com" target="_blank" rel="external">学习 CSS 布局</a> 这个网站，又从头到尾把 CSS 布局有关的知识梳理了一遍，做成了下面的思维导图。</p>
<a id="more"></a>
<p><img src="http://ww4.sinaimg.cn/large/65e4f1e6jw1fa3hgr3kwdj20w40rn0ug.jpg" alt=""></p>
<p>通过梳理，发现自己对 Flex 布局还不了解，谷歌后发现阮一峰大大的教程不错，打算跟着学习一下。</p>
<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">Flex 布局教程：语法篇</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="external">Flex 布局教程：实例篇</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天偶然发现 &lt;a href=&quot;http://zh.learnlayout.com&quot;&gt;学习 CSS 布局&lt;/a&gt; 这个网站，又从头到尾把 CSS 布局有关的知识梳理了一遍，做成了下面的思维导图。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="http://zhangchuanfeng.me/tags/CSS/"/>
    
      <category term="布局" scheme="http://zhangchuanfeng.me/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>如何在短时间内掌握一项技能--知乎 Live</title>
    <link href="http://zhangchuanfeng.me/2016/11/22/%E5%A6%82%E4%BD%95%E5%9C%A8%E7%9F%AD%E6%97%B6%E9%97%B4%E5%86%85%E6%8E%8C%E6%8F%A1%E4%B8%80%E9%A1%B9%E6%8A%80%E8%83%BD--%E7%9F%A5%E4%B9%8E%20Live/"/>
    <id>http://zhangchuanfeng.me/2016/11/22/如何在短时间内掌握一项技能--知乎 Live/</id>
    <published>2016-11-22T10:24:48.000Z</published>
    <updated>2016-11-23T06:50:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Live-简介"><a href="#Live-简介" class="headerlink" title="Live 简介"></a>Live 简介</h2><p>我是 Scott Young ，一位因为快速学习而成名的神奇小子，应用自己发明的学习方法，完成了 10 天搞定线性代数、 1 年学习 4 年 MIT 课程的「不可能任务」，最近又在尝试一年学习四门外语（包括中文哦），经营着世界上最大的学习博客之一。从高中开始，我几乎课下不学习，尽管如此，还是以全班第 2 名的成绩毕业。读大学时，大考之前一般每天学习不过两个小时。不过， 4 年来，平均成绩总在 A 和 A+ 之间。毕业后登上 TEDx 的演讲台，向全世界宣讲自己的学习经验，是不折不扣的超级学霸。</p>
<p>本次 Live 我将带来对高效学习的更多心得，以及泛学习领域的各种心得，高效率的学习能够带给我们生活、工作更多的改变。</p>
<p>本次 Live 主要包括以下问题：</p>
<ul>
<li>如何高效学习？  </li>
<li>如何改变习惯？</li>
<li>在办公室外如何思考？</li>
<li>超效率手册是什么？  </li>
</ul>
<h2 id="Live-笔记思维导图"><a href="#Live-笔记思维导图" class="headerlink" title="Live 笔记思维导图"></a>Live 笔记思维导图</h2><p><img src="http://ww3.sinaimg.cn/large/006tNc79jw1fa14x5jhh0j30qc0h1ab5.jpg" alt=""></p>
<blockquote>
<p>通过视频和主题阅读来建立一个知识体系，形成知识地图，通过对基础概念和知识点的深入理解构建知识体系的主体框架，理论来说就是用80%的时间和精力集中在20%最重要的知识点上。同时需要把新学到的知识点跟大脑中以前的知识点做好连接。并根据每节课的学习进度进行实时反馈测试掌握情况，找出理解中的弱点进行补充完善。最后通过合理的记忆和复习技巧对知识点进行巩固。<br>作者：warfalcon<br>链接：<a href="https://www.zhihu.com/question/20571226/answer/15516872" target="_blank" rel="external">https://www.zhihu.com/question/20571226/answer/15516872</a><br>来源：知乎<br>著作权归作者所有，转载请联系作者获得授权。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Live-简介&quot;&gt;&lt;a href=&quot;#Live-简介&quot; class=&quot;headerlink&quot; title=&quot;Live 简介&quot;&gt;&lt;/a&gt;Live 简介&lt;/h2&gt;&lt;p&gt;我是 Scott Young ，一位因为快速学习而成名的神奇小子，应用自己发明的学习方法，完成了 1
    
    </summary>
    
    
      <category term="方法论" scheme="http://zhangchuanfeng.me/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>hexo 命令及 Markdown 语法</title>
    <link href="http://zhangchuanfeng.me/2016/11/20/hexo-%E5%91%BD%E4%BB%A4%E5%8F%8A-Markdown-%E8%AF%AD%E6%B3%95/"/>
    <id>http://zhangchuanfeng.me/2016/11/20/hexo-命令及-Markdown-语法/</id>
    <published>2016-11-20T02:58:50.000Z</published>
    <updated>2016-11-20T06:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><p>Hexo是使用 Markdown 编辑文章的，我写的这些文章也都是用这种标记语言完成的。所以，我们先从 Markdown 说起。</p>
<ul>
<li>什么是 Markdown</li>
<li>Markdown 语法</li>
<li>实战</li>
</ul>
<p>你可以使用 vim 工具直接编辑 .md 文件，也可以用记事本打开 .md 文件编辑你的文章，也可以 Markdown 的编辑器编写——这就是 Markdown 的特别之处，它不像 .doc 一样需要专门的软件打开。我是Mac系统，用的一个叫 MacDown 的编辑器，还比较好用。关于 Markdown 编辑器的选择，你可以查看以下文章：</p>
<ul>
<li><a href="http://www.jianshu.com/p/6ea395a6a35b" target="_blank" rel="external">Markdown编辑器一览,总有一款适合你</a></li>
</ul>
<h3 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h3><blockquote>
<p>Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯和亚伦·斯沃茨。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML文档”。 ——维基百科</p>
</blockquote>
<p>下面简单介绍一下 Markdown 的语法，具体使用相信您看到例子机会明白了。<br><a id="more"></a></p>
<h3 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h3><p><strong>1、 分段：</strong> <code>两个回车</code><br><strong>2、 换行：</strong> <code>两个空格 + 回车</code><br><strong>3、标题：</strong> <code>#</code>~<code>######</code> 井号的个数代表几级标题<br><strong>4、引用：</strong> <code>&gt;</code><br><strong>5、列表</strong> <code>*</code>,<code>+</code>,<code>-</code>,<code>1.</code> 均可，注意其后有个空格<br><strong>6、代码：</strong> 只有一行，用`将语句包起来。如果为多行，可以将```置于这段代码的首行和末行。<br><strong>7、链接：</strong> <code>[文字](链接地址)</code><br><strong>8：图片</strong> <code>![图片说明](图片链接)</code> ，图片链接可以是本地路径，也可以是网络地址<br><strong>9、强调：</strong> <code>**文字**</code>，<code>__文字__</code>，<code>_文字_</code><br><strong>10、斜体：</strong> <code>*文字*</code></p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>光看不练假本身，动手看看效果吧！<br>在线编辑器例文： <a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">传送门</a><br>MacDown 编辑器： <a href="http://macdown.uranusjr.com" target="_blank" rel="external">下载地址</a></p>
<h2 id="Hexo-常用命令"><a href="#Hexo-常用命令" class="headerlink" title="Hexo 常用命令"></a>Hexo 常用命令</h2><p><strong>1、新建</strong>  </p>
<pre><code>hexo new &quot;new post&quot;    
</code></pre><p>新建的文件在<code>hexo/source/_posts/new-post.md</code>，可前往打开编辑</p>
<p><strong>2、 编译</strong>  </p>
<pre><code>hexo g 
</code></pre><p>一般部署前都要编译一下，将所有的 .md 文件编译成 .html 文件并储存在<code>public</code> 文件夹  </p>
<p><strong>3、开启本地服务</strong>  </p>
<pre><code>hexo s  
</code></pre><p>开启本地服务后，就可以通过<code>http://localhost:4000/</code> 访问你的博客</p>
<p><strong>4、部署</strong></p>
<pre><code>hexo d  
</code></pre><p>部署到 git 等</p>
<p><strong>5、清除缓存</strong></p>
<pre><code>hexo c  
</code></pre><p>当<code>source</code>文件夹中的部分资源更改过之后，特别是对文件进行了删除或者路径的改变之后，需要执行这个命令，然后重新编译。</p>
<p>以上这些都是我在使用过程中经常用到的一些hexo命令。最为详细、最为全面的说明文档当然还是在<a href="http://zespia.tw/hexo/docs/commands.html" target="_blank" rel="external">官网</a>。请各位猛戳。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇博文介绍了常用的 Hexo 命令和 Markdown 语法，多练习多使用方能掌握~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Markdown&quot;&gt;&lt;a href=&quot;#Markdown&quot; class=&quot;headerlink&quot; title=&quot;Markdown&quot;&gt;&lt;/a&gt;Markdown&lt;/h2&gt;&lt;p&gt;Hexo是使用 Markdown 编辑文章的，我写的这些文章也都是用这种标记语言完成的。所以，我们先从 Markdown 说起。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是 Markdown&lt;/li&gt;
&lt;li&gt;Markdown 语法&lt;/li&gt;
&lt;li&gt;实战&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以使用 vim 工具直接编辑 .md 文件，也可以用记事本打开 .md 文件编辑你的文章，也可以 Markdown 的编辑器编写——这就是 Markdown 的特别之处，它不像 .doc 一样需要专门的软件打开。我是Mac系统，用的一个叫 MacDown 的编辑器，还比较好用。关于 Markdown 编辑器的选择，你可以查看以下文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/6ea395a6a35b&quot;&gt;Markdown编辑器一览,总有一款适合你&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;什么是-Markdown&quot;&gt;&lt;a href=&quot;#什么是-Markdown&quot; class=&quot;headerlink&quot; title=&quot;什么是 Markdown&quot;&gt;&lt;/a&gt;什么是 Markdown&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯和亚伦·斯沃茨。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML文档”。 ——维基百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面简单介绍一下 Markdown 的语法，具体使用相信您看到例子机会明白了。&lt;br&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://zhangchuanfeng.me/tags/hexo/"/>
    
      <category term="markdown" scheme="http://zhangchuanfeng.me/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>11.14-11.16 回家之行</title>
    <link href="http://zhangchuanfeng.me/2016/11/17/11-14-11-16-%E5%9B%9E%E5%AE%B6%E4%B9%8B%E8%A1%8C/"/>
    <id>http://zhangchuanfeng.me/2016/11/17/11-14-11-16-回家之行/</id>
    <published>2016-11-17T11:53:25.000Z</published>
    <updated>2016-11-17T11:57:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么回家"><a href="#为什么回家" class="headerlink" title="为什么回家"></a>为什么回家</h2><ol>
<li>去银行办点事</li>
<li>碰巧姐姐和外甥女在家，而且我们很长时间没见了</li>
<li>表妹正好也回家，顺路    </li>
</ol>
<h2 id="回家做了什么"><a href="#回家做了什么" class="headerlink" title="回家做了什么"></a>回家做了什么</h2><a id="more"></a>
<ol>
<li>银行的事情处理完毕</li>
<li>见了姐姐和外甥女，三天相处蛮愉快</li>
<li>见了表妹和她好朋友（maybe GF…）</li>
<li>帮伯伯把台式电脑从新房运到了老家并组装好，维护了系统，顺便谈妥寒假借房学习的事宜。</li>
</ol>
<h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><ol>
<li>去的工商银行办事效率太慢，两次去柜员都是五六十岁的中老年人，一会儿喝点水，一会儿泡点茶，不紧不慢，让人捉急</li>
<li>外甥女会说简单的话了，听到她叫“舅舅”时我十分兴奋。问她吃饭吗，她说“吃”；问她这（坏事）是你干的吗？回答“不是”，太有意思了。我们开玩笑说得把她当成人看了</li>
<li>之前不太了解伯伯，这次又有新的发现。首先伯伯注重仪表，给人一种给体面的感觉，让人肃然起敬；其次，在伯伯的书架上看到孙子兵法全集，还有一些其他的书，要知道伯伯平时非常忙，看不看书我不知道，但起码有这个心态；再次，事分轻重，理解并支持子女。总之伯伯给我的感觉就是一个优秀的人。</li>
<li>据说嫂子怀孕两个月了，哥哥也去了中国农业大学做博士后，工作两年后全家都会有北京户口，基本在北京扎根了。哥哥从小就充满青春气息。记得小时候他早晨起来在院里吼几嗓子，我也跟着吼。他在社交网络上也表现得积极向上。如今这般功成名就，努力获得回报，真是让人开心</li>
<li>关于<strong>健康</strong> 回家后得知二姨夫胃癌晚期，想不到这种事会发生在自己的亲戚身上。我刚开始很惊讶，后来想起来二姨夫经常吃热腾腾的食物，比如饺子。刚出锅的饺子，别人都不敢动口，二姨夫就狼吞虎咽地吃掉，还因此出名。在跟爸爸的交流中我发现我们和另一个衣服的想法不谋而合：可能这不是主要病因，但这绝对有影响。近期健康出问题的还有姐姐的婆婆，突发脑溢血晕倒，在医院快一个月了还有半边身子不太会动。所以关于健康，年轻时珍惜身体，不要太拼；年老时每年体检，及时发现问题。像以上两位，病情严重前都有感觉的，只不过他们或许是不在意， 或许是不舍得花钱、不想让亲人担心，所以都拖到了不能再拖的情况。</li>
</ol>
<h2 id="迷茫和不安"><a href="#迷茫和不安" class="headerlink" title="迷茫和不安"></a>迷茫和不安</h2><p>眼看秋招就快结束了，还没有找到工作，究其原因还是我不想将就本专业的工作，而对于前端开发的工作还没有达到任职要求。我需要时间，去细嚼慢咽，去仔细品味。</p>
<p><em>我虽然走地慢，但我不曾停下脚步。</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么回家&quot;&gt;&lt;a href=&quot;#为什么回家&quot; class=&quot;headerlink&quot; title=&quot;为什么回家&quot;&gt;&lt;/a&gt;为什么回家&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;去银行办点事&lt;/li&gt;
&lt;li&gt;碰巧姐姐和外甥女在家，而且我们很长时间没见了&lt;/li&gt;
&lt;li&gt;表妹正好也回家，顺路    &lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;回家做了什么&quot;&gt;&lt;a href=&quot;#回家做了什么&quot; class=&quot;headerlink&quot; title=&quot;回家做了什么&quot;&gt;&lt;/a&gt;回家做了什么&lt;/h2&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://zhangchuanfeng.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>腾讯公益404页面无法返回自己首页的解决办法</title>
    <link href="http://zhangchuanfeng.me/2016/11/13/%E8%85%BE%E8%AE%AF%E5%85%AC%E7%9B%8A404%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E8%BF%94%E5%9B%9E%E8%87%AA%E5%B7%B1%E9%A6%96%E9%A1%B5%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://zhangchuanfeng.me/2016/11/13/腾讯公益404页面无法返回自己首页的解决办法/</id>
    <published>2016-11-13T09:23:27.000Z</published>
    <updated>2016-11-13T09:42:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯公益404页面是个非常好的想法，<a href="http://www.qq.com/404/" target="_blank" rel="external">官方页面</a>说明如下：<br><img src="http://ww4.sinaimg.cn/large/006y8lVajw1f9qlzvnua2j30rb0kpq6c.jpg" alt=""><br>更人性化的一点是，其提供“返回腾讯网”超链接的可定制化能力，只需要修改两个参数即可：<br><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f9qm1cf8nwj30qu0k4tbl.jpg" alt=""><br>然而博主按照说明修改了两个参数，超链接文字却没有发生改变——依然是“返回腾讯网”，经一番搜索，终于找到了解决方法：<br><a id="more"></a><br>复制<a href="https://github.com/songjinzhong/404html/blob/master/404.html" target="_blank" rel="external">该页面</a>提供的代码到本地，然后修改第11行和第113行的参数为你的即可。效果如下：<br><img src="http://ww1.sinaimg.cn/large/006y8lVajw1f9qm85vlimj30ul0le78e.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;腾讯公益404页面是个非常好的想法，&lt;a href=&quot;http://www.qq.com/404/&quot;&gt;官方页面&lt;/a&gt;说明如下：&lt;br&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006y8lVajw1f9qlzvnua2j30rb0kpq6c.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;更人性化的一点是，其提供“返回腾讯网”超链接的可定制化能力，只需要修改两个参数即可：&lt;br&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/006y8lVajw1f9qm1cf8nwj30qu0k4tbl.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;然而博主按照说明修改了两个参数，超链接文字却没有发生改变——依然是“返回腾讯网”，经一番搜索，终于找到了解决方法：&lt;br&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://zhangchuanfeng.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>域名申请与解析</title>
    <link href="http://zhangchuanfeng.me/2016/11/13/%E5%9F%9F%E5%90%8D%E7%94%B3%E8%AF%B7%E4%B8%8E%E8%A7%A3%E6%9E%90/"/>
    <id>http://zhangchuanfeng.me/2016/11/13/域名申请与解析/</id>
    <published>2016-11-13T04:10:36.000Z</published>
    <updated>2016-11-13T07:10:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="域名申请与解析"><a href="#域名申请与解析" class="headerlink" title="域名申请与解析"></a>域名申请与解析</h1><h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>个人博客的网址是 github.io 一类的网址未免普通（Bigger 不够），而博主想正好借这次机会体验一下购买域名的流程，所以就开始选服务商啦！<br><a id="more"></a></p>
<h2 id="域名服务商的选择"><a href="#域名服务商的选择" class="headerlink" title="域名服务商的选择"></a>域名服务商的选择</h2><p>godaddy 口碑不错，推荐的人挺多，博主刚开始在上面选择好了域名，到了结算时，发现还有 WhoisGuard （涉及域名所有人的隐私）需要考虑，而 godaddy 一年的费用要70￥，博主又去选别的服务商了（学生党…）去知乎转了一圈发现 namecheap 口碑也不错，而且<a href="https://www.domcomp.com/?refcode=582684121300007f36f19420" target="_blank" rel="external">domcomp</a> 还有返利，于是就选择了它。</p>
<h2 id="域名申请步骤"><a href="#域名申请步骤" class="headerlink" title="域名申请步骤"></a>域名申请步骤</h2><p>首先去<a href="https://www.domcomp.com/?refcode=582684121300007f36f19420" target="_blank" rel="external">domcomp</a> </p>
<p><img src="http://ww4.sinaimg.cn/large/006y8lVajw1f9qb7umgf0j312i0ez77u.jpg" alt=""></p>
<p>在列表中选择 <em>Namecheap</em>，跳转到 Namecheap 主页，然后在搜索框中输入自己想要的域名（可不带后缀）</p>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f9qbayg3wbj312h0dhjz4.jpg" alt=""></p>
<p>点击 <em>Search</em>，可以看到各种不同后缀的域名搜索结果</p>
<p><img src="http://ww3.sinaimg.cn/large/006y8lVajw1f9qbctqr1fj30s80m3dio.jpg" alt=""></p>
<p>选择一个自己满意的，点击灰色的购物车图标即可添加到购物车（关于价格，博主购买一年期，价格就是黑色字体的价格），然后查看购物车</p>
<p><img src="http://ww4.sinaimg.cn/large/006y8lVajw1f9qbgdjgsqj31060fhwhn.jpg" alt=""></p>
<p>可以看到购买当前域名的价格（部分域名包含<a href="https://www.namecheap.com/legal/domains/icann-fee.aspx" target="_blank" rel="external">ICANN fee</a>），注意 Namecheap 送免费的 WhoisGuard ！好良心有木有！确认好了之后就可以点击右侧的 <em>Confirm Order</em> ，进入付款页面</p>
<p><img src="http://ww1.sinaimg.cn/large/006y8lVajw1f9qbk7xu54j31270icwgy.jpg" alt=""></p>
<p>付款方式选方便自己的（PayPal 支持银联袄！）</p>
<p>下方是账单地址，这个根据自己的情况填就可以，博主就不贴出来了</p>
<p><strong>注意</strong> 下方的续期选项，如果到期后不想续期就把下面的对勾<em>取消</em>掉</p>
<p><img src="http://ww1.sinaimg.cn/large/006y8lVajw1f9qbmqknxdj30sh0iftan.jpg" alt=""></p>
<p>确认信息无误，点击 <em>Continue</em>，进入付款页面。付款完成，等待 Namecheap 确认完成后即可进入控制台管理自己的域名。</p>
<h2 id="域名管理"><a href="#域名管理" class="headerlink" title="域名管理"></a>域名管理</h2><p><img src="http://ww3.sinaimg.cn/large/006y8lVajw1f9qbp55v72j311j0ejjtm.jpg" alt=""></p>
<p>点击 <em>MANAGE</em>，看看到如下界面</p>
<p><img src="http://ww3.sinaimg.cn/large/006y8lVajw1f9qbqqjtw9j312k0m20vs.jpg" alt=""></p>
<p>博主选择了国内的 DNSPod 免费域名解析服务，可以很方便得设置国内国外分别走不同线路，推荐您跟我一样进行设置。</p>
<p>在<em>NAMESERVERS</em>处选择<em>Custom DNS</em> ，然后填入以下两个 DNS： f1g1ns1.dnspod.net 和  f1g1ns2.dnspod.net 。填好后，点击该部分右上角的对勾保存设置。</p>
<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><h3 id="DNSPod-的设置"><a href="#DNSPod-的设置" class="headerlink" title="DNSPod 的设置"></a>DNSPod 的设置</h3><p>到 <a href="www.dnspod.cn">DNSPod</a> 注册并登录（可直接使用 QQ 账号登录），然后点击左侧的<em>域名解析</em>，再点击<em>添加域名</em></p>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f9qc5q9e7fj30z40ch0wg.jpg" alt=""></p>
<p>输入你注册的域名，点击确定后系统会自动扫描已有 DNS 记录</p>
<p><img src="http://ww4.sinaimg.cn/large/006y8lVajw1f9qc796ks5j30mg0by3zd.jpg" alt=""></p>
<p>点击<em>添加记录</em> </p>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f9qc9bhmeyj30m90a80u2.jpg" alt=""></p>
<p>鼠标每移动到每一项均有说明。</p>
<blockquote>
<p>如果只添加了 @ 的记录，那么别人就无法通过 www.yoursite.com 访问你的网站</p>
<p><em>记录值</em>为你要定向到的地址，比如我想别人在访问我的域名时获取我的 github pages 上的内容，所以<em>记录值</em> 处应该填 ChuanfengZhang.github.io.</p>
<p>同样也给 coding 添加记录</p>
</blockquote>
<p><strong>github pages 的<em>线路类型选国外</em>，这样国外的网友访问你的域名时会解析到 github，比 coding 速度更快</strong></p>
<p>设置好了以后我们需要分别到 github 和 coding 设置。</p>
<h3 id="github-的设置"><a href="#github-的设置" class="headerlink" title="github 的设置"></a>github 的设置</h3><p>进入到 github 上你的博客仓库，点击<em>Create new file</em> 在建立一个名为<strong>CNAME</strong>的文件（文件名大写），文件内容为你的域名。</p>
<h3 id="coding-的设置"><a href="#coding-的设置" class="headerlink" title="coding 的设置"></a>coding 的设置</h3><p>coding 设置相对来说简单些，只需在自定义域名输入框输入你的域名，点击添加即可</p>
<p><img src="http://ww4.sinaimg.cn/large/006y8lVajw1f9qcogtv88j30y30hm420.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们的域名申请和解析工作就完成了，访问你的域名看能不能显示出你的博客呢？</p>
<p><img src="http://ww1.sinaimg.cn/large/006y8lVajw1f9qcqub2kpj312q0k3n0x.jpg" alt=""></p>
<p>如果你在这个过程中遇到了什么问题或者有什么疑问，欢迎在评论中写出或通过其他方式联系我:-)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;域名申请与解析&quot;&gt;&lt;a href=&quot;#域名申请与解析&quot; class=&quot;headerlink&quot; title=&quot;域名申请与解析&quot;&gt;&lt;/a&gt;域名申请与解析&lt;/h1&gt;&lt;h2 id=&quot;初衷&quot;&gt;&lt;a href=&quot;#初衷&quot; class=&quot;headerlink&quot; title=&quot;初衷&quot;&gt;&lt;/a&gt;初衷&lt;/h2&gt;&lt;p&gt;个人博客的网址是 github.io 一类的网址未免普通（Bigger 不够），而博主想正好借这次机会体验一下购买域名的流程，所以就开始选服务商啦！&lt;br&gt;
    
    </summary>
    
    
      <category term="建站" scheme="http://zhangchuanfeng.me/tags/%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>将hexo博客同时托管到 github 和 coding</title>
    <link href="http://zhangchuanfeng.me/2016/11/12/%E5%B0%86hexo%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%97%B6%E6%89%98%E7%AE%A1%E5%88%B0%20github%20%E5%92%8C%20coding/"/>
    <id>http://zhangchuanfeng.me/2016/11/12/将hexo博客同时托管到 github 和 coding/</id>
    <published>2016-11-12T13:01:20.000Z</published>
    <updated>2016-11-13T09:43:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前我们把hexo托管在github，但是毕竟github是国外的，访问速度上还是有点慢，所以想也部署一套在国内的托管平台，国内目前比较好的就是 coding 了。接下来就看下怎样将hexo博客同时托管到 github 和 coding<br><a id="more"></a></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><hr>
<p>_config.yml 配置</p>
<hr>
<p>之前只部署到一个平台时，_config.yml 内容是这样的：  </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">deploy:</span></div><div class="line"><span class="attr">  type:</span> git</div><div class="line"><span class="attr">  repository:</span> git@github.com:ChuanfengZhang/ChuanfengZhang.github.io.git</div><div class="line"><span class="attr">  branch:</span> master</div></pre></td></tr></table></figure>
<p>如果我们想同时部署到两个平台，就需要将其改为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">deploy:</span></div><div class="line"><span class="attr">  type:</span> git</div><div class="line"><span class="attr">  repository:</span></div><div class="line"><span class="attr">    github:</span> git@github.com:ChuanfengZhang/ChuanfengZhang.github.io.git,master</div><div class="line"><span class="attr">    coding:</span> https://git.coding.net/chuanfengzhang/chuanfengzhang.git,master</div></pre></td></tr></table></figure>
<p><strong>注意：coding 仓库创建以及配置等内容与 github 类似，在此就不展开了</strong>  </p>
<p>将 hexo 部署到 coding 后，推荐使用 pages 方式，因为可以绑定域名。pages 方式也很简单，就是在 source/ 创建一个空白文件，至于原因，是因为 coding 需要这个文件来作为以静态文件部署的标志。就是说看到这个Staticfile就知道按照静态文件来发布。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd source/</div><div class="line">touch Staticfile  #名字必须是Staticfile</div></pre></td></tr></table></figure>
<p><img src="http://ww3.sinaimg.cn/large/006y8lVajw1f9pmwinfj1j313u0i3dkz.jpg" alt=""></p>
<p>然后开启 pages 服务即可</p>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVajw1f9pn4aa9scj313u0hsdkz.jpg" alt=""></p>
<p>点击页面提示的地址就可以访问了。</p>
<p>以后执行<code>hexo d -g</code>就可以同时部署到 github 和 conding 了，是不是很方便呢？</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<p><a href="http://www.jianshu.com/p/7ad9d3cd4d6e" target="_blank" rel="external">hexo干货系列：（四）将hexo博客同时托管到github和coding</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>这么一设置，以后就方便同时部署到两个平台了，为以后国内国外分别访问两个平台的 pages 打下了基础，下一篇文章是关于域名申请和解析的，敬请期待哦！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前我们把hexo托管在github，但是毕竟github是国外的，访问速度上还是有点慢，所以想也部署一套在国内的托管平台，国内目前比较好的就是 coding 了。接下来就看下怎样将hexo博客同时托管到 github 和 coding&lt;br&gt;
    
    </summary>
    
    
      <category term="建站" scheme="http://zhangchuanfeng.me/tags/%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>域名不加www无法访问?</title>
    <link href="http://zhangchuanfeng.me/2016/11/12/%E5%9F%9F%E5%90%8D%E4%B8%8D%E5%8A%A0www%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE?/"/>
    <id>http://zhangchuanfeng.me/2016/11/12/域名不加www无法访问?/</id>
    <published>2016-11-12T12:18:47.000Z</published>
    <updated>2016-11-12T12:52:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>问：我的网站<a href="www.zhangchuanfeng.me">www.zhangchuanfeng.me</a>，为何输www.zhangchuanfeng.me可以打开，而直接输入zhangchuanfeng.me打不开？</p>
<p>答：虚拟主机开通的时候默认只绑定www.abcd.com,所以abcd.com需要绑定后才能打开。<br>操作步骤：<br><a id="more"></a>  </p>
<ol>
<li><p>登录管理中心，点 业务管理&gt;域名服务，找到相关的域名，点 管理，然后点 dns解析管理,点　增加ip,</p>
<p>添加: A 记录<br>主机名:    填入 @<br>对应值:    填入你的虚拟主机ip (在　虚拟主机管理中心可以查到）<br>(注意： 这一步一般已经由我们的程序自动完成了，如果您发现在：dns解析管理中 有一个@记录，指向了你的ip,你就可以跳过这一步了）。   </p>
<p>​</p>
</li>
<li><p>点业务管理&gt;虚拟主机管理　</p>
<p>在域名绑定一栏　输入您想绑定的域名zhangchuanfeng.me,然后点添加就行了。</p>
</li>
</ol>
<p>这样，您就可以直接输入zhangchuanfeng.me打开你的网站了。</p>
<p>如果你想绑定其他的域名，其步骤也是一样的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问：我的网站&lt;a href=&quot;www.zhangchuanfeng.me&quot;&gt;www.zhangchuanfeng.me&lt;/a&gt;，为何输www.zhangchuanfeng.me可以打开，而直接输入zhangchuanfeng.me打不开？&lt;/p&gt;
&lt;p&gt;答：虚拟主机开通的时候默认只绑定www.abcd.com,所以abcd.com需要绑定后才能打开。&lt;br&gt;操作步骤：&lt;br&gt;
    
    </summary>
    
    
      <category term="建站" scheme="http://zhangchuanfeng.me/tags/%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>我的博客建好啦！</title>
    <link href="http://zhangchuanfeng.me/2016/11/10/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%BB%BA%E5%A5%BD%E5%95%A6%EF%BC%81/"/>
    <id>http://zhangchuanfeng.me/2016/11/10/我的博客建好啦！/</id>
    <published>2016-11-10T11:27:23.000Z</published>
    <updated>2016-11-11T03:26:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>跟着<a href="http://leopardpan.github.io" target="_blank" rel="external">潘柏信的博客</a>教程一步一步搭建起来的，比想象中简单。<br>下一步就换主题咯！<br>双11没有买买买，只有学学学！(^o^)/</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跟着&lt;a href=&quot;http://leopardpan.github.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;潘柏信的博客&lt;/a&gt;教程一步一步搭建起来的，比想象中简单。&lt;br&gt;下一步就换主题咯！&lt;br&gt;双11没有买买买，只有学学学！(^o^)
    
    </summary>
    
    
      <category term="随笔" scheme="http://zhangchuanfeng.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
